diff --git a/BUILD b/BUILD
index 7de87f884..18c42434d 100644
--- a/BUILD
+++ b/BUILD
@@ -230,6 +230,12 @@ cc_library(
         "src/google/protobuf/util/type_resolver_util.cc",
         "src/google/protobuf/wire_format.cc",
         "src/google/protobuf/wrappers.pb.cc",
+        "src/google/protobuf/patch/inlined_arenastring_field.cc",
+        "src/google/protobuf/patch/repeated_arenastring_field.cc",
+        "src/google/protobuf/patch/extension_set_with_arenastring.cc",
+        "src/google/protobuf/patch/extension_set_heavy_with_arenastring.cc",
+        "src/google/protobuf/patch/arenastring.cc",
+        "src/google/protobuf/patch/arenastring_impl.cc",
     ],
     hdrs = glob([
         "src/**/*.h",
diff --git a/cmake/extract_includes.bat.in b/cmake/extract_includes.bat.in
index 97c6b715f..d4ffb7da4 100644
--- a/cmake/extract_includes.bat.in
+++ b/cmake/extract_includes.bat.in
@@ -13,12 +13,19 @@ mkdir include\google\protobuf\compiler\ruby
 mkdir include\google\protobuf\io
 mkdir include\google\protobuf\stubs
 mkdir include\google\protobuf\util
+mkdir include\google\protobuf\patch
 copy "${PROTOBUF_SOURCE_WIN32_PATH}\..\src\google\protobuf\any.h" include\google\protobuf\any.h
 copy "${PROTOBUF_SOURCE_WIN32_PATH}\..\src\google\protobuf\any.pb.h" include\google\protobuf\any.pb.h
 copy "${PROTOBUF_SOURCE_WIN32_PATH}\..\src\google\protobuf\api.pb.h" include\google\protobuf\api.pb.h
 copy "${PROTOBUF_SOURCE_WIN32_PATH}\..\src\google\protobuf\arena.h" include\google\protobuf\arena.h
 copy "${PROTOBUF_SOURCE_WIN32_PATH}\..\src\google\protobuf\arena_impl.h" include\google\protobuf\arena_impl.h
 copy "${PROTOBUF_SOURCE_WIN32_PATH}\..\src\google\protobuf\arenastring.h" include\google\protobuf\arenastring.h
+copy "${PROTOBUF_SOURCE_WIN32_PATH}\..\src\google\protobuf\patch\inlined_arenastring_field.h" include\google\protobuf\patch\inlined_arenastring_field.h
+copy "${PROTOBUF_SOURCE_WIN32_PATH}\..\src\google\protobuf\patch\repeated_arenastring_field.h" include\google\protobuf\patch\repeated_arenastring_field.h
+copy "${PROTOBUF_SOURCE_WIN32_PATH}\..\src\google\protobuf\patch\extension_set_with_arenastring.h" include\google\protobuf\patch\extension_set_with_arenastring.h
+copy "${PROTOBUF_SOURCE_WIN32_PATH}\..\src\google\protobuf\patch\extension_set_inl_with_arenastring.h" include\google\protobuf\patch\extension_set_inl_with_arenastring.h
+copy "${PROTOBUF_SOURCE_WIN32_PATH}\..\src\google\protobuf\patch\arenastring.h" include\google\protobuf\patch\arenastring.h
+copy "${PROTOBUF_SOURCE_WIN32_PATH}\..\src\google\protobuf\patch\arenastring_impl.h" include\google\protobuf\patch\arenastring_impl.h
 copy "${PROTOBUF_SOURCE_WIN32_PATH}\..\src\google\protobuf\compiler\code_generator.h" include\google\protobuf\compiler\code_generator.h
 copy "${PROTOBUF_SOURCE_WIN32_PATH}\..\src\google\protobuf\compiler\command_line_interface.h" include\google\protobuf\compiler\command_line_interface.h
 copy "${PROTOBUF_SOURCE_WIN32_PATH}\..\src\google\protobuf\compiler\cpp\cpp_generator.h" include\google\protobuf\compiler\cpp\cpp_generator.h
diff --git a/cmake/libprotobuf.cmake b/cmake/libprotobuf.cmake
index d39446733..0701838c2 100644
--- a/cmake/libprotobuf.cmake
+++ b/cmake/libprotobuf.cmake
@@ -52,6 +52,12 @@ set(libprotobuf_files
   ${protobuf_source_dir}/src/google/protobuf/util/type_resolver_util.cc
   ${protobuf_source_dir}/src/google/protobuf/wire_format.cc
   ${protobuf_source_dir}/src/google/protobuf/wrappers.pb.cc
+  ${protobuf_source_dir}/src/google/protobuf/patch/arenastring.cc
+  ${protobuf_source_dir}/src/google/protobuf/patch/arenastring_impl.cc
+  ${protobuf_source_dir}/src/google/protobuf/patch/inlined_arenastring_field.cc
+  ${protobuf_source_dir}/src/google/protobuf/patch/repeated_arenastring_field.cc
+  ${protobuf_source_dir}/src/google/protobuf/patch/extension_set_with_arenastring.cc
+  ${protobuf_source_dir}/src/google/protobuf/patch/extension_set_heavy_with_arenastring.cc
 )
 
 set(libprotobuf_includes
@@ -107,6 +113,12 @@ set(libprotobuf_includes
   ${protobuf_source_dir}/src/google/protobuf/util/type_resolver_util.h
   ${protobuf_source_dir}/src/google/protobuf/wire_format.h
   ${protobuf_source_dir}/src/google/protobuf/wrappers.pb.h
+  ${protobuf_source_dir}/src/google/protobuf/patch/arenastring.h
+  ${protobuf_source_dir}/src/google/protobuf/patch/arenastring_impl.h
+  ${protobuf_source_dir}/src/google/protobuf/patch/inlined_arenastring_field.h
+  ${protobuf_source_dir}/src/google/protobuf/patch/repeated_arenastring_field.h
+  ${protobuf_source_dir}/src/google/protobuf/patch/extension_set_with_arenastring.h
+  ${protobuf_source_dir}/src/google/protobuf/patch/extension_set_inl_with_arenastring.h
 )
 
 if (CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
diff --git a/src/Makefile.am b/src/Makefile.am
index 3da92e750..d8f676e66 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -174,6 +174,12 @@ nobase_include_HEADERS =                                         \
   google/protobuf/util/type_resolver_util.h                      \
   google/protobuf/wire_format.h                                  \
   google/protobuf/wire_format_lite.h                             \
+  google/protobuf/patch/arenastring.h                            \
+  google/protobuf/patch/arenastring_impl.h                       \
+  google/protobuf/patch/inlined_arenastring_field.h              \
+  google/protobuf/patch/repeated_arenastring_field.h             \
+  google/protobuf/patch/extension_set_with_arenastring.h         \
+  google/protobuf/patch/extension_set_inl_with_arenastring.h     \
   google/protobuf/wrappers.pb.h
 
 lib_LTLIBRARIES = libprotobuf-lite.la libprotobuf.la libprotoc.la
@@ -312,6 +318,12 @@ libprotobuf_la_SOURCES =                                       \
   google/protobuf/util/time_util.cc                            \
   google/protobuf/util/type_resolver_util.cc                   \
   google/protobuf/wire_format.cc                               \
+  google/protobuf/patch/arenastring.cc                         \
+  google/protobuf/patch/arenastring_impl.cc                    \
+  google/protobuf/patch/inlined_arenastring_field.cc           \
+  google/protobuf/patch/repeated_arenastring_field.cc          \
+  google/protobuf/patch/extension_set_with_arenastring.cc      \
+  google/protobuf/patch/extension_set_heavy_with_arenastring.cc \
   google/protobuf/wrappers.pb.cc
 
 nodist_libprotobuf_la_SOURCES = $(nodist_libprotobuf_lite_la_SOURCES)
diff --git a/src/google/protobuf/arena.h b/src/google/protobuf/arena.h
index 8b1a6b577..dc37bc310 100644
--- a/src/google/protobuf/arena.h
+++ b/src/google/protobuf/arena.h
@@ -754,6 +754,8 @@ class PROTOBUF_EXPORT PROTOBUF_ALIGNAS(8) Arena final {
     return nullptr;
   }
 
+  // AllocateAligned() change to public api which is used by arenastring_impl
+ public:
   // For friends of arena.
   void* AllocateAligned(size_t n, size_t align = 8) {
     if (align <= 8) {
@@ -767,6 +769,7 @@ class PROTOBUF_EXPORT PROTOBUF_ALIGNAS(8) Arena final {
       return internal::AlignTo(AllocateAlignedNoHook(n + align - 8), align);
     }
   }
+ private:
 
   void* AllocateAlignedWithHook(size_t n, size_t align,
                                 const std::type_info* type) {
diff --git a/src/google/protobuf/compiler/cpp/cpp_extension.cc b/src/google/protobuf/compiler/cpp/cpp_extension.cc
index 670c37f5b..b586972ba 100644
--- a/src/google/protobuf/compiler/cpp/cpp_extension.cc
+++ b/src/google/protobuf/compiler/cpp/cpp_extension.cc
@@ -65,6 +65,9 @@ ExtensionGenerator::ExtensionGenerator(const FieldDescriptor* descriptor,
     type_traits_ = "Repeated";
   }
 
+  bool enable_donated_string = descriptor_->file()->options().cc_enable_arenas()
+                               && descriptor_->file()->options().cc_mutable_donated_string();
+
   switch (descriptor_->cpp_type()) {
     case FieldDescriptor::CPPTYPE_ENUM:
       type_traits_.append("EnumTypeTraits< ");
@@ -74,7 +77,11 @@ ExtensionGenerator::ExtensionGenerator(const FieldDescriptor* descriptor,
       type_traits_.append("_IsValid>");
       break;
     case FieldDescriptor::CPPTYPE_STRING:
-      type_traits_.append("StringTypeTraits");
+      if (enable_donated_string) {
+        type_traits_.append("ArenaStringTypeTraits");
+      } else {
+        type_traits_.append("StringTypeTraits");
+      }
       break;
     case FieldDescriptor::CPPTYPE_MESSAGE:
       type_traits_.append("MessageTypeTraits< ");
diff --git a/src/google/protobuf/compiler/cpp/cpp_helpers.cc b/src/google/protobuf/compiler/cpp/cpp_helpers.cc
index 937a42a4d..e58307466 100644
--- a/src/google/protobuf/compiler/cpp/cpp_helpers.cc
+++ b/src/google/protobuf/compiler/cpp/cpp_helpers.cc
@@ -777,9 +777,15 @@ std::string SafeFunctionName(const Descriptor* descriptor,
   return function_name;
 }
 
-bool IsStringInlined(const FieldDescriptor* /* descriptor */,
+bool IsStringInlined(const FieldDescriptor* descriptor,
                      const Options& /* options */) {
-  return false;
+  return descriptor->file()->options().cc_mutable_donated_string()
+      && descriptor->cpp_type() == FieldDescriptor::CPPTYPE_STRING
+      && !descriptor->is_repeated()
+      && !descriptor->containing_type()->options().map_entry()
+      && !descriptor->real_containing_oneof()
+      && !descriptor->has_default_value()
+      && descriptor->file()->options().cc_enable_arenas();
 }
 
 static bool HasLazyFields(const Descriptor* descriptor, const Options& options,
diff --git a/src/google/protobuf/compiler/cpp/cpp_message.cc b/src/google/protobuf/compiler/cpp/cpp_message.cc
index c29be76c0..7f58cc023 100644
--- a/src/google/protobuf/compiler/cpp/cpp_message.cc
+++ b/src/google/protobuf/compiler/cpp/cpp_message.cc
@@ -1882,9 +1882,19 @@ void MessageGenerator::GenerateClassDefinition(io::Printer* printer) {
   // Members assumed to align to 8 bytes:
 
   if (descriptor_->extension_range_count() > 0) {
-    format(
-        "::$proto_ns$::internal::ExtensionSet _extensions_;\n"
-        "\n");
+    // TODO: check enable cc_mutable_arena_string
+    // use additional class definition
+    bool enable_donated_string = descriptor_->file()->options().cc_enable_arenas()
+                               && descriptor_->file()->options().cc_mutable_donated_string();
+    if (enable_donated_string) {
+      format(
+          "::$proto_ns$::internal::ExtensionSetWithArenaString _extensions_;\n"
+          "\n");
+    } else {
+      format(
+          "::$proto_ns$::internal::ExtensionSet _extensions_;\n"
+          "\n");
+    }
   }
 
   if (options_.field_listener_options.inject_field_listener_events &&
@@ -2068,19 +2078,27 @@ bool MessageGenerator::GenerateParseTable(io::Printer* printer, size_t offset,
 void MessageGenerator::GenerateSchema(io::Printer* printer, int offset,
                                       int has_offset) {
   Formatter format(printer, variables_);
-  has_offset = !has_bit_indices_.empty() || IsMapEntryMessage(descriptor_)
-                   ? offset + has_offset
-                   : -1;
+  // 一个Message的使用的schema信息在offset段中构成是
+  // <metadata>[has_bit_indices][inlined_string_indices]
+  // has_offset = sizeof(metadata)
+  // offset = base offset of metadata
+  // 原先的写法当has_bit_indices为空，但inlined_string_indices非空时
+  // 无法正确支持，可能和这段从google开源过程中的删减有关
+  // 这里按照远离调整为能够正确计算
+  int has_bit_indices_offset = !has_bit_indices_.empty() || IsMapEntryMessage(descriptor_)
+                               ? offset + has_offset
+                               : -1;
   int inlined_string_indices_offset;
   if (inlined_string_indices_.empty()) {
     inlined_string_indices_offset = -1;
   } else {
     GOOGLE_DCHECK_NE(has_offset, -1);
     GOOGLE_DCHECK(!IsMapEntryMessage(descriptor_));
-    inlined_string_indices_offset = has_offset + has_bit_indices_.size();
+    // inlined_string_indices_offset = has_offset + has_bit_indices_.size();
+    inlined_string_indices_offset = offset + has_offset + has_bit_indices_.size();
   }
 
-  format("{ $1$, $2$, $3$, sizeof($classtype$)},\n", offset, has_offset,
+  format("{ $1$, $2$, $3$, sizeof($classtype$)},\n", offset, has_bit_indices_offset,
          inlined_string_indices_offset);
 }
 
diff --git a/src/google/protobuf/compiler/cpp/cpp_string_field.cc b/src/google/protobuf/compiler/cpp/cpp_string_field.cc
index be19310df..4a380e34e 100644
--- a/src/google/protobuf/compiler/cpp/cpp_string_field.cc
+++ b/src/google/protobuf/compiler/cpp/cpp_string_field.cc
@@ -60,6 +60,9 @@ void SetStringVariables(const FieldDescriptor* descriptor,
     (*variables)["lazy_variable"] =
         QualifiedClassName(descriptor->containing_type(), options) +
         "::" + default_variable_string;
+    (*variables)["lazy_variable_args"] = (*variables)["lazy_variable"] + ", ";
+  } else {
+    (*variables)["lazy_variable_args"] = "";
   }
 
   (*variables)["default_string"] =
@@ -118,7 +121,7 @@ void StringFieldGenerator::GeneratePrivateMembers(io::Printer* printer) const {
   } else {
     // `_init_inline_xxx` is used for initializing default instances.
     format(
-        "::$proto_ns$::internal::InlinedStringField $name$_;\n"
+        "::$proto_ns$::internal::InlinedArenaStringField $name$_;\n"
         "static std::true_type _init_inline_$name$_;\n");
   }
 }
@@ -168,8 +171,23 @@ void StringFieldGenerator::GenerateAccessorDeclarations(
       "template <typename ArgT0 = const std::string&, typename... ArgT>\n"
       "$deprecated_attr$void ${1$set_$name$$}$(ArgT0&& arg0, ArgT... args);\n",
       descriptor_);
+
+  // StringField declaration
+  // check cc_mutable_donated_string option
+  bool enable_donated_string = descriptor_->file()->options().cc_enable_arenas()
+                               && descriptor_->file()->options().cc_mutable_donated_string();
+  if (enable_donated_string && inlined_) {
+    format(
+        "$deprecated_attr$::$proto_ns$::MaybeArenaStringAccessor ${1$mutable_$name$$}$();\n",
+        descriptor_);
+  } else {
+    format(
+        "$deprecated_attr$std::string* ${1$mutable_$name$$}$();\n",
+        descriptor_);
+  }
+
   format(
-      "$deprecated_attr$std::string* ${1$mutable_$name$$}$();\n"
+      //"$deprecated_attr$std::string* ${1$mutable_$name$$}$();\n"
       "PROTOBUF_MUST_USE_RESULT $deprecated_attr$std::string* "
       "${1$$release_name$$}$();\n"
       "$deprecated_attr$void ${1$set_allocated_$name$$}$(std::string* "
@@ -181,6 +199,12 @@ void StringFieldGenerator::GenerateAccessorDeclarations(
       "inline PROTOBUF_ALWAYS_INLINE void "
       "_internal_set_$name$(const std::string& value);\n"
       "std::string* _internal_mutable_$name$();\n");
+
+  // add internal arenastring impl
+  if (enable_donated_string) {
+    format("$proto_ns$::MaybeArenaStringAccessor _internal_mutable_$name$_accessor();\n");
+  }
+
   if (inlined_) {
     format(
         "inline PROTOBUF_ALWAYS_INLINE bool _internal_$name$_donated() "
@@ -227,9 +251,9 @@ void StringFieldGenerator::GenerateInlineAccessorDefinitions(
         "inline PROTOBUF_ALWAYS_INLINE\n"
         "void $classname$::set_$name$(ArgT0&& arg0, ArgT... args) {\n"
         " $set_hasbit$\n"
-        " $name$_.$setter$(nullptr, static_cast<ArgT0 &&>(arg0),"
+        " $name$_.$setter$(static_cast<ArgT0 &&>(arg0),"
         " args..., GetArenaForAllocation(), _internal_$name$_donated(), "
-        "&$donating_states_word$, $mask_for_undonate$);\n"
+        "&$donating_states_word$, $mask_for_undonate$, this);\n"
         "$annotate_set$"
         "  // @@protoc_insertion_point(field_set:$full_name$)\n"
         "}\n"
@@ -238,9 +262,24 @@ void StringFieldGenerator::GenerateInlineAccessorDefinitions(
         "  return value;\n"
         "}\n");
   }
+
+  // StringField definition
+  // check cc_mutable_donated_string option
+  bool enable_donated_string = descriptor_->file()->options().cc_enable_arenas()
+                               && descriptor_->file()->options().cc_mutable_donated_string();
+  if (enable_donated_string) {
+    format(
+        "inline $proto_ns$::MaybeArenaStringAccessor $classname$::mutable_$name$() {\n"
+        "  auto _s = _internal_mutable_$name$_accessor();\n");
+  } else {
+    format(
+        "inline std::string* $classname$::mutable_$name$() {\n"
+        "  auto _s = _internal_mutable_$name$();\n");
+  }
+
   format(
-      "inline std::string* $classname$::mutable_$name$() {\n"
-      "  std::string* _s = _internal_mutable_$name$();\n"
+      //"inline std::string* $classname$::mutable_$name$() {\n"
+      //"  std::string* _s = _internal_mutable_$name$();\n"
       "$annotate_mutable$"
       "  // @@protoc_insertion_point(field_mutable:$full_name$)\n"
       "  return _s;\n"
@@ -256,12 +295,20 @@ void StringFieldGenerator::GenerateInlineAccessorDefinitions(
         "  $name$_.Set($default_value_tag$, value, GetArenaForAllocation());\n"
         "}\n");
   } else {
+#if 0
     format(
         "  $name$_.Set(nullptr, value, GetArenaForAllocation(),\n"
         "    _internal_$name$_donated(), &$donating_states_word$, "
         "$mask_for_undonate$);\n"
         "}\n");
+#endif
+    format(
+        "  $name$_.Set(value, GetArenaForAllocation(),\n"
+        "    _internal_$name$_donated(), &$donating_states_word$, "
+        "$mask_for_undonate$, this);\n"
+        "}\n");
   }
+
   format(
       "inline std::string* $classname$::_internal_mutable_$name$() {\n"
       "  $set_hasbit$\n");
@@ -272,11 +319,21 @@ void StringFieldGenerator::GenerateInlineAccessorDefinitions(
         "}\n");
   } else {
     format(
-        "  return $name$_.Mutable($default_variable_or_tag$, "
+        "  return $name$_.Mutable($lazy_variable_args$"
         "GetArenaForAllocation(), _internal_$name$_donated(), "
-        "&$donating_states_word$, $mask_for_undonate$);\n"
+        "&$donating_states_word$, $mask_for_undonate$, this);\n"
+        "}\n");
+  }
+
+  if (enable_donated_string) {
+    format(
+        "inline ::google::protobuf::MaybeArenaStringAccessor $classname$::_internal_mutable_$name$_accessor() {\n"
+        "  $set_hasbit$\n"
+        "  return $name$_.MutableAccessor($lazy_variable_args$ GetArenaForAllocation(), "
+        "_internal_$name$_donated(), &$donating_states_word$, $mask_for_undonate$, this);\n"
         "}\n");
   }
+
   format(
       "inline std::string* $classname$::$release_name$() {\n"
       "$annotate_release$"
@@ -294,12 +351,18 @@ void StringFieldGenerator::GenerateInlineAccessorDefinitions(
           "GetArenaForAllocation());\n");
     } else {
       format(
-          "  return $name$_.Release(nullptr, GetArenaForAllocation(), "
+          "  return $name$_.Release(GetArenaForAllocation(), "
           "_internal_$name$_donated());\n");
     }
   } else {
-    format(
+    if (!inlined_) {
+      format(
         "  return $name$_.Release($init_value$, GetArenaForAllocation());\n");
+    } else {
+      format(
+          "  return $name$_.Release(GetArenaForAllocation(), "
+          "_internal_$name$_donated());\n");
+    }
   }
 
   format(
@@ -319,7 +382,7 @@ void StringFieldGenerator::GenerateInlineAccessorDefinitions(
     format(
         "    $name$_.SetAllocated(nullptr, $name$, GetArenaForAllocation(), "
         "_internal_$name$_donated(), &$donating_states_word$, "
-        "$mask_for_undonate$);\n");
+        "$mask_for_undonate$, this);\n");
   }
   format(
       "$annotate_set$"
@@ -404,13 +467,12 @@ void StringFieldGenerator::GenerateSwappingCode(io::Printer* printer) const {
         "    &other->$name$_, rhs_arena\n"
         ");\n");
   } else {
-    // At this point, it's guaranteed that the two fields being swapped are on
-    // the same arena.
     format(
-        "$name$_.Swap(&other->$name$_, nullptr, GetArenaForAllocation(), "
-        "_internal_$name$_donated(), other->_internal_$name$_donated(), "
-        "&$donating_states_word$, &(other->$donating_states_word$), "
-        "$mask_for_undonate$);\n");
+        "::$proto_ns$::internal::InlinedArenaStringField::InternalSwap(\n"
+        "  &$name$_, GetArenaForAllocation(), "
+        "_internal_$name$_donated(), this,\n"
+        "  &other->$name$_, other->GetArenaForAllocation(), "
+        "_internal_$name$_donated(), other);\n");
   }
 }
 
@@ -442,10 +504,10 @@ void StringFieldGenerator::GenerateCopyConstructorCode(
         "$name$_.Set($default_value_tag$, from._internal_$name$(), \n"
         "  GetArenaForAllocation());\n");
   } else {
-    format(
-        "$name$_.Set(nullptr, from._internal_$name$(),\n"
+   format(
+        "$name$_.Set(from._internal_$name$(),\n"
         "  GetArenaForAllocation(), _internal_$name$_donated(), "
-        "&$donating_states_word$, $mask_for_undonate$);\n");
+        "&$donating_states_word$, $mask_for_undonate$, this);\n");
   }
 
   format.Outdent();
@@ -532,9 +594,24 @@ void StringOneofFieldGenerator::GenerateInlineAccessorDefinitions(
       " static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());\n"
       "$annotate_set$"
       "  // @@protoc_insertion_point(field_set:$full_name$)\n"
-      "}\n"
-      "inline std::string* $classname$::mutable_$name$() {\n"
-      "  std::string* _s = _internal_mutable_$name$();\n"
+      "}\n");
+
+  // StringOneofField definition
+  // check cc_mutable_donated_string option
+  bool enable_donated_string = descriptor_->file()->options().cc_enable_arenas()
+                               && descriptor_->file()->options().cc_mutable_donated_string();
+  enable_donated_string = IsStringInlined(descriptor_, options_) && enable_donated_string;
+  if (enable_donated_string) {
+    format(
+        "inline $proto_ns$::MaybeArenaStringAccessor $classname$::mutable_$name$() {\n"
+        "  auto _s = _internal_mutable_$name$_accessor();\n");
+  } else {
+    format(
+        "inline std::string* $classname$::mutable_$name$() {\n"
+        "  auto _s = _internal_mutable_$name$();\n");
+  }
+
+  format(
       "$annotate_mutable$"
       "  // @@protoc_insertion_point(field_mutable:$full_name$)\n"
       "  return _s;\n"
@@ -555,6 +632,22 @@ void StringOneofFieldGenerator::GenerateInlineAccessorDefinitions(
       "  $field_member$.Set($default_value_tag$, value, "
       "GetArenaForAllocation());\n"
       "}\n");
+
+#if 0
+  if (enable_donated_string) {
+    format(
+     "inline ::google::protobuf::MaybeArenaStringAccessor $classname$::_internal_mutable_$name$_accessor() {\n"
+      "  if (!_internal_has_$name$()) {\n"
+      "    clear_$oneof_name$();\n"
+      "    set_has_$name$();\n"
+      "    $field_member$.InitDefault();\n"
+      "  }\n"
+      "  return $field_member$.MutableAccessor($lazy_variable_args$"
+      "      GetArenaForAllocation());\n"
+      "}\n");
+  }
+#endif
+
   format(
       "inline std::string* $classname$::_internal_mutable_$name$() {\n"
       "  if (!_internal_has_$name$()) {\n"
@@ -629,7 +722,13 @@ RepeatedStringFieldGenerator::~RepeatedStringFieldGenerator() {}
 void RepeatedStringFieldGenerator::GeneratePrivateMembers(
     io::Printer* printer) const {
   Formatter format(printer, variables_);
-  format("::$proto_ns$::RepeatedPtrField<std::string> $name$_;\n");
+  bool enable_donated_string = descriptor_->file()->options().cc_enable_arenas()
+                               && descriptor_->file()->options().cc_mutable_donated_string();
+  if (enable_donated_string) {
+    format("::$proto_ns$::RepeatedArenaPtrField<std::string> $name$_;\n");
+  } else {
+    format("::$proto_ns$::RepeatedPtrField<std::string> $name$_;\n");
+  }
 }
 
 void RepeatedStringFieldGenerator::GenerateAccessorDeclarations(
@@ -648,8 +747,23 @@ void RepeatedStringFieldGenerator::GenerateAccessorDeclarations(
   }
 
   format(
-      "$deprecated_attr$const std::string& ${1$$name$$}$(int index) const;\n"
-      "$deprecated_attr$std::string* ${1$mutable_$name$$}$(int index);\n"
+      "$deprecated_attr$const std::string& ${1$$name$$}$(int index) const;\n", descriptor_);
+
+  // repeated string field declaration
+  // check cc_mutable_donated_string option
+  bool enable_donated_string = descriptor_->file()->options().cc_enable_arenas()
+                               && descriptor_->file()->options().cc_mutable_donated_string();
+  if (enable_donated_string) {
+    format(
+        "$deprecated_attr$$proto_ns$::MaybeArenaStringAccessor ${1$mutable_$name$$}$(int index);\n",
+        descriptor_);
+  } else {
+    format(
+        "$deprecated_attr$std::string* ${1$mutable_$name$$}$(int index);\n",
+        descriptor_);
+  }
+
+  format(
       "$deprecated_attr$void ${1$set_$name$$}$(int index, const "
       "std::string& value);\n"
       "$deprecated_attr$void ${1$set_$name$$}$(int index, std::string&& "
@@ -665,8 +779,22 @@ void RepeatedStringFieldGenerator::GenerateAccessorDeclarations(
   }
   format(
       "$deprecated_attr$void ${1$set_$name$$}$("
-      "int index, const $pointer_type$* value, size_t size);\n"
-      "$deprecated_attr$std::string* ${1$add_$name$$}$();\n"
+      "int index, const $pointer_type$* value, size_t size);\n",
+      descriptor_);
+
+  // repeated string field declaration
+  // check cc_mutable_donated_string option
+  if (enable_donated_string) {
+    format(
+        "$deprecated_attr$$proto_ns$::MaybeArenaStringAccessor ${1$add_$name$$}$();\n",
+        descriptor_);
+  } else {
+    format(
+        "$deprecated_attr$std::string* ${1$add_$name$$}$();\n",
+        descriptor_);
+  }
+
+  format(
       "$deprecated_attr$void ${1$add_$name$$}$(const std::string& value);\n"
       "$deprecated_attr$void ${1$add_$name$$}$(std::string&& value);\n"
       "$deprecated_attr$void ${1$add_$name$$}$(const char* value);\n",
@@ -676,7 +804,25 @@ void RepeatedStringFieldGenerator::GenerateAccessorDeclarations(
         "$deprecated_attr$void ${1$add_$name$$}$(StringPiece value);\n",
         descriptor_);
   }
-  format(
+
+  if (enable_donated_string) {
+    format(
+      "$deprecated_attr$void ${1$add_$name$$}$(const $pointer_type$* "
+      "value, size_t size)"
+      ";\n"
+      "$deprecated_attr$const ::$proto_ns$::RepeatedArenaPtrField<std::string>& "
+      "${1$$name$$}$() "
+      "const;\n"
+      "$deprecated_attr$::$proto_ns$::RepeatedArenaPtrField<std::string>* "
+      "${1$mutable_$name$$}$()"
+      ";\n"
+      "private:\n"
+      "const std::string& ${1$_internal_$name$$}$(int index) const;\n"
+      "std::string* _internal_add_$name$();\n",
+      descriptor_);
+    format("::$proto_ns$::MaybeArenaStringAccessor _internal_add_$name$_accessor();\n");
+  } else {
+    format(
       "$deprecated_attr$void ${1$add_$name$$}$(const $pointer_type$* "
       "value, size_t size)"
       ";\n"
@@ -688,9 +834,10 @@ void RepeatedStringFieldGenerator::GenerateAccessorDeclarations(
       ";\n"
       "private:\n"
       "const std::string& ${1$_internal_$name$$}$(int index) const;\n"
-      "std::string* _internal_add_$name$();\n"
-      "public:\n",
+      "std::string* _internal_add_$name$();\n",
       descriptor_);
+  }
+  format("public:\n");
 
   if (unknown_ctype) {
     format.Outdent();
@@ -702,9 +849,24 @@ void RepeatedStringFieldGenerator::GenerateAccessorDeclarations(
 void RepeatedStringFieldGenerator::GenerateInlineAccessorDefinitions(
     io::Printer* printer) const {
   Formatter format(printer, variables_);
+
+  // repeated string field definition
+  // check cc_mutable_donated_string option
+  bool enable_donated_string = descriptor_->file()->options().cc_enable_arenas()
+                               && descriptor_->file()->options().cc_mutable_donated_string();
+  if (enable_donated_string) {
+    format(
+        "inline $proto_ns$::MaybeArenaStringAccessor $classname$::add_$name$() {\n"
+        "  auto _s = _internal_add_$name$_accessor();\n");
+  } else {
+    format(
+        "inline std::string* $classname$::add_$name$() {\n"
+        "  auto _s = _internal_add_$name$();\n");
+  }
+
   format(
-      "inline std::string* $classname$::add_$name$() {\n"
-      "  std::string* _s = _internal_add_$name$();\n"
+      //"inline std::string* $classname$::add_$name$() {\n"
+      //"  std::string* _s = _internal_add_$name$();\n"
       "$annotate_add_mutable$"
       "  // @@protoc_insertion_point(field_add_mutable:$full_name$)\n"
       "  return _s;\n"
@@ -728,12 +890,26 @@ void RepeatedStringFieldGenerator::GenerateInlineAccessorDefinitions(
       "$annotate_get$"
       "  // @@protoc_insertion_point(field_get:$full_name$)\n"
       "  return _internal_$name$(index);\n"
-      "}\n"
-      "inline std::string* $classname$::mutable_$name$(int index) {\n"
-      "$annotate_mutable$"
-      "  // @@protoc_insertion_point(field_mutable:$full_name$)\n"
-      "  return $name$_.Mutable(index);\n"
-      "}\n"
+      "}\n");
+
+  // repeated string field definition
+  // check cc_mutable_donated_string option
+  if (enable_donated_string) {
+    format(
+        "inline $proto_ns$::MaybeArenaStringAccessor $classname$::mutable_$name$(int index) {\n"
+        "$annotate_mutable$"
+        "  // @@protoc_insertion_point(field_mutable:$full_name$)\n"
+        "  return $name$_.MutableAccessor(index);\n"
+        "}\n");
+  } else {
+    format(
+        "inline std::string* $classname$::mutable_$name$(int index) {\n"
+        "$annotate_mutable$"
+        "  // @@protoc_insertion_point(field_mutable:$full_name$)\n"
+        "  return $name$_.Mutable(index);\n"
+        "}\n");
+  }
+  format(
       "inline void $classname$::set_$name$(int index, const std::string& "
       "value) "
       "{\n"
@@ -761,7 +937,43 @@ void RepeatedStringFieldGenerator::GenerateInlineAccessorDefinitions(
         "  // @@protoc_insertion_point(field_set_string_piece:$full_name$)\n"
         "}\n");
   }
-  format(
+
+  // repeated arena string
+  if (enable_donated_string) {
+    format(
+      "inline void "
+      "$classname$::set_$name$"
+      "(int index, const $pointer_type$* value, size_t size) {\n"
+      "  $name$_.Mutable(index)->assign(\n"
+      "    reinterpret_cast<const char*>(value), size);\n"
+      "$annotate_set$"
+      "  // @@protoc_insertion_point(field_set_pointer:$full_name$)\n"
+      "}\n"
+      "inline std::string* $classname$::_internal_add_$name$() {\n"
+      "  return $name$_.AddString();\n"
+      "}\n"
+      "inline ::$proto_ns$::MaybeArenaStringAccessor $classname$::_internal_add_$name$_accessor() {\n"
+      "  return $name$_.AddAccessor();\n"
+      "}\n"
+      "inline void $classname$::add_$name$(const std::string& value) {\n"
+      "  $name$_.AddAccessor()->assign(value);\n"
+      "$annotate_add$"
+      "  // @@protoc_insertion_point(field_add:$full_name$)\n"
+      "}\n"
+      "inline void $classname$::add_$name$(std::string&& value) {\n"
+      "  $name$_.Add(std::move(value));\n"
+      "$annotate_add$"
+      "  // @@protoc_insertion_point(field_add:$full_name$)\n"
+      "}\n"
+      "inline void $classname$::add_$name$(const char* value) {\n"
+      "  $null_check$"
+      "  $name$_.AddAccessor()->assign(value);\n"
+      "$annotate_add$"
+      "  // @@protoc_insertion_point(field_add_char:$full_name$)\n"
+      "}\n");
+  } else {
+    // base
+    format(
       "inline void "
       "$classname$::set_$name$"
       "(int index, const $pointer_type$* value, size_t size) {\n"
@@ -789,6 +1001,8 @@ void RepeatedStringFieldGenerator::GenerateInlineAccessorDefinitions(
       "$annotate_add$"
       "  // @@protoc_insertion_point(field_add_char:$full_name$)\n"
       "}\n");
+  }
+
   if (!options_.opensource_runtime) {
     format(
         "inline void $classname$::add_$name$(StringPiece value) {\n"
@@ -797,7 +1011,28 @@ void RepeatedStringFieldGenerator::GenerateInlineAccessorDefinitions(
         "  // @@protoc_insertion_point(field_add_string_piece:$full_name$)\n"
         "}\n");
   }
-  format(
+  if (enable_donated_string) {
+    format(
+      "inline void "
+      "$classname$::add_$name$(const $pointer_type$* value, size_t size) {\n"
+      "  $name$_.Add()->assign(reinterpret_cast<const char*>(value), size);\n"
+      "$annotate_add$"
+      "  // @@protoc_insertion_point(field_add_pointer:$full_name$)\n"
+      "}\n"
+      "inline const ::$proto_ns$::RepeatedArenaPtrField<std::string>&\n"
+      "$classname$::$name$() const {\n"
+      "$annotate_list$"
+      "  // @@protoc_insertion_point(field_list:$full_name$)\n"
+      "  return $name$_;\n"
+      "}\n"
+      "inline ::$proto_ns$::RepeatedArenaPtrField<std::string>*\n"
+      "$classname$::mutable_$name$() {\n"
+      "$annotate_mutable_list$"
+      "  // @@protoc_insertion_point(field_mutable_list:$full_name$)\n"
+      "  return &$name$_;\n"
+      "}\n");
+  } else {
+    format(
       "inline void "
       "$classname$::add_$name$(const $pointer_type$* value, size_t size) {\n"
       "  $name$_.Add()->assign(reinterpret_cast<const char*>(value), size);\n"
@@ -816,8 +1051,8 @@ void RepeatedStringFieldGenerator::GenerateInlineAccessorDefinitions(
       "  // @@protoc_insertion_point(field_mutable_list:$full_name$)\n"
       "  return &$name$_;\n"
       "}\n");
+  }
 }
-
 void RepeatedStringFieldGenerator::GenerateClearingCode(
     io::Printer* printer) const {
   Formatter format(printer, variables_);
diff --git a/src/google/protobuf/config.h b/src/google/protobuf/config.h
new file mode 100644
index 000000000..d4b3064a1
--- /dev/null
+++ b/src/google/protobuf/config.h
@@ -0,0 +1 @@
+#define GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING 1
diff --git a/src/google/protobuf/descriptor.pb.cc b/src/google/protobuf/descriptor.pb.cc
index ef6749457..0e6c6acda 100644
--- a/src/google/protobuf/descriptor.pb.cc
+++ b/src/google/protobuf/descriptor.pb.cc
@@ -244,6 +244,7 @@ constexpr FileOptions::FileOptions(
   , py_generic_services_(false)
   , php_generic_services_(false)
   , deprecated_(false)
+  , cc_mutable_donated_string_(false)
   , optimize_for_(1)
 
   , cc_enable_arenas_(true){}
@@ -671,6 +672,7 @@ const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_google_2fprotobuf_2fdescriptor
   PROTOBUF_FIELD_OFFSET(::PROTOBUF_NAMESPACE_ID::FileOptions, php_generic_services_),
   PROTOBUF_FIELD_OFFSET(::PROTOBUF_NAMESPACE_ID::FileOptions, deprecated_),
   PROTOBUF_FIELD_OFFSET(::PROTOBUF_NAMESPACE_ID::FileOptions, cc_enable_arenas_),
+  PROTOBUF_FIELD_OFFSET(::PROTOBUF_NAMESPACE_ID::FileOptions, cc_mutable_donated_string_),
   PROTOBUF_FIELD_OFFSET(::PROTOBUF_NAMESPACE_ID::FileOptions, objc_class_prefix_),
   PROTOBUF_FIELD_OFFSET(::PROTOBUF_NAMESPACE_ID::FileOptions, csharp_namespace_),
   PROTOBUF_FIELD_OFFSET(::PROTOBUF_NAMESPACE_ID::FileOptions, swift_prefix_),
@@ -684,14 +686,15 @@ const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_google_2fprotobuf_2fdescriptor
   10,
   11,
   12,
-  18,
+  19,
   2,
   13,
   14,
   15,
   16,
   17,
-  19,
+  20,
+  18,
   3,
   4,
   5,
@@ -876,20 +879,20 @@ static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOB
   { 156, 165, -1, sizeof(::PROTOBUF_NAMESPACE_ID::EnumValueDescriptorProto)},
   { 168, 177, -1, sizeof(::PROTOBUF_NAMESPACE_ID::ServiceDescriptorProto)},
   { 180, 192, -1, sizeof(::PROTOBUF_NAMESPACE_ID::MethodDescriptorProto)},
-  { 198, 225, -1, sizeof(::PROTOBUF_NAMESPACE_ID::FileOptions)},
-  { 246, 257, -1, sizeof(::PROTOBUF_NAMESPACE_ID::MessageOptions)},
-  { 262, 275, -1, sizeof(::PROTOBUF_NAMESPACE_ID::FieldOptions)},
-  { 282, -1, -1, sizeof(::PROTOBUF_NAMESPACE_ID::OneofOptions)},
-  { 289, 298, -1, sizeof(::PROTOBUF_NAMESPACE_ID::EnumOptions)},
-  { 301, 309, -1, sizeof(::PROTOBUF_NAMESPACE_ID::EnumValueOptions)},
-  { 311, 319, -1, sizeof(::PROTOBUF_NAMESPACE_ID::ServiceOptions)},
-  { 321, 330, -1, sizeof(::PROTOBUF_NAMESPACE_ID::MethodOptions)},
-  { 333, 341, -1, sizeof(::PROTOBUF_NAMESPACE_ID::UninterpretedOption_NamePart)},
-  { 343, 356, -1, sizeof(::PROTOBUF_NAMESPACE_ID::UninterpretedOption)},
-  { 363, 374, -1, sizeof(::PROTOBUF_NAMESPACE_ID::SourceCodeInfo_Location)},
-  { 379, -1, -1, sizeof(::PROTOBUF_NAMESPACE_ID::SourceCodeInfo)},
-  { 386, 396, -1, sizeof(::PROTOBUF_NAMESPACE_ID::GeneratedCodeInfo_Annotation)},
-  { 400, -1, -1, sizeof(::PROTOBUF_NAMESPACE_ID::GeneratedCodeInfo)},
+  { 198, 226, -1, sizeof(::PROTOBUF_NAMESPACE_ID::FileOptions)},
+  { 248, 259, -1, sizeof(::PROTOBUF_NAMESPACE_ID::MessageOptions)},
+  { 264, 277, -1, sizeof(::PROTOBUF_NAMESPACE_ID::FieldOptions)},
+  { 284, -1, -1, sizeof(::PROTOBUF_NAMESPACE_ID::OneofOptions)},
+  { 291, 300, -1, sizeof(::PROTOBUF_NAMESPACE_ID::EnumOptions)},
+  { 303, 311, -1, sizeof(::PROTOBUF_NAMESPACE_ID::EnumValueOptions)},
+  { 313, 321, -1, sizeof(::PROTOBUF_NAMESPACE_ID::ServiceOptions)},
+  { 323, 332, -1, sizeof(::PROTOBUF_NAMESPACE_ID::MethodOptions)},
+  { 335, 343, -1, sizeof(::PROTOBUF_NAMESPACE_ID::UninterpretedOption_NamePart)},
+  { 345, 358, -1, sizeof(::PROTOBUF_NAMESPACE_ID::UninterpretedOption)},
+  { 365, 376, -1, sizeof(::PROTOBUF_NAMESPACE_ID::SourceCodeInfo_Location)},
+  { 381, -1, -1, sizeof(::PROTOBUF_NAMESPACE_ID::SourceCodeInfo)},
+  { 388, 398, -1, sizeof(::PROTOBUF_NAMESPACE_ID::GeneratedCodeInfo_Annotation)},
+  { 402, -1, -1, sizeof(::PROTOBUF_NAMESPACE_ID::GeneratedCodeInfo)},
 };
 
 static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
@@ -996,7 +999,7 @@ const char descriptor_table_protodef_google_2fprotobuf_2fdescriptor_2eproto[] PR
   "\ninput_type\030\002 \001(\t\022\023\n\013output_type\030\003 \001(\t\022/"
   "\n\007options\030\004 \001(\0132\036.google.protobuf.Method"
   "Options\022\037\n\020client_streaming\030\005 \001(\010:\005false"
-  "\022\037\n\020server_streaming\030\006 \001(\010:\005false\"\245\006\n\013Fi"
+  "\022\037\n\020server_streaming\030\006 \001(\010:\005false\"\317\006\n\013Fi"
   "leOptions\022\024\n\014java_package\030\001 \001(\t\022\034\n\024java_"
   "outer_classname\030\010 \001(\t\022\"\n\023java_multiple_f"
   "iles\030\n \001(\010:\005false\022)\n\035java_generate_equal"
@@ -1008,77 +1011,78 @@ const char descriptor_table_protodef_google_2fprotobuf_2fdescriptor_2eproto[] PR
   "ric_services\030\021 \001(\010:\005false\022\"\n\023py_generic_"
   "services\030\022 \001(\010:\005false\022#\n\024php_generic_ser"
   "vices\030* \001(\010:\005false\022\031\n\ndeprecated\030\027 \001(\010:\005"
-  "false\022\036\n\020cc_enable_arenas\030\037 \001(\010:\004true\022\031\n"
-  "\021objc_class_prefix\030$ \001(\t\022\030\n\020csharp_names"
-  "pace\030% \001(\t\022\024\n\014swift_prefix\030\' \001(\t\022\030\n\020php_"
-  "class_prefix\030( \001(\t\022\025\n\rphp_namespace\030) \001("
-  "\t\022\036\n\026php_metadata_namespace\030, \001(\t\022\024\n\014rub"
-  "y_package\030- \001(\t\022C\n\024uninterpreted_option\030"
-  "\347\007 \003(\0132$.google.protobuf.UninterpretedOp"
-  "tion\":\n\014OptimizeMode\022\t\n\005SPEED\020\001\022\r\n\tCODE_"
-  "SIZE\020\002\022\020\n\014LITE_RUNTIME\020\003*\t\010\350\007\020\200\200\200\200\002J\004\010&\020"
-  "\'\"\204\002\n\016MessageOptions\022&\n\027message_set_wire"
-  "_format\030\001 \001(\010:\005false\022.\n\037no_standard_desc"
-  "riptor_accessor\030\002 \001(\010:\005false\022\031\n\ndeprecat"
-  "ed\030\003 \001(\010:\005false\022\021\n\tmap_entry\030\007 \001(\010\022C\n\024un"
-  "interpreted_option\030\347\007 \003(\0132$.google.proto"
-  "buf.UninterpretedOption*\t\010\350\007\020\200\200\200\200\002J\004\010\004\020\005"
-  "J\004\010\005\020\006J\004\010\006\020\007J\004\010\010\020\tJ\004\010\t\020\n\"\236\003\n\014FieldOption"
-  "s\022:\n\005ctype\030\001 \001(\0162#.google.protobuf.Field"
-  "Options.CType:\006STRING\022\016\n\006packed\030\002 \001(\010\022\?\n"
-  "\006jstype\030\006 \001(\0162$.google.protobuf.FieldOpt"
-  "ions.JSType:\tJS_NORMAL\022\023\n\004lazy\030\005 \001(\010:\005fa"
-  "lse\022\031\n\ndeprecated\030\003 \001(\010:\005false\022\023\n\004weak\030\n"
-  " \001(\010:\005false\022C\n\024uninterpreted_option\030\347\007 \003"
-  "(\0132$.google.protobuf.UninterpretedOption"
-  "\"/\n\005CType\022\n\n\006STRING\020\000\022\010\n\004CORD\020\001\022\020\n\014STRIN"
-  "G_PIECE\020\002\"5\n\006JSType\022\r\n\tJS_NORMAL\020\000\022\r\n\tJS"
-  "_STRING\020\001\022\r\n\tJS_NUMBER\020\002*\t\010\350\007\020\200\200\200\200\002J\004\010\004\020"
-  "\005\"^\n\014OneofOptions\022C\n\024uninterpreted_optio"
+  "false\022\036\n\020cc_enable_arenas\030\037 \001(\010:\004true\022(\n"
+  "\031cc_mutable_donated_string\030  \001(\010:\005false\022"
+  "\031\n\021objc_class_prefix\030$ \001(\t\022\030\n\020csharp_nam"
+  "espace\030% \001(\t\022\024\n\014swift_prefix\030\' \001(\t\022\030\n\020ph"
+  "p_class_prefix\030( \001(\t\022\025\n\rphp_namespace\030) "
+  "\001(\t\022\036\n\026php_metadata_namespace\030, \001(\t\022\024\n\014r"
+  "uby_package\030- \001(\t\022C\n\024uninterpreted_optio"
   "n\030\347\007 \003(\0132$.google.protobuf.Uninterpreted"
-  "Option*\t\010\350\007\020\200\200\200\200\002\"\223\001\n\013EnumOptions\022\023\n\013all"
-  "ow_alias\030\002 \001(\010\022\031\n\ndeprecated\030\003 \001(\010:\005fals"
-  "e\022C\n\024uninterpreted_option\030\347\007 \003(\0132$.googl"
-  "e.protobuf.UninterpretedOption*\t\010\350\007\020\200\200\200\200"
-  "\002J\004\010\005\020\006\"}\n\020EnumValueOptions\022\031\n\ndeprecate"
-  "d\030\001 \001(\010:\005false\022C\n\024uninterpreted_option\030\347"
-  "\007 \003(\0132$.google.protobuf.UninterpretedOpt"
-  "ion*\t\010\350\007\020\200\200\200\200\002\"{\n\016ServiceOptions\022\031\n\ndepr"
-  "ecated\030! \001(\010:\005false\022C\n\024uninterpreted_opt"
+  "Option\":\n\014OptimizeMode\022\t\n\005SPEED\020\001\022\r\n\tCOD"
+  "E_SIZE\020\002\022\020\n\014LITE_RUNTIME\020\003*\t\010\350\007\020\200\200\200\200\002J\004\010"
+  "&\020\'\"\204\002\n\016MessageOptions\022&\n\027message_set_wi"
+  "re_format\030\001 \001(\010:\005false\022.\n\037no_standard_de"
+  "scriptor_accessor\030\002 \001(\010:\005false\022\031\n\ndeprec"
+  "ated\030\003 \001(\010:\005false\022\021\n\tmap_entry\030\007 \001(\010\022C\n\024"
+  "uninterpreted_option\030\347\007 \003(\0132$.google.pro"
+  "tobuf.UninterpretedOption*\t\010\350\007\020\200\200\200\200\002J\004\010\004"
+  "\020\005J\004\010\005\020\006J\004\010\006\020\007J\004\010\010\020\tJ\004\010\t\020\n\"\236\003\n\014FieldOpti"
+  "ons\022:\n\005ctype\030\001 \001(\0162#.google.protobuf.Fie"
+  "ldOptions.CType:\006STRING\022\016\n\006packed\030\002 \001(\010\022"
+  "\?\n\006jstype\030\006 \001(\0162$.google.protobuf.FieldO"
+  "ptions.JSType:\tJS_NORMAL\022\023\n\004lazy\030\005 \001(\010:\005"
+  "false\022\031\n\ndeprecated\030\003 \001(\010:\005false\022\023\n\004weak"
+  "\030\n \001(\010:\005false\022C\n\024uninterpreted_option\030\347\007"
+  " \003(\0132$.google.protobuf.UninterpretedOpti"
+  "on\"/\n\005CType\022\n\n\006STRING\020\000\022\010\n\004CORD\020\001\022\020\n\014STR"
+  "ING_PIECE\020\002\"5\n\006JSType\022\r\n\tJS_NORMAL\020\000\022\r\n\t"
+  "JS_STRING\020\001\022\r\n\tJS_NUMBER\020\002*\t\010\350\007\020\200\200\200\200\002J\004\010"
+  "\004\020\005\"^\n\014OneofOptions\022C\n\024uninterpreted_opt"
   "ion\030\347\007 \003(\0132$.google.protobuf.Uninterpret"
-  "edOption*\t\010\350\007\020\200\200\200\200\002\"\255\002\n\rMethodOptions\022\031\n"
-  "\ndeprecated\030! \001(\010:\005false\022_\n\021idempotency_"
-  "level\030\" \001(\0162/.google.protobuf.MethodOpti"
-  "ons.IdempotencyLevel:\023IDEMPOTENCY_UNKNOW"
-  "N\022C\n\024uninterpreted_option\030\347\007 \003(\0132$.googl"
-  "e.protobuf.UninterpretedOption\"P\n\020Idempo"
-  "tencyLevel\022\027\n\023IDEMPOTENCY_UNKNOWN\020\000\022\023\n\017N"
-  "O_SIDE_EFFECTS\020\001\022\016\n\nIDEMPOTENT\020\002*\t\010\350\007\020\200\200"
-  "\200\200\002\"\236\002\n\023UninterpretedOption\022;\n\004name\030\002 \003("
-  "\0132-.google.protobuf.UninterpretedOption."
-  "NamePart\022\030\n\020identifier_value\030\003 \001(\t\022\032\n\022po"
-  "sitive_int_value\030\004 \001(\004\022\032\n\022negative_int_v"
-  "alue\030\005 \001(\003\022\024\n\014double_value\030\006 \001(\001\022\024\n\014stri"
-  "ng_value\030\007 \001(\014\022\027\n\017aggregate_value\030\010 \001(\t\032"
-  "3\n\010NamePart\022\021\n\tname_part\030\001 \002(\t\022\024\n\014is_ext"
-  "ension\030\002 \002(\010\"\325\001\n\016SourceCodeInfo\022:\n\010locat"
-  "ion\030\001 \003(\0132(.google.protobuf.SourceCodeIn"
-  "fo.Location\032\206\001\n\010Location\022\020\n\004path\030\001 \003(\005B\002"
-  "\020\001\022\020\n\004span\030\002 \003(\005B\002\020\001\022\030\n\020leading_comments"
-  "\030\003 \001(\t\022\031\n\021trailing_comments\030\004 \001(\t\022!\n\031lea"
-  "ding_detached_comments\030\006 \003(\t\"\247\001\n\021Generat"
-  "edCodeInfo\022A\n\nannotation\030\001 \003(\0132-.google."
-  "protobuf.GeneratedCodeInfo.Annotation\032O\n"
-  "\nAnnotation\022\020\n\004path\030\001 \003(\005B\002\020\001\022\023\n\013source_"
-  "file\030\002 \001(\t\022\r\n\005begin\030\003 \001(\005\022\013\n\003end\030\004 \001(\005B~"
-  "\n\023com.google.protobufB\020DescriptorProtosH"
-  "\001Z-google.golang.org/protobuf/types/desc"
-  "riptorpb\370\001\001\242\002\003GPB\252\002\032Google.Protobuf.Refl"
-  "ection"
+  "edOption*\t\010\350\007\020\200\200\200\200\002\"\223\001\n\013EnumOptions\022\023\n\013a"
+  "llow_alias\030\002 \001(\010\022\031\n\ndeprecated\030\003 \001(\010:\005fa"
+  "lse\022C\n\024uninterpreted_option\030\347\007 \003(\0132$.goo"
+  "gle.protobuf.UninterpretedOption*\t\010\350\007\020\200\200"
+  "\200\200\002J\004\010\005\020\006\"}\n\020EnumValueOptions\022\031\n\ndepreca"
+  "ted\030\001 \001(\010:\005false\022C\n\024uninterpreted_option"
+  "\030\347\007 \003(\0132$.google.protobuf.UninterpretedO"
+  "ption*\t\010\350\007\020\200\200\200\200\002\"{\n\016ServiceOptions\022\031\n\nde"
+  "precated\030! \001(\010:\005false\022C\n\024uninterpreted_o"
+  "ption\030\347\007 \003(\0132$.google.protobuf.Uninterpr"
+  "etedOption*\t\010\350\007\020\200\200\200\200\002\"\255\002\n\rMethodOptions\022"
+  "\031\n\ndeprecated\030! \001(\010:\005false\022_\n\021idempotenc"
+  "y_level\030\" \001(\0162/.google.protobuf.MethodOp"
+  "tions.IdempotencyLevel:\023IDEMPOTENCY_UNKN"
+  "OWN\022C\n\024uninterpreted_option\030\347\007 \003(\0132$.goo"
+  "gle.protobuf.UninterpretedOption\"P\n\020Idem"
+  "potencyLevel\022\027\n\023IDEMPOTENCY_UNKNOWN\020\000\022\023\n"
+  "\017NO_SIDE_EFFECTS\020\001\022\016\n\nIDEMPOTENT\020\002*\t\010\350\007\020"
+  "\200\200\200\200\002\"\236\002\n\023UninterpretedOption\022;\n\004name\030\002 "
+  "\003(\0132-.google.protobuf.UninterpretedOptio"
+  "n.NamePart\022\030\n\020identifier_value\030\003 \001(\t\022\032\n\022"
+  "positive_int_value\030\004 \001(\004\022\032\n\022negative_int"
+  "_value\030\005 \001(\003\022\024\n\014double_value\030\006 \001(\001\022\024\n\014st"
+  "ring_value\030\007 \001(\014\022\027\n\017aggregate_value\030\010 \001("
+  "\t\0323\n\010NamePart\022\021\n\tname_part\030\001 \002(\t\022\024\n\014is_e"
+  "xtension\030\002 \002(\010\"\325\001\n\016SourceCodeInfo\022:\n\010loc"
+  "ation\030\001 \003(\0132(.google.protobuf.SourceCode"
+  "Info.Location\032\206\001\n\010Location\022\020\n\004path\030\001 \003(\005"
+  "B\002\020\001\022\020\n\004span\030\002 \003(\005B\002\020\001\022\030\n\020leading_commen"
+  "ts\030\003 \001(\t\022\031\n\021trailing_comments\030\004 \001(\t\022!\n\031l"
+  "eading_detached_comments\030\006 \003(\t\"\247\001\n\021Gener"
+  "atedCodeInfo\022A\n\nannotation\030\001 \003(\0132-.googl"
+  "e.protobuf.GeneratedCodeInfo.Annotation\032"
+  "O\n\nAnnotation\022\020\n\004path\030\001 \003(\005B\002\020\001\022\023\n\013sourc"
+  "e_file\030\002 \001(\t\022\r\n\005begin\030\003 \001(\005\022\013\n\003end\030\004 \001(\005"
+  "B~\n\023com.google.protobufB\020DescriptorProto"
+  "sH\001Z-google.golang.org/protobuf/types/de"
+  "scriptorpb\370\001\001\242\002\003GPB\252\002\032Google.Protobuf.Re"
+  "flection"
   ;
 static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_google_2fprotobuf_2fdescriptor_2eproto_once;
 const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_google_2fprotobuf_2fdescriptor_2eproto = {
-  false, false, 6046, descriptor_table_protodef_google_2fprotobuf_2fdescriptor_2eproto, "google/protobuf/descriptor.proto", 
+  false, false, 6088, descriptor_table_protodef_google_2fprotobuf_2fdescriptor_2eproto, "google/protobuf/descriptor.proto", 
   &descriptor_table_google_2fprotobuf_2fdescriptor_2eproto_once, nullptr, 0, 27,
   schemas, file_default_instances, TableStruct_google_2fprotobuf_2fdescriptor_2eproto::offsets,
   file_level_metadata_google_2fprotobuf_2fdescriptor_2eproto, file_level_enum_descriptors_google_2fprotobuf_2fdescriptor_2eproto, file_level_service_descriptors_google_2fprotobuf_2fdescriptor_2eproto,
@@ -5977,7 +5981,7 @@ class FileOptions::_Internal {
     (*has_bits)[0] |= 4096u;
   }
   static void set_has_optimize_for(HasBits* has_bits) {
-    (*has_bits)[0] |= 262144u;
+    (*has_bits)[0] |= 524288u;
   }
   static void set_has_go_package(HasBits* has_bits) {
     (*has_bits)[0] |= 4u;
@@ -5998,7 +6002,10 @@ class FileOptions::_Internal {
     (*has_bits)[0] |= 131072u;
   }
   static void set_has_cc_enable_arenas(HasBits* has_bits) {
-    (*has_bits)[0] |= 524288u;
+    (*has_bits)[0] |= 1048576u;
+  }
+  static void set_has_cc_mutable_donated_string(HasBits* has_bits) {
+    (*has_bits)[0] |= 262144u;
   }
   static void set_has_objc_class_prefix(HasBits* has_bits) {
     (*has_bits)[0] |= 8u;
@@ -6109,8 +6116,8 @@ php_metadata_namespace_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::Get
 ruby_package_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
 ::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
     reinterpret_cast<char*>(&java_multiple_files_) - reinterpret_cast<char*>(this)),
-    0, static_cast<size_t>(reinterpret_cast<char*>(&deprecated_) -
-    reinterpret_cast<char*>(&java_multiple_files_)) + sizeof(deprecated_));
+    0, static_cast<size_t>(reinterpret_cast<char*>(&cc_mutable_donated_string_) -
+    reinterpret_cast<char*>(&java_multiple_files_)) + sizeof(cc_mutable_donated_string_));
 optimize_for_ = 1;
 cc_enable_arenas_ = true;
 }
@@ -6194,10 +6201,10 @@ void FileOptions::Clear() {
         reinterpret_cast<char*>(&py_generic_services_) -
         reinterpret_cast<char*>(&java_multiple_files_)) + sizeof(py_generic_services_));
   }
-  if (cached_has_bits & 0x000f0000u) {
+  if (cached_has_bits & 0x001f0000u) {
     ::memset(&php_generic_services_, 0, static_cast<size_t>(
-        reinterpret_cast<char*>(&deprecated_) -
-        reinterpret_cast<char*>(&php_generic_services_)) + sizeof(deprecated_));
+        reinterpret_cast<char*>(&cc_mutable_donated_string_) -
+        reinterpret_cast<char*>(&php_generic_services_)) + sizeof(cc_mutable_donated_string_));
     optimize_for_ = 1;
     cc_enable_arenas_ = true;
   }
@@ -6333,6 +6340,15 @@ const char* FileOptions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID
         } else
           goto handle_unusual;
         continue;
+      // optional bool cc_mutable_donated_string = 32 [default = false];
+      case 32:
+        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 0)) {
+          _Internal::set_has_cc_mutable_donated_string(&has_bits);
+          cc_mutable_donated_string_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
+          CHK_(ptr);
+        } else
+          goto handle_unusual;
+        continue;
       // optional string objc_class_prefix = 36;
       case 36:
         if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
@@ -6496,7 +6512,7 @@ failure:
   }
 
   // optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];
-  if (cached_has_bits & 0x00040000u) {
+  if (cached_has_bits & 0x00080000u) {
     target = stream->EnsureSpace(target);
     target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
       9, this->_internal_optimize_for(), target);
@@ -6555,11 +6571,17 @@ failure:
   }
 
   // optional bool cc_enable_arenas = 31 [default = true];
-  if (cached_has_bits & 0x00080000u) {
+  if (cached_has_bits & 0x00100000u) {
     target = stream->EnsureSpace(target);
     target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(31, this->_internal_cc_enable_arenas(), target);
   }
 
+  // optional bool cc_mutable_donated_string = 32 [default = false];
+  if (cached_has_bits & 0x00040000u) {
+    target = stream->EnsureSpace(target);
+    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(32, this->_internal_cc_mutable_donated_string(), target);
+  }
+
   // optional string objc_class_prefix = 36;
   if (cached_has_bits & 0x00000008u) {
     ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
@@ -6778,7 +6800,7 @@ size_t FileOptions::ByteSizeLong() const {
     }
 
   }
-  if (cached_has_bits & 0x000f0000u) {
+  if (cached_has_bits & 0x001f0000u) {
     // optional bool php_generic_services = 42 [default = false];
     if (cached_has_bits & 0x00010000u) {
       total_size += 2 + 1;
@@ -6789,14 +6811,19 @@ size_t FileOptions::ByteSizeLong() const {
       total_size += 2 + 1;
     }
 
-    // optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];
+    // optional bool cc_mutable_donated_string = 32 [default = false];
     if (cached_has_bits & 0x00040000u) {
+      total_size += 2 + 1;
+    }
+
+    // optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];
+    if (cached_has_bits & 0x00080000u) {
       total_size += 1 +
         ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_optimize_for());
     }
 
     // optional bool cc_enable_arenas = 31 [default = true];
-    if (cached_has_bits & 0x00080000u) {
+    if (cached_has_bits & 0x00100000u) {
       total_size += 2 + 1;
     }
 
@@ -6878,7 +6905,7 @@ void FileOptions::MergeFrom(const FileOptions& from) {
     }
     _has_bits_[0] |= cached_has_bits;
   }
-  if (cached_has_bits & 0x000f0000u) {
+  if (cached_has_bits & 0x001f0000u) {
     if (cached_has_bits & 0x00010000u) {
       php_generic_services_ = from.php_generic_services_;
     }
@@ -6886,9 +6913,12 @@ void FileOptions::MergeFrom(const FileOptions& from) {
       deprecated_ = from.deprecated_;
     }
     if (cached_has_bits & 0x00040000u) {
-      optimize_for_ = from.optimize_for_;
+      cc_mutable_donated_string_ = from.cc_mutable_donated_string_;
     }
     if (cached_has_bits & 0x00080000u) {
+      optimize_for_ = from.optimize_for_;
+    }
+    if (cached_has_bits & 0x00100000u) {
       cc_enable_arenas_ = from.cc_enable_arenas_;
     }
     _has_bits_[0] |= cached_has_bits;
@@ -6972,8 +7002,8 @@ void FileOptions::InternalSwap(FileOptions* other) {
       &other->ruby_package_, rhs_arena
   );
   ::PROTOBUF_NAMESPACE_ID::internal::memswap<
-      PROTOBUF_FIELD_OFFSET(FileOptions, deprecated_)
-      + sizeof(FileOptions::deprecated_)
+      PROTOBUF_FIELD_OFFSET(FileOptions, cc_mutable_donated_string_)
+      + sizeof(FileOptions::cc_mutable_donated_string_)
       - PROTOBUF_FIELD_OFFSET(FileOptions, java_multiple_files_)>(
           reinterpret_cast<char*>(&java_multiple_files_),
           reinterpret_cast<char*>(&other->java_multiple_files_));
diff --git a/src/google/protobuf/descriptor.pb.h b/src/google/protobuf/descriptor.pb.h
index 51261e4b4..7e3373602 100644
--- a/src/google/protobuf/descriptor.pb.h
+++ b/src/google/protobuf/descriptor.pb.h
@@ -3791,6 +3791,7 @@ class PROTOBUF_EXPORT FileOptions final :
     kPyGenericServicesFieldNumber = 18,
     kPhpGenericServicesFieldNumber = 42,
     kDeprecatedFieldNumber = 23,
+    kCcMutableDonatedStringFieldNumber = 32,
     kOptimizeForFieldNumber = 9,
     kCcEnableArenasFieldNumber = 31,
   };
@@ -4096,6 +4097,19 @@ class PROTOBUF_EXPORT FileOptions final :
   void _internal_set_deprecated(bool value);
   public:
 
+  // optional bool cc_mutable_donated_string = 32 [default = false];
+  bool has_cc_mutable_donated_string() const;
+  private:
+  bool _internal_has_cc_mutable_donated_string() const;
+  public:
+  void clear_cc_mutable_donated_string();
+  bool cc_mutable_donated_string() const;
+  void set_cc_mutable_donated_string(bool value);
+  private:
+  bool _internal_cc_mutable_donated_string() const;
+  void _internal_set_cc_mutable_donated_string(bool value);
+  public:
+
   // optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];
   bool has_optimize_for() const;
   private:
@@ -4342,6 +4356,7 @@ class PROTOBUF_EXPORT FileOptions final :
   bool py_generic_services_;
   bool php_generic_services_;
   bool deprecated_;
+  bool cc_mutable_donated_string_;
   int optimize_for_;
   bool cc_enable_arenas_;
   friend struct ::TableStruct_google_2fprotobuf_2fdescriptor_2eproto;
@@ -11829,7 +11844,7 @@ inline void FileOptions::set_java_string_check_utf8(bool value) {
 
 // optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9 [default = SPEED];
 inline bool FileOptions::_internal_has_optimize_for() const {
-  bool value = (_has_bits_[0] & 0x00040000u) != 0;
+  bool value = (_has_bits_[0] & 0x00080000u) != 0;
   return value;
 }
 inline bool FileOptions::has_optimize_for() const {
@@ -11837,7 +11852,7 @@ inline bool FileOptions::has_optimize_for() const {
 }
 inline void FileOptions::clear_optimize_for() {
   optimize_for_ = 1;
-  _has_bits_[0] &= ~0x00040000u;
+  _has_bits_[0] &= ~0x00080000u;
 }
 inline ::PROTOBUF_NAMESPACE_ID::FileOptions_OptimizeMode FileOptions::_internal_optimize_for() const {
   return static_cast< ::PROTOBUF_NAMESPACE_ID::FileOptions_OptimizeMode >(optimize_for_);
@@ -11848,7 +11863,7 @@ inline ::PROTOBUF_NAMESPACE_ID::FileOptions_OptimizeMode FileOptions::optimize_f
 }
 inline void FileOptions::_internal_set_optimize_for(::PROTOBUF_NAMESPACE_ID::FileOptions_OptimizeMode value) {
   assert(::PROTOBUF_NAMESPACE_ID::FileOptions_OptimizeMode_IsValid(value));
-  _has_bits_[0] |= 0x00040000u;
+  _has_bits_[0] |= 0x00080000u;
   optimize_for_ = value;
 }
 inline void FileOptions::set_optimize_for(::PROTOBUF_NAMESPACE_ID::FileOptions_OptimizeMode value) {
@@ -12056,7 +12071,7 @@ inline void FileOptions::set_deprecated(bool value) {
 
 // optional bool cc_enable_arenas = 31 [default = true];
 inline bool FileOptions::_internal_has_cc_enable_arenas() const {
-  bool value = (_has_bits_[0] & 0x00080000u) != 0;
+  bool value = (_has_bits_[0] & 0x00100000u) != 0;
   return value;
 }
 inline bool FileOptions::has_cc_enable_arenas() const {
@@ -12064,7 +12079,7 @@ inline bool FileOptions::has_cc_enable_arenas() const {
 }
 inline void FileOptions::clear_cc_enable_arenas() {
   cc_enable_arenas_ = true;
-  _has_bits_[0] &= ~0x00080000u;
+  _has_bits_[0] &= ~0x00100000u;
 }
 inline bool FileOptions::_internal_cc_enable_arenas() const {
   return cc_enable_arenas_;
@@ -12074,7 +12089,7 @@ inline bool FileOptions::cc_enable_arenas() const {
   return _internal_cc_enable_arenas();
 }
 inline void FileOptions::_internal_set_cc_enable_arenas(bool value) {
-  _has_bits_[0] |= 0x00080000u;
+  _has_bits_[0] |= 0x00100000u;
   cc_enable_arenas_ = value;
 }
 inline void FileOptions::set_cc_enable_arenas(bool value) {
@@ -12082,6 +12097,34 @@ inline void FileOptions::set_cc_enable_arenas(bool value) {
   // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.cc_enable_arenas)
 }
 
+// optional bool cc_mutable_donated_string = 32 [default = false];
+inline bool FileOptions::_internal_has_cc_mutable_donated_string() const {
+  bool value = (_has_bits_[0] & 0x00040000u) != 0;
+  return value;
+}
+inline bool FileOptions::has_cc_mutable_donated_string() const {
+  return _internal_has_cc_mutable_donated_string();
+}
+inline void FileOptions::clear_cc_mutable_donated_string() {
+  cc_mutable_donated_string_ = false;
+  _has_bits_[0] &= ~0x00040000u;
+}
+inline bool FileOptions::_internal_cc_mutable_donated_string() const {
+  return cc_mutable_donated_string_;
+}
+inline bool FileOptions::cc_mutable_donated_string() const {
+  // @@protoc_insertion_point(field_get:google.protobuf.FileOptions.cc_mutable_donated_string)
+  return _internal_cc_mutable_donated_string();
+}
+inline void FileOptions::_internal_set_cc_mutable_donated_string(bool value) {
+  _has_bits_[0] |= 0x00040000u;
+  cc_mutable_donated_string_ = value;
+}
+inline void FileOptions::set_cc_mutable_donated_string(bool value) {
+  _internal_set_cc_mutable_donated_string(value);
+  // @@protoc_insertion_point(field_set:google.protobuf.FileOptions.cc_mutable_donated_string)
+}
+
 // optional string objc_class_prefix = 36;
 inline bool FileOptions::_internal_has_objc_class_prefix() const {
   bool value = (_has_bits_[0] & 0x00000008u) != 0;
diff --git a/src/google/protobuf/descriptor.proto b/src/google/protobuf/descriptor.proto
index 156e410ae..1045ba937 100644
--- a/src/google/protobuf/descriptor.proto
+++ b/src/google/protobuf/descriptor.proto
@@ -419,6 +419,10 @@ message FileOptions {
   // only to generated classes for C++.
   optional bool cc_enable_arenas = 31 [default = true];
 
+  // 增加新开关，控制生成代码的mutable_xxx接口行为和返回值
+  // false: 默认，将donated状态的string转换为heap allocated，通过std::string*返回
+  // true: 保持当前string的donated状态，通过MaybeArenaStringAccessor返回
+  optional bool cc_mutable_donated_string = 32 [default = false];
 
   // Sets the objective c class prefix which is prepended to all objective c
   // generated classes from this .proto. There is no default.
diff --git a/src/google/protobuf/generated_message_reflection.cc b/src/google/protobuf/generated_message_reflection.cc
index 7962327c0..0105e5bf4 100644
--- a/src/google/protobuf/generated_message_reflection.cc
+++ b/src/google/protobuf/generated_message_reflection.cc
@@ -44,6 +44,7 @@
 #include <google/protobuf/extension_set.h>
 #include <google/protobuf/generated_message_util.h>
 #include <google/protobuf/inlined_string_field.h>
+#include <google/protobuf/patch/inlined_arenastring_field.h>
 #include <google/protobuf/map_field.h>
 #include <google/protobuf/map_field_inl.h>
 #include <google/protobuf/stubs/mutex.h>
diff --git a/src/google/protobuf/generated_message_util.h b/src/google/protobuf/generated_message_util.h
index 336234c96..ac1e98a6c 100644
--- a/src/google/protobuf/generated_message_util.h
+++ b/src/google/protobuf/generated_message_util.h
@@ -53,6 +53,7 @@
 #include <google/protobuf/stubs/once.h>  // Add direct dep on port for pb.cc
 #include <google/protobuf/port.h>
 #include <google/protobuf/repeated_field.h>
+#include <google/protobuf/patch/extension_set_with_arenastring.h>
 #include <google/protobuf/wire_format_lite.h>
 #include <google/protobuf/stubs/strutil.h>
 #include <google/protobuf/stubs/casts.h>
diff --git a/src/google/protobuf/message_lite.h b/src/google/protobuf/message_lite.h
index d8138503c..0fa1dee79 100644
--- a/src/google/protobuf/message_lite.h
+++ b/src/google/protobuf/message_lite.h
@@ -80,16 +80,11 @@ namespace internal {
 
 class SwapFieldHelper;
 
-// Tag type used to invoke the constinit constructor overload of some classes.
-// Such constructors are internal implementation details of the library.
-struct ConstantInitialized {
-  explicit ConstantInitialized() = default;
-};
-
 // See parse_context.h for explanation
 class ParseContext;
 
 class ExtensionSet;
+class ExtensionSetWithArenaString;
 class LazyField;
 class RepeatedPtrFieldBase;
 class TcParserBase;
@@ -98,6 +93,8 @@ class WeakFieldMap;
 
 template <typename Type>
 class GenericTypeHandler;  // defined in repeated_field.h
+template <typename Type>
+class ArenaGenericTypeHandler;  // defined in patch/repeated_arenastring_field.h
 
 // We compute sizes as size_t but cache them as int.  This function converts a
 // computed size to a cached size.  Since we don't proceed with serialization
@@ -527,6 +524,7 @@ class PROTOBUF_EXPORT MessageLite {
   friend class Message;
   friend class Reflection;
   friend class internal::ExtensionSet;
+  friend class internal::ExtensionSetWithArenaString;
   friend class internal::LazyField;
   friend class internal::SwapFieldHelper;
   friend class internal::TcParserBase;
@@ -537,6 +535,8 @@ class PROTOBUF_EXPORT MessageLite {
   friend class Arena::InternalHelper;
   template <typename Type>
   friend class internal::GenericTypeHandler;
+  template <typename Type>
+  friend class internal::ArenaGenericTypeHandler;
 
   void LogInitializationErrorMessage() const;
 
diff --git a/src/google/protobuf/parse_context.h b/src/google/protobuf/parse_context.h
index 488b0621c..ad32bbc27 100644
--- a/src/google/protobuf/parse_context.h
+++ b/src/google/protobuf/parse_context.h
@@ -39,8 +39,11 @@
 #include <google/protobuf/io/zero_copy_stream.h>
 #include <google/protobuf/arena.h>
 #include <google/protobuf/arenastring.h>
+#include <google/protobuf/patch/arenastring.h>
 #include <google/protobuf/implicit_weak_message.h>
 #include <google/protobuf/inlined_string_field.h>
+#include <google/protobuf/patch/inlined_arenastring_field.h>
+#include <google/protobuf/patch/repeated_arenastring_field.h>
 #include <google/protobuf/metadata_lite.h>
 #include <google/protobuf/port.h>
 #include <google/protobuf/repeated_field.h>
@@ -171,6 +174,11 @@ class PROTOBUF_EXPORT EpsCopyInputStream {
   PROTOBUF_MUST_USE_RESULT const char* ReadArenaString(const char* ptr,
                                                        ArenaStringPtr* s,
                                                        Arena* arena);
+  PROTOBUF_MUST_USE_RESULT const char* ReadArenaString(const char* ptr,
+                                                       patch::ArenaStringPtr* s,
+                                                       Arena* arena);
+  PROTOBUF_MUST_USE_RESULT const char* ReadArenaString(const char* ptr,
+                                                MaybeArenaStringAccessor s);
 
   template <typename Tag, typename T>
   PROTOBUF_MUST_USE_RESULT const char* ReadRepeatedFixed(const char* ptr,
diff --git a/src/google/protobuf/patch/arenastring.cc b/src/google/protobuf/patch/arenastring.cc
new file mode 100644
index 000000000..f13f4aca8
--- /dev/null
+++ b/src/google/protobuf/patch/arenastring.cc
@@ -0,0 +1,321 @@
+// Protocol Buffers - Google's data interchange format
+// Copyright 2008 Google Inc.  All rights reserved.
+// https://developers.google.com/protocol-buffers/
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include <google/protobuf/patch/arenastring.h>
+
+#include <cstddef>
+#include <google/protobuf/stubs/logging.h>
+#include <google/protobuf/stubs/common.h>
+#include <google/protobuf/io/coded_stream.h>
+#include <google/protobuf/stubs/mutex.h>
+#include <google/protobuf/stubs/strutil.h>
+#include <google/protobuf/message_lite.h>
+#include <google/protobuf/parse_context.h>
+#include <google/protobuf/stubs/stl_util.h>
+
+// clang-format off
+#include <google/protobuf/port_def.inc>
+// clang-format on
+
+namespace google {
+namespace protobuf {
+namespace internal {
+namespace patch {
+
+namespace  {
+
+// TaggedStringPtr::Flags uses the lower 2 bits as tags.
+// Enforce that allocated data aligns to at least 4 bytes, and that
+// the alignment of the global const string value does as well.
+// The alignment guaranteed by `new std::string` depends on both:
+// - new align = __STDCPP_DEFAULT_NEW_ALIGNMENT__ / max_align_t
+// - alignof(std::string)
+#ifdef __STDCPP_DEFAULT_NEW_ALIGNMENT__
+constexpr size_t kNewAlign = __STDCPP_DEFAULT_NEW_ALIGNMENT__;
+#elif (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) < 40900
+constexpr size_t kNewAlign = alignof(::max_align_t);
+#else
+constexpr size_t kNewAlign = alignof(std::max_align_t);
+#endif
+constexpr size_t kStringAlign = alignof(std::string);
+
+static_assert((kStringAlign > kNewAlign ? kStringAlign : kNewAlign) >= 4, "");
+static_assert(alignof(ExplicitlyConstructedArenaString) >= 4, "");
+
+}  // namespace
+
+const std::string& LazyString::Init() const {
+  static WrappedMutex mu{GOOGLE_PROTOBUF_LINKER_INITIALIZED};
+  mu.Lock();
+  const std::string* res = inited_.load(std::memory_order_acquire);
+  if (res == nullptr) {
+    auto init_value = init_value_;
+    res = ::new (static_cast<void*>(string_buf_))
+        std::string(init_value.ptr, init_value.size);
+    inited_.store(res, std::memory_order_release);
+  }
+  mu.Unlock();
+  return *res;
+}
+
+namespace {
+
+
+#if defined(NDEBUG) || !GOOGLE_PROTOBUF_INTERNAL_DONATE_STEAL
+
+class ScopedCheckPtrInvariants {
+ public:
+  explicit ScopedCheckPtrInvariants(const TaggedStringPtr*) {}
+};
+
+#endif  // NDEBUG || !GOOGLE_PROTOBUF_INTERNAL_DONATE_STEAL
+
+// Creates a heap allocated std::string value.
+inline TaggedStringPtr CreateString(ConstStringParam value) {
+  TaggedStringPtr res;
+  res.SetAllocated(new std::string(value.data(), value.length()));
+  return res;
+}
+
+#if !GOOGLE_PROTOBUF_INTERNAL_DONATE_STEAL
+
+// Creates an arena allocated std::string value.
+TaggedStringPtr CreateArenaString(Arena& arena, ConstStringParam s) {
+  TaggedStringPtr res;
+  res.SetMutableArena(Arena::Create<std::string>(&arena, s.data(), s.length()));
+  return res;
+}
+
+#endif  // !GOOGLE_PROTOBUF_INTERNAL_DONATE_STEAL
+
+}  // namespace
+
+std::string* ArenaStringPtr::Mutable(Arena* arena) {
+  ScopedCheckPtrInvariants check(&tagged_ptr_);
+  if (tagged_ptr_.IsMutable()) {
+    return tagged_ptr_.Get();
+  } else {
+    return MutableSlow(arena);
+  }
+}
+
+MaybeArenaStringAccessor ArenaStringPtr::MutableAccessor(Arena* arena) {
+  ScopedCheckPtrInvariants check(&tagged_ptr_);
+  if (IsDefault()) {
+    std::string* string;
+    if (arena != nullptr) {
+      string = ArenaStringAccessor::create(arena).underlying();
+      tagged_ptr_.SetFixedSizeArena(string);
+    } else {
+      string = new std::string;
+      tagged_ptr_.SetAllocated(string);
+    }
+    return MaybeArenaStringAccessor(arena, string);
+  } else {
+    return Accessor(arena);
+  }
+}
+
+std::string* ArenaStringPtr::Mutable(const LazyString& default_value,
+                                     Arena* arena) {
+  ScopedCheckPtrInvariants check(&tagged_ptr_);
+  if (tagged_ptr_.IsMutable()) {
+    return tagged_ptr_.Get();
+  } else {
+    return MutableSlow(arena, default_value);
+  }
+}
+
+MaybeArenaStringAccessor ArenaStringPtr::MutableAccessor(
+        const LazyString& default_value,
+        Arena* arena) {
+  ScopedCheckPtrInvariants check(&tagged_ptr_);
+  if (IsDefault()) {
+    std::string* string;
+    if (arena != nullptr) {
+      string = ArenaStringAccessor::create(
+          arena, default_value.get()).underlying();
+      tagged_ptr_.SetFixedSizeArena(string);
+    } else {
+      string = new std::string(default_value.get());
+      tagged_ptr_.SetAllocated(string);
+    }
+    return MaybeArenaStringAccessor(arena, string);
+  } else {
+    return Accessor(arena);
+  }
+}
+
+std::string* ArenaStringPtr::MutableNoCopy(Arena* arena) {
+  ScopedCheckPtrInvariants check(&tagged_ptr_);
+  if (tagged_ptr_.IsMutable()) {
+    return tagged_ptr_.Get();
+  } else {
+    GOOGLE_DCHECK(IsDefault());
+    // Allocate empty. The contents are not relevant.
+    return NewString(arena);
+  }
+}
+
+template <typename... Lazy>
+std::string* ArenaStringPtr::MutableSlow(::google::protobuf::Arena* arena,
+                                         const Lazy&... lazy_default) {
+  if (IsFixedSizeArena()) {
+    auto ptr = Arena::Create<std::string>(arena, *tagged_ptr_.Get());
+    tagged_ptr_.SetMutableArena(ptr);
+    return ptr;
+  }
+  GOOGLE_DCHECK(IsDefault());
+
+  // For empty defaults, this ends up calling the default constructor which is
+  // more efficient than a copy construction from
+  // GetEmptyStringAlreadyInited().
+  return NewString(arena, lazy_default.get()...);
+}
+
+std::string* ArenaStringPtr::Release() {
+  ScopedCheckPtrInvariants check(&tagged_ptr_);
+  if (IsDefault()) return nullptr;
+
+  std::string* released = tagged_ptr_.Get();
+  if (tagged_ptr_.IsArena()) {
+    released = tagged_ptr_.IsMutable() ? new std::string(std::move(*released))
+                                       : new std::string(*released);
+  }
+  InitDefault();
+  return released;
+}
+
+void ArenaStringPtr::SetAllocated(std::string* value, Arena* arena) {
+  ScopedCheckPtrInvariants check(&tagged_ptr_);
+  // Release what we have first.
+  Destroy();
+
+  if (value == nullptr) {
+    InitDefault();
+  } else {
+#ifndef NDEBUG
+    // On debug builds, copy the string so the address differs.  delete will
+    // fail if value was a stack-allocated temporary/etc., which would have
+    // failed when arena ran its cleanup list.
+    std::string* new_value = new std::string(std::move(*value));
+    delete value;
+    value = new_value;
+#endif  // !NDEBUG
+    InitAllocated(value, arena);
+  }
+}
+
+void ArenaStringPtr::Destroy() {
+  delete tagged_ptr_.GetIfAllocated();
+}
+
+void ArenaStringPtr::ClearToEmpty() {
+  ScopedCheckPtrInvariants check(&tagged_ptr_);
+  if (IsDefault()) {
+    // Already set to default -- do nothing.
+  } else {
+    // Unconditionally mask away the tag.
+    //
+    // UpdateArenaString uses assign when capacity is larger than the new
+    // value, which is trivially true in the donated string case.
+    // const_cast<std::string*>(PtrValue<std::string>())->clear();
+    ClearNonDefaultToEmpty();
+  }
+}
+
+void ArenaStringPtr::ClearToDefault(const LazyString& default_value,
+                                    ::google::protobuf::Arena* arena) {
+  ScopedCheckPtrInvariants check(&tagged_ptr_);
+  if (IsDefault()) {
+    // Already set to default -- do nothing.
+  } else {
+    Accessor(arena) = default_value.get();
+  }
+}
+}  // namespace patch
+const char* EpsCopyInputStream::ReadArenaString(const char* ptr,
+                                                patch::ArenaStringPtr* s,
+                                                Arena* arena) {
+  patch::ScopedCheckPtrInvariants check(&s->tagged_ptr_);
+  GOOGLE_DCHECK(arena != nullptr);
+
+  int size = ReadSize(&ptr);
+  if (!ptr) return nullptr;
+
+  auto* str = s->NewString(arena);
+  ptr = ReadString(ptr, size, str);
+  GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
+  return ptr;
+}
+
+const char* EpsCopyInputStream::ReadArenaString(const char* ptr,
+                                                MaybeArenaStringAccessor s) {
+  auto size = ReadSize(&ptr);
+  if (!ptr) return nullptr;
+
+  if (s.arena() != nullptr) {
+    ArenaStringAccessor& as = s;
+    auto* buffer = as.resize_uninitialized(size);
+
+    if (size <= buffer_end_ + kSlopBytes - ptr) {
+      memcpy(buffer, ptr, size);
+      return ptr + size;
+    }
+
+    return AppendSize(ptr, size, [&](const char* p, int s) {
+      memcpy(buffer, p, s);
+      buffer += s;
+    });
+  }
+
+  return ReadString(ptr, size, s.underlying());
+}
+
+/*static*/bool WireFormatLite::ReadArenaString(io::CodedInputStream* input,
+                                                      MaybeArenaStringAccessor s) {
+  uint32_t size;
+  input->ReadVarint32(&size);
+ 
+  if (s.arena() != nullptr) {
+    ArenaStringAccessor& as = s;
+    auto* buffer = as.resize_uninitialized(size);
+    (void)buffer;
+    return input->ReadString(as.underlying(), size);
+  }
+ 
+  return input->ReadString(s.underlying(), size);
+}
+
+}  // namespace internal
+}  // namespace protobuf
+}  // namespace google
+
+#include <google/protobuf/port_undef.inc>
diff --git a/src/google/protobuf/patch/arenastring.h b/src/google/protobuf/patch/arenastring.h
new file mode 100644
index 000000000..b2df52427
--- /dev/null
+++ b/src/google/protobuf/patch/arenastring.h
@@ -0,0 +1,502 @@
+// Protocol Buffers - Google's data interchange format
+// Copyright 2008 Google Inc.  All rights reserved.
+// https://developers.google.com/protocol-buffers/
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef GOOGLE_PROTOBUF_PATCH_ARENASTRING_H__
+#define GOOGLE_PROTOBUF_PATCH_ARENASTRING_H__
+
+#include <algorithm>
+#include <string>
+#include <type_traits>
+#include <utility>
+
+#include <google/protobuf/stubs/logging.h>
+#include <google/protobuf/stubs/common.h>
+#include <google/protobuf/arena.h>
+#include <google/protobuf/patch/arenastring_impl.h>
+#include <google/protobuf/port.h>
+//#include <google/protobuf/explicitly_constructed.h>
+
+// must be last:
+#include <google/protobuf/port_def.inc>
+
+#ifdef SWIG
+#error "You cannot SWIG proto headers"
+#endif
+
+
+namespace google {
+namespace protobuf {
+namespace internal {
+
+template <typename T>
+class ExplicitlyConstructed;
+using ExplicitlyConstructedArenaString = ExplicitlyConstructed<std::string>;
+
+class EpsCopyInputStream;
+class SwapFieldHelper;
+
+// Declared in message_lite.h
+PROTOBUF_EXPORT extern ExplicitlyConstructedArenaString
+    fixed_address_empty_string;
+
+namespace patch {
+
+// Lazy string instance to support string fields with non-empty default.
+// These are initialized on the first call to .get().
+class PROTOBUF_EXPORT LazyString {
+ public:
+  // We explicitly make LazyString an aggregate so that MSVC can do constant
+  // initialization on it without marking it `constexpr`.
+  // We do not want to use `constexpr` because it makes it harder to have extern
+  // storage for it and causes library bloat.
+  struct InitValue {
+    const char* ptr;
+    size_t size;
+  };
+  // We keep a union of the initialization value and the std::string to save on
+  // space. We don't need the string array after Init() is done.
+  union {
+    mutable InitValue init_value_;
+    alignas(std::string) mutable char string_buf_[sizeof(std::string)];
+  };
+  mutable std::atomic<const std::string*> inited_;
+
+  const std::string& get() const {
+    // This check generates less code than a call-once invocation.
+    auto* res = inited_.load(std::memory_order_acquire);
+    if (PROTOBUF_PREDICT_FALSE(res == nullptr)) return Init();
+    return *res;
+  }
+
+ private:
+  // Initialize the string in `string_buf_`, update `inited_` and return it.
+  // We return it here to avoid having to read it again in the inlined code.
+  const std::string& Init() const;
+};
+
+class TaggedStringPtr {
+ public:
+  // Bit flags qualifying string properties. We can use 2 bits as
+  // ptr_ is guaranteed and enforced to be aligned on 4 byte boundaries.
+  enum Flags {
+    kArenaBit = 0x1,      // ptr is arena allocated
+    kMutableBit = 0x2,    // ptr contents are fully mutable
+    kMask = 0x3           // Bit mask
+  };
+
+  // Composed logical types
+  enum Type {
+    // Default strings are immutable and never owned.
+    kDefault = 0,
+
+    // Allocated strings are mutable and (as the name implies) owned.
+    // A heap allocated string must be deleted.
+    kAllocated = kMutableBit,
+
+    // Mutable arena strings are strings where the string instance is owned
+    // by the arena, but the string contents itself are owned by the string
+    // instance. Mutable arena string instances need to be destroyed which is
+    // typically done through a cleanup action added to the arena owning it.
+    kMutableArena = kArenaBit | kMutableBit,
+
+    // Fixed size arena strings are strings where both the string instance and
+    // the string contents are fully owned by the arena. Fixed size arena
+    // strings are a platform and c++ library specific customization. Fixed
+    // size arena strings are immutable, with the exception of custom internal
+    // updates to the content that fit inside the existing capacity.
+    // Fixed size arena strings must never be deleted or destroyed.
+    kFixedSizeArena = kArenaBit,
+  };
+
+  TaggedStringPtr() = default;
+  explicit constexpr TaggedStringPtr(ExplicitlyConstructedArenaString* ptr)
+      : ptr_(ptr) {}
+  explicit constexpr TaggedStringPtr(const void* tagged_ptr)
+      : ptr_(const_cast<void*>(tagged_ptr)) {}
+
+  // Sets the value to `p`, tagging the value as being a 'default' value.
+  // See documentation for kDefault for more info.
+  inline const std::string* SetDefault(const std::string* p) {
+    return TagAs(kDefault, const_cast<std::string*>(p));
+  }
+
+  // Sets the value to `p`, tagging the value as a heap allocated value.
+  // Allocated strings are mutable and (as the name implies) owned.
+  // `p` must not be null
+  inline std::string* SetAllocated(std::string* p) {
+    return TagAs(kAllocated, p);
+  }
+
+  // Sets the value to `p`, tagging the value as a fixed size arena string.
+  // See documentation for kFixedSizeArena for more info.
+  // `p` must not be null
+  inline std::string* SetFixedSizeArena(std::string* p) {
+    return TagAs(kFixedSizeArena, p);
+  }
+
+  // Sets the value to `p`, tagging the value as a mutable arena string.
+  // See documentation for kMutableArena for more info.
+  // `p` must not be null
+  inline std::string* SetMutableArena(std::string* p) {
+    return TagAs(kMutableArena, p);
+  }
+
+  // Returns true if the contents of the current string are fully mutable.
+  inline bool IsMutable() const { return as_int() & kMutableBit; }
+
+  // Returns true if the current string is an immutable default value.
+  inline bool IsDefault() const { return (as_int() & kMask) == kDefault; }
+
+  // If the current string is a heap-allocated mutable value, returns a pointer
+  // to it.  Returns nullptr otherwise.
+  inline std::string *GetIfAllocated() const {
+    auto allocated = as_int() ^ kAllocated;
+    if (allocated & kMask) return nullptr;
+
+    auto ptr = reinterpret_cast<std::string*>(allocated);
+    PROTOBUF_ASSUME(ptr != nullptr);
+    return ptr;
+  }
+
+  // Returns true if the current string is an arena allocated value.
+  // This means it's either a mutable or fixed size arena string.
+  inline bool IsArena() const { return as_int() & kArenaBit; }
+
+  // Returns true if the current string is a fixed size arena allocated value.
+  inline bool IsFixedSizeArena() const {
+    return (as_int() & kMask) == kFixedSizeArena;
+  }
+
+  // Returns the contained string pointer.
+  inline std::string* Get() const {
+    return reinterpret_cast<std::string*>(as_int() & ~kMask);
+  }
+
+  inline void* GetTagged() const {
+    return ptr_;
+  }
+
+  // Returns true if the contained pointer is null, indicating some error.
+  // The Null value is only used during parsing for temporary values.
+  // A persisted ArenaStringPtr value is never null.
+  inline bool IsNull() { return ptr_ == nullptr; }
+
+ private:
+  static inline void assert_aligned(const void* p) {
+    GOOGLE_DCHECK_EQ(reinterpret_cast<uintptr_t>(p) & kMask, 0UL);
+  }
+
+  inline std::string* TagAs(Type type, std::string* p) {
+    GOOGLE_DCHECK(p != nullptr);
+    assert_aligned(p);
+    ptr_ = reinterpret_cast<void*>(reinterpret_cast<uintptr_t>(p) | type);
+    return p;
+  }
+
+  uintptr_t as_int() const { return reinterpret_cast<uintptr_t>(ptr_); }
+  void* ptr_;
+};
+
+static_assert(std::is_trivial<TaggedStringPtr>::value,
+              "TaggedStringPtr must be trivial");
+
+// This class encapsulates a pointer to a std::string with or without arena
+// owned contents, tagged by the bottom bits of the string pointer. It is a
+// high-level wrapper that almost directly corresponds to the interface required
+// by string fields in generated code. It replaces the old std::string* pointer
+// in such cases.
+//
+// The string pointer is tagged to be either a default, externally owned value,
+// a mutable heap allocated value, or an arena allocated value. The object uses
+// a single global instance of an empty string that is used as the initial
+// default value. Fields that have empty default values directly use this global
+// default. Fields that have non empty default values are supported through
+// lazily initialized default values managed by the LazyString class.
+//
+// Generated code and reflection code both ensure that ptr_ is never null.
+// Because ArenaStringPtr is used in oneof unions, its constructor is a NOP and
+// the field is always manually initialized via method calls.
+//
+// See TaggedStringPtr for more information about the types of string values
+// being held, and the mutable and ownership invariants for each type.
+struct PROTOBUF_EXPORT ArenaStringPtr {
+  ArenaStringPtr() = default;
+  constexpr ArenaStringPtr(ExplicitlyConstructedArenaString* default_value,
+                           ConstantInitialized)
+      : tagged_ptr_(default_value) {}
+
+  // Called from generated code / reflection runtime only. Resets value to point
+  // to a default string pointer, with the semantics that this ArenaStringPtr
+  // does not own the pointed-to memory. Disregards initial value of ptr_ (so
+  // this is the *ONLY* safe method to call after construction or when
+  // reinitializing after becoming the active field in a oneof union).
+  inline void InitDefault();
+
+  // Similar to `InitDefault` except that it allows the default value to be
+  // initialized to an externally owned string. This method is called from
+  // parsing code. `str` must not be null and outlive this instance.
+  inline void InitExternal(const std::string* str);
+
+  // Called from generated code / reflection runtime only. Resets the value of
+  // this instances to the heap allocated value in `str`. `str` must not be
+  // null. Invokes `arena->Own(str)` to transfer ownership into the arena if
+  // `arena` is not null, else, `str` will be owned by ArenaStringPtr. This
+  // function should only be used to initialize a ArenaStringPtr or on an
+  // instance known to not carry any heap allocated value.
+  inline void InitAllocated(std::string* str, Arena* arena);
+
+  template <typename T>
+  void Set(T&& value, Arena* arena);
+  void Set(const char* s, size_t n, Arena* arena);
+
+  template <typename T>
+  void SetBytes(T&& value, Arena* arena);
+  void SetBytes(const void* p, size_t n, Arena* arena);
+
+  // Returns a mutable std::string reference.
+  // The version accepting a `LazyString` value is used in the generated code to
+  // initialize mutable copies for fields with a non-empty default where the
+  // default value is lazily initialized.
+  std::string* Mutable(Arena* arena);
+  MaybeArenaStringAccessor MutableAccessor(Arena* arena);
+  std::string* Mutable(const LazyString& default_value, Arena* arena);
+  MaybeArenaStringAccessor MutableAccessor(const LazyString& default_value, Arena* arena);
+
+  // Gets a mutable pointer with unspecified contents.
+  // This function is identical to Mutable(), except it is optimized for the
+  // case where the caller is not interested in the current contents. For
+  // example, if the current field is not mutable, it will re-initialize the
+  // value with an empty string rather than a (non-empty) default value.
+  // Likewise, if the current value is a fixed size arena string with contents,
+  // it will be initialized into an empty mutable arena string.
+  std::string* MutableNoCopy(Arena* arena);
+
+  // Basic accessors.
+  PROTOBUF_NDEBUG_INLINE const std::string& Get() const {
+    // Unconditionally mask away the tag.
+    return *tagged_ptr_.Get();
+  }
+
+  // Returns a pointer to the stored contents for this instance.
+  // This method is for internal debugging and tracking purposes only.
+  PROTOBUF_NDEBUG_INLINE const std::string* UnsafeGetPointer() const
+      PROTOBUF_RETURNS_NONNULL {
+    return tagged_ptr_.Get();
+  }
+
+  // Release returns a std::string* instance that is heap-allocated and is not
+  // Own()'d by any arena. If the field is not set, this returns nullptr. The
+  // caller retains ownership. Clears this field back to the default state.
+  // Used to implement release_<field>() methods on generated classes.
+  PROTOBUF_MUST_USE_RESULT std::string* Release();
+
+  // Takes a std::string that is heap-allocated, and takes ownership. The
+  // std::string's destructor is registered with the arena. Used to implement
+  // set_allocated_<field> in generated classes.
+  void SetAllocated(std::string* value, Arena* arena);
+
+  // Frees storage (if not on an arena).
+  void Destroy();
+
+  // Clears content, but keeps allocated std::string, to avoid the overhead of
+  // heap operations. After this returns, the content (as seen by the user) will
+  // always be the empty std::string. Assumes that |default_value| is an empty
+  // std::string.
+  void ClearToEmpty();
+
+  // Clears content, assuming that the current value is not the empty
+  // string default.
+  void ClearNonDefaultToEmpty();
+
+  // Clears content, but keeps allocated std::string if arena != nullptr, to
+  // avoid the overhead of heap operations. After this returns, the content
+  // (as seen by the user) will always be equal to |default_value|.
+  void ClearToDefault(const LazyString& default_value, ::google::protobuf::Arena* arena);
+
+  // Swaps internal pointers. Arena-safety semantics: this is guarded by the
+  // logic in Swap()/UnsafeArenaSwap() at the message level, so this method is
+  // 'unsafe' if called directly.
+  inline PROTOBUF_NDEBUG_INLINE static void InternalSwap(ArenaStringPtr* rhs,
+                                                         Arena* rhs_arena,
+                                                         ArenaStringPtr* lhs,
+                                                         Arena* lhs_arena);
+
+  // Internal setter used only at parse time to directly set a donated string
+  // value.
+  void UnsafeSetTaggedPointer(TaggedStringPtr value) { tagged_ptr_ = value; }
+  // Generated code only! An optimization, in certain cases the generated
+  // code is certain we can obtain a std::string with no default checks and
+  // tag tests.
+  std::string* UnsafeMutablePointer() PROTOBUF_RETURNS_NONNULL;
+
+  // Returns true if this instances holds an immutable default value.
+  inline bool IsDefault() const { return tagged_ptr_.IsDefault(); }
+
+ private:
+  template <typename... Args>
+  inline std::string* NewString(Arena* arena, Args&&... args) {
+    if (arena == nullptr) {
+      auto* s = new std::string(std::forward<Args>(args)...);
+      return tagged_ptr_.SetAllocated(s);
+    } else {
+      auto* s = Arena::Create<std::string>(arena, std::forward<Args>(args)...);
+      return tagged_ptr_.SetMutableArena(s);
+    }
+  }
+
+  TaggedStringPtr tagged_ptr_;
+
+  bool IsFixedSizeArena() const {
+    return tagged_ptr_.IsFixedSizeArena();
+  }
+
+  // Swaps tagged pointer without debug hardening. This is to allow python
+  // protobuf to maintain pointer stability even in DEBUG builds.
+  inline PROTOBUF_NDEBUG_INLINE static void UnsafeShallowSwap(
+      ArenaStringPtr* rhs, ArenaStringPtr* lhs) {
+    std::swap(lhs->tagged_ptr_, rhs->tagged_ptr_);
+  }
+
+  inline PROTOBUF_ALWAYS_INLINE MaybeArenaStringAccessor Accessor(Arena* arena) {
+    return MaybeArenaStringAccessor(
+            tagged_ptr_.IsFixedSizeArena() ? arena : nullptr,
+            tagged_ptr_.Get());
+  }
+
+  friend class ::google::protobuf::internal::SwapFieldHelper;
+  friend class TcParser;
+
+  // Slow paths.
+
+  // MutableSlow requires that !IsString() || IsDefault
+  // Variadic to support 0 args for empty default and 1 arg for LazyString.
+  template <typename... Lazy>
+  std::string* MutableSlow(::google::protobuf::Arena* arena, const Lazy&... lazy_default);
+
+  friend class ::google::protobuf::internal::EpsCopyInputStream;
+};
+
+inline void ArenaStringPtr::InitDefault() {
+  tagged_ptr_ = TaggedStringPtr(&fixed_address_empty_string);
+}
+
+inline void ArenaStringPtr::InitExternal(const std::string* str) {
+  tagged_ptr_.SetDefault(str);
+}
+
+inline void ArenaStringPtr::InitAllocated(std::string* str, Arena* arena) {
+  if (arena != nullptr) {
+    tagged_ptr_.SetMutableArena(str);
+    arena->Own(str);
+  } else {
+    tagged_ptr_.SetAllocated(str);
+  }
+}
+
+template <typename T>
+inline void ArenaStringPtr::Set(T&& value, Arena* arena) {
+  if (IsDefault()) {
+    if (arena != nullptr) {
+      tagged_ptr_.SetFixedSizeArena(
+          ArenaStringAccessor::create(
+              arena, std::forward<T>(value)).underlying());
+    } else {
+      tagged_ptr_.SetAllocated(new std::string(std::forward<T>(value)));
+    }
+  } else {
+    Accessor(arena) = std::forward<T>(value);
+  }
+}
+
+inline void ArenaStringPtr::Set(const char* s, size_t n, Arena* arena) {
+  Set(StringPiece{s, n}, arena);
+}
+
+template <typename T>
+inline void ArenaStringPtr::SetBytes(T&& value, Arena* arena) {
+  Set(std::forward<T>(value), arena);
+}
+
+inline void ArenaStringPtr::SetBytes(const void* p, size_t n, Arena* arena) {
+  Set(static_cast<const char*>(p), n, arena);
+}
+
+// Make sure rhs_arena allocated rhs, and lhs_arena allocated lhs.
+inline PROTOBUF_NDEBUG_INLINE void ArenaStringPtr::InternalSwap(  //
+    ArenaStringPtr* rhs, Arena* rhs_arena,                        //
+    ArenaStringPtr* lhs, Arena* lhs_arena) {
+  // Silence unused variable warnings in release buildls.
+  (void)rhs_arena;
+  (void)lhs_arena;
+  std::swap(lhs->tagged_ptr_, rhs->tagged_ptr_);
+#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+  auto force_realloc = [](ArenaStringPtr* p, Arena* arena) {
+    if (p->IsDefault()) return;
+    std::string* old_value = p->tagged_ptr_.Get();
+    std::string* new_value =
+        p->IsFixedSizeArena()
+            ? Arena::Create<std::string>(arena, *old_value)
+            : Arena::Create<std::string>(arena, std::move(*old_value));
+    if (arena == nullptr) {
+      delete old_value;
+      p->tagged_ptr_.SetAllocated(new_value);
+    } else {
+      p->tagged_ptr_.SetMutableArena(new_value);
+    }
+  };
+  // Because, at this point, tagged_ptr_ has been swapped, arena should also be
+  // swapped.
+  force_realloc(lhs, rhs_arena);
+  force_realloc(rhs, lhs_arena);
+#endif  // PROTOBUF_FORCE_COPY_IN_SWAP
+}
+
+inline void ArenaStringPtr::ClearNonDefaultToEmpty() {
+  MaybeArenaStringAccessor::clear(tagged_ptr_.Get());
+}
+
+inline std::string* ArenaStringPtr::UnsafeMutablePointer() {
+  GOOGLE_DCHECK(tagged_ptr_.IsMutable());
+  GOOGLE_DCHECK(tagged_ptr_.Get() != nullptr);
+  return tagged_ptr_.Get();
+}
+
+}  // namespace patch
+
+using TaggedStringPtrWithPatch = patch::TaggedStringPtr;
+using LazyStringWithPatch = patch::LazyString;
+
+}  // namespace internal
+}  // namespace protobuf
+}  // namespace google
+
+#include <google/protobuf/port_undef.inc>
+
+#endif  // GOOGLE_PROTOBUF_PATCH_ARENASTRING_H__
diff --git a/src/google/protobuf/patch/arenastring_impl.cc b/src/google/protobuf/patch/arenastring_impl.cc
new file mode 100644
index 000000000..abdb508c5
--- /dev/null
+++ b/src/google/protobuf/patch/arenastring_impl.cc
@@ -0,0 +1,155 @@
+#include <google/protobuf/patch/arenastring_impl.h>
+
+#include <google/protobuf/port_def.inc>
+
+namespace google {
+namespace protobuf {
+
+ArenaStringAccessor& ArenaStringAccessor::assign(
+        const_pointer data, size_type size) noexcept {
+    auto* buffer = qualified_buffer(size);
+    set_size(size);
+    __builtin_memcpy(buffer, data, size);
+    buffer[size] = '\0';
+    return *this;
+}
+
+void ArenaStringAccessor::reserve(size_type required_capacity) noexcept {
+    if (required_capacity > capacity()) {
+        auto origin_size = size();
+        recreate_buffer(required_capacity);
+        set_size_and_terminator(origin_size);
+    }
+}
+
+void ArenaStringAccessor::push_back(value_type c) noexcept {
+    auto origin_size = size();
+    auto* buffer = qualified_buffer(origin_size + 1, origin_size << 1);
+    set_size(origin_size + 1);
+    buffer[origin_size] = c;
+    buffer[origin_size + 1] = '\0';
+}
+
+ArenaStringAccessor& ArenaStringAccessor::append(
+        const_pointer append_data, size_type append_size) noexcept {
+    auto origin_size = size();
+    auto* buffer = qualified_buffer(origin_size + append_size);
+    set_size(origin_size + append_size);
+    __builtin_memcpy(buffer + origin_size, append_data, append_size);
+    buffer[origin_size + append_size] = '\0';
+    return *this;
+}
+
+void ArenaStringAccessor::swap(ArenaStringAccessor other) noexcept {
+#if __GLIBCXX__ && !_GLIBCXX_USE_CXX11_ABI
+    auto* tmp = representation().data;
+    *reinterpret_cast<pointer*>(_ptr) = other.representation().data;
+    *reinterpret_cast<pointer*>(other._ptr) = tmp;
+#else // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+    _ptr->swap(*other._ptr);
+#endif // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+}
+
+void ArenaStringAccessor::resize(size_type new_size, value_type c) noexcept {
+    auto origin_size = size();
+    auto* buffer = qualified_buffer(new_size);
+    set_size_and_terminator(new_size);
+    if (new_size > origin_size) {
+        __builtin_memset(buffer, c, new_size - origin_size);
+    }
+}
+ 
+internal::StdStringRep& ArenaStringAccessor::representation() noexcept {
+#if __GLIBCXX__ && !_GLIBCXX_USE_CXX11_ABI
+    return *(*reinterpret_cast<StdStringRep**>(_ptr) - 1);
+#else // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+    return *reinterpret_cast<StdStringRep*>(_ptr);
+#endif // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+}
+
+ArenaStringAccessor::pointer ArenaStringAccessor::recreate_buffer(
+        size_type capacity) noexcept {
+#if __GLIBCXX__
+    size_t buffer_size = capacity + 1;
+    buffer_size = (buffer_size + 8) & static_cast<size_t>(-8);
+    capacity = buffer_size - 1;
+#if _GLIBCXX_USE_CXX11_ABI
+    auto* buffer = reinterpret_cast<char*>(_arena->AllocateAligned(buffer_size));
+    __builtin_memcpy(buffer, data(), size());
+    auto& rep = representation();
+    rep.data = buffer;
+    rep.capacity = capacity;
+    return buffer;
+#else // !_GLIBCXX_USE_CXX11_ABI
+    auto* rep = reinterpret_cast<StdStringRep*>(_arena->AllocateAligned(
+            sizeof(StdStringRep) + buffer_size));
+    rep->capacity = capacity;
+    rep->refcount = -1;
+    __builtin_memcpy(rep->data, data(), size());
+    *reinterpret_cast<pointer*>(_ptr) = rep->data;
+    return rep->data;
+#endif // !_GLIBCXX_USE_CXX11_ABI
+#else // !__GLIBCXX__
+    capacity = (capacity + 16) & static_cast<size_type>(-16);
+    auto* buffer = reinterpret_cast<pointer>(_arena->AllocateAligned(capacity));
+    __builtin_memcpy(buffer, data(), size());
+    auto& rep = representation();
+    rep.long_format.data = buffer;
+    rep.long_format.capacity = capacity + 1;
+    return rep.long_format.data;
+#endif // !__GLIBCXX__
+}
+
+ArenaStringAccessor::pointer ArenaStringAccessor::writable_buffer() noexcept {
+#if __GLIBCXX__ && !_GLIBCXX_USE_CXX11_ABI
+    return representation().refcount <= 0 ? representation().data : &(*_ptr)[0];
+#else // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+    return &(*_ptr)[0];
+#endif // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+}
+
+void ArenaStringAccessor::set_size(size_type size) noexcept {
+#if __GLIBCXX__
+    auto& rep = representation();
+    rep.size = size;
+#else // !__GLIBCXX__
+    auto& rep = representation();
+    if (rep.is_long()) {
+        rep.long_format.size = size;
+    } else {
+        rep.shot_format.size = size << 1;
+    }
+#endif // !__GLIBCXX__
+}
+
+void ArenaStringAccessor::set_size_and_terminator(size_type size) noexcept {
+#if __GLIBCXX__
+    auto& rep = representation();
+    rep.size = size;
+    rep.data[size] = '\0';
+#else // !__GLIBCXX__
+    auto& rep = representation();
+    if (rep.is_long()) {
+        rep.long_format.size = size;
+        rep.long_format.data[size] = '\0';
+    } else {
+        rep.shot_format.size = size << 1;
+        rep.shot_format.data[size] = '\0';
+    }
+#endif // !__GLIBCXX__
+}
+
+void MaybeArenaStringAccessor::clear() noexcept {
+#if __GLIBCXX__ && !_GLIBCXX_USE_CXX11_ABI
+    if (representation().refcount <= 0) {
+        ArenaStringAccessor::clear();
+        return;
+    }
+#endif // !__GLIBCXX__ || _GLIBCXX_USE_CXX11_ABI
+    underlying()->clear();
+}
+
+} // namespace protobuf
+} // namespace google
+
+#include <google/protobuf/port_undef.inc>
diff --git a/src/google/protobuf/patch/arenastring_impl.h b/src/google/protobuf/patch/arenastring_impl.h
new file mode 100644
index 000000000..60f69cacc
--- /dev/null
+++ b/src/google/protobuf/patch/arenastring_impl.h
@@ -0,0 +1,475 @@
+#pragma once
+
+// feature check macro
+#define GOOGLE_PROTOBUF_HAS_DONATED_STRING 1
+
+#include <google/protobuf/arena.h>
+#include <google/protobuf/config.h>
+// #include <google/protobuf/explicitly_constructed.h>
+#include <google/protobuf/stubs/stringpiece.h>
+
+#include <google/protobuf/port_def.inc>
+
+namespace google {
+namespace protobuf {
+
+namespace internal {
+
+#if __GLIBCXX__
+#if _GLIBCXX_USE_CXX11_ABI
+struct StdStringRep {
+    char* data;
+    uint64_t size;
+    union {
+        uint64_t capacity;
+        char local[16];
+    };
+};
+#else // !_GLIBCXX_USE_CXX11_ABI
+struct StdStringRep {
+    uint64_t size;
+    uint64_t capacity;
+    int32_t refcount;
+    uint32_t gap;
+    char data[0];
+};
+#endif // !_GLIBCXX_USE_CXX11_ABI
+#elif _LIBCPP_VERSION // && !__GLIBCXX__
+#if _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT 
+static_assert(false, "don not support _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT yet");
+#endif // _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT
+#if _LIBCPP_BIG_ENDIAN
+static_assert(false, "don not support _LIBCPP_BIG_ENDIAN yet");
+#endif // _LIBCPP_BIG_ENDIAN
+union StdStringRep {
+    struct {
+        typename ::std::string::size_type capacity;
+        typename ::std::string::size_type size;
+        typename ::std::string::pointer data;
+    } long_format;
+    struct {
+        uint8_t size;
+        typename ::std::string::value_type data[0];
+    } shot_format;
+
+    inline bool is_long() const noexcept {
+        return shot_format.size & 0x01;
+    }
+
+    inline ::std::string::size_type long_capacity() const noexcept {
+        return long_format.capacity & ~static_cast<::std::string::size_type>(0x01);
+    }
+};
+#endif // _LIBCPP_VERSION && !__GLIBCXX__
+} // internal
+
+// ArenaString的访问器，操作明确分配在Arena上的string
+class ArenaStringAccessor {
+public:
+    typedef typename ::std::string::value_type value_type;
+    typedef typename ::std::string::traits_type traits_type;
+    typedef typename ::std::string::allocator_type allocator_type;
+    typedef typename ::std::string::size_type size_type;
+    typedef typename ::std::string::difference_type difference_type;
+    typedef typename ::std::string::reference reference;
+    typedef typename ::std::string::const_reference const_reference;
+    typedef typename ::std::string::pointer pointer;
+    typedef typename ::std::string::const_pointer const_pointer;
+    typedef pointer iterator;
+    typedef const_pointer const_iterator;
+    typedef ::std::reverse_iterator<pointer> reverse_iterator;
+    typedef ::std::reverse_iterator<const_pointer> const_reverse_iterator;
+    typedef internal::StdStringRep StdStringRep;
+
+    // 禁用默认构造和拷贝和移动赋值，避免出错
+    inline ArenaStringAccessor() = delete;
+    inline ArenaStringAccessor(ArenaStringAccessor&&) noexcept = default;
+    inline ArenaStringAccessor(const ArenaStringAccessor&) noexcept = default;
+    inline ArenaStringAccessor& operator=(ArenaStringAccessor&&) = delete;
+    inline ArenaStringAccessor& operator=(const ArenaStringAccessor&) = delete;
+
+    // 赋值
+    inline ArenaStringAccessor& operator=(StringPiece other) noexcept {
+        return assign(other.data(), other.size());
+    }
+    inline ArenaStringAccessor& assign(StringPiece other) noexcept {
+        return assign(other.data(), other.size());
+    }
+    ArenaStringAccessor& assign(const_pointer data, size_type size) noexcept;
+    template <typename T>
+    inline ArenaStringAccessor& operator=(::std::reference_wrapper<T> other) noexcept {
+        return assign(other);
+    }
+    template <typename T>
+    inline ArenaStringAccessor& assign(::std::reference_wrapper<T> other) noexcept {
+        return assign(other.get());
+    }
+
+    // 访问
+    inline reference operator[](size_type position) noexcept {
+        return writable_buffer()[position];
+    }
+    inline const_reference operator[](size_type position) const noexcept {
+        return data()[position];
+    }
+    inline const_pointer data() const noexcept {
+        return c_str();
+    }
+    inline const_pointer c_str() const noexcept {
+        return static_cast<const ::std::string*>(_ptr)->c_str();
+    }
+    inline operator StringPiece() const noexcept {
+        return StringPiece(data(), size());
+    }
+    inline operator const ::std::string&() const noexcept {
+        return *_ptr;
+    }
+
+    // 迭代器
+    inline iterator begin() noexcept {
+        return iterator(writable_buffer());
+    }
+    inline const_iterator cbegin() const noexcept {
+        return const_iterator(data());
+    }
+    inline const_iterator end() noexcept {
+        return iterator(writable_buffer() + size());
+    }
+    inline const_iterator cend() const noexcept {
+        return const_iterator(data() + size());
+    }
+
+    // 容量
+    inline bool empty() const noexcept {
+        return _ptr->empty();
+    }
+    inline size_type size() const noexcept {
+        return _ptr->size();
+    }
+    void reserve(size_type required_capacity) noexcept;
+    inline size_type capacity() const noexcept {
+        return _ptr->capacity();
+    }
+
+    // 操作
+    inline void clear() noexcept {
+        set_size_and_terminator(0);
+    }
+
+    // ArenaStringAccessor& insert(size_type index, size_type count, value_type value);
+    // ArenaStringAccessor& erase(size_type index, size_type count);
+
+    void push_back(value_type c) noexcept;
+
+    // void pop_back();
+
+    inline ArenaStringAccessor& append(StringPiece sv) noexcept {
+        return append(sv.data(), sv.size());
+    }
+
+    ArenaStringAccessor& append(const_pointer append_data,
+                                       size_type append_size) noexcept;
+
+    inline ArenaStringAccessor& operator+=(StringPiece sv) noexcept {
+        return append(sv.data(), sv.size());
+    }
+
+    inline int compare(StringPiece other) const noexcept {
+        return static_cast<StringPiece>(*this).compare(other);
+    }
+
+    void swap(ArenaStringAccessor other) noexcept;
+
+    // size_type find(value_type value, size_type pos) const;
+    
+    void resize(size_type new_size) noexcept {
+        resize(new_size, '\0');
+    }
+    void resize(size_type new_size, value_type c) noexcept;
+
+    ////////////////////////////////////////////////////////////////////////////
+    // 不同于std::string的特殊功能
+
+    // 包装构造，用于从ArenaStringPtr将Arena和ptr打包返回
+    inline ArenaStringAccessor(Arena* arena, ::std::string* ptr) noexcept :
+        _arena(arena), _ptr(ptr) {}
+
+    inline Arena* arena() const noexcept {
+        return _arena;
+    }
+
+    inline ::std::string* underlying() const noexcept {
+        return _ptr;
+    }
+
+    inline pointer resize_uninitialized(size_type new_size) noexcept {
+        auto* buffer = qualified_buffer(new_size);
+        set_size_and_terminator(new_size);
+        return buffer;
+    }
+
+    inline static ArenaStringAccessor create(Arena* arena) noexcept {
+        // ArenaString不需要析构和释放内存，因此不能采用Arena::Create<::std::string>(arena)
+        // 独立进行分配和构造两个动作
+        auto* ptr = reinterpret_cast<::std::string*>(arena->AllocateAligned(sizeof(::std::string)));
+        new (ptr) ::std::string();
+        return ArenaStringAccessor(arena, ptr);
+    }
+
+    template <typename T>
+    inline static ArenaStringAccessor create(Arena* arena, T&& value) noexcept {
+        return create(arena) = ::std::forward<T>(value);
+    }
+
+    // clear动作不需要使用arena，可以直接对string生效
+    inline static void clear(::std::string* ptr) noexcept {
+        ArenaStringAccessor(nullptr, ptr).clear();
+    }
+
+    // swap动作不需要使用arena，可以直接对string生效
+    //inline static void swap(::std::string* left, ::std::string* right) noexcept {
+    //    ArenaStringAccessor(nullptr, left).swap(
+    //            ArenaStringAccessor(nullptr, right));
+    //}
+    ////////////////////////////////////////////////////////////////////////////
+
+protected:
+    StdStringRep& representation() noexcept;
+
+    pointer recreate_buffer(size_type capacity) noexcept;
+
+    pointer writable_buffer() noexcept;
+
+    inline pointer qualified_buffer(size_type required_capacity,
+                                    size_type predict_capacity) noexcept{
+        return required_capacity <= capacity() ? writable_buffer() : recreate_buffer(predict_capacity);
+    }
+
+    inline pointer qualified_buffer(size_type required_capacity) noexcept {
+        return qualified_buffer(required_capacity, required_capacity);
+    }
+
+    void set_size(size_type size) noexcept;
+
+    void set_size_and_terminator(size_type size) noexcept;
+
+    Arena* _arena;
+    ::std::string* _ptr;
+};
+
+inline bool operator==(const ArenaStringAccessor& left, const ArenaStringAccessor& right) noexcept {
+    return static_cast<StringPiece>(left) == static_cast<StringPiece>(right);
+}
+
+inline bool operator==(StringPiece left, const ArenaStringAccessor& right) noexcept {
+    return left == static_cast<StringPiece>(right);
+}
+
+inline bool operator==(const ArenaStringAccessor& left, StringPiece right) noexcept {
+    return static_cast<StringPiece>(left) == right;
+}
+
+inline bool operator!=(const ArenaStringAccessor& left, const ArenaStringAccessor& right) noexcept {
+    return !(left == right);
+}
+
+inline bool operator!=(StringPiece left, const ArenaStringAccessor& right) noexcept {
+    return !(left == right);
+}
+
+inline bool operator!=(const ArenaStringAccessor& left, StringPiece right) noexcept {
+    return !(left == right);
+}
+
+class MaybeArenaStringAccessor : public ArenaStringAccessor {
+public:
+    using ArenaStringAccessor::ArenaStringAccessor;
+
+    MaybeArenaStringAccessor(const ArenaStringAccessor& other) noexcept : ArenaStringAccessor(other) {}
+
+    // 赋值
+    template <typename T>
+    inline MaybeArenaStringAccessor& operator=(T&& other) {
+        return assign(::std::forward<T>(other));
+    }
+    template <typename T>
+    inline MaybeArenaStringAccessor& assign(T&& other) {
+        StringPiece sv(::std::forward<T>(other));
+        return assign(sv.data(), sv.size());
+    }
+    inline MaybeArenaStringAccessor& assign(const_pointer data, size_type size) {
+        if (arena() != nullptr) {
+            ArenaStringAccessor::assign(data, size);
+        } else {
+            underlying()->assign(data, size);
+        }
+        return *this;
+    }
+
+    // string单独处理，避免在非Arena场景下失去copy on write
+    inline MaybeArenaStringAccessor& operator=(const ::std::string& other) {
+        return assign(other);
+    }
+    inline MaybeArenaStringAccessor& assign(const ::std::string& other) {
+        if (arena() != nullptr) {
+            ArenaStringAccessor::assign(other);
+        } else {
+            underlying()->assign(other);
+        }
+        return *this;
+    }
+    inline MaybeArenaStringAccessor& operator=(::std::string& other) {
+        return assign(static_cast<const ::std::string&>(other));
+    }
+    inline MaybeArenaStringAccessor& assign(::std::string& other) {
+        return assign(static_cast<const ::std::string&>(other));
+    }
+    inline MaybeArenaStringAccessor& operator=(::std::string&& other) {
+        return assign(::std::move(other));
+    }
+    inline MaybeArenaStringAccessor& assign(::std::string&& other) {
+        if (arena() != nullptr) {
+            ArenaStringAccessor::assign(other);
+        } else {
+            underlying()->assign(::std::move(other));
+        }
+        return *this;
+    }
+    template <typename T>
+    inline MaybeArenaStringAccessor& operator=(::std::reference_wrapper<T> other) {
+        return assign(other);
+    }
+    template <typename T>
+    inline MaybeArenaStringAccessor& assign(::std::reference_wrapper<T> other) {
+        return assign(other.get());
+    }
+
+    inline void reserve(size_type required_capacity) {
+        if (arena() != nullptr) {
+            ArenaStringAccessor::reserve(required_capacity);
+        } else if (required_capacity > capacity()) {
+            underlying()->reserve(required_capacity);
+        }
+    }
+
+    void clear() noexcept;
+
+    inline void push_back(value_type c) {
+        if (arena() != nullptr) {
+            ArenaStringAccessor::push_back(c);
+        } else {
+            underlying()->push_back(c);
+        }
+    }
+
+    inline MaybeArenaStringAccessor& append(StringPiece piece) {
+        return append(piece.data(), piece.size());
+    }
+
+    inline MaybeArenaStringAccessor& append(const_pointer data, size_type size) {
+        if (arena() != nullptr) {
+            ArenaStringAccessor::append(data, size);
+        } else {
+            underlying()->append(data, size);
+        }
+        return *this;
+    }
+
+    inline void swap(MaybeArenaStringAccessor other) noexcept {
+        if (arena() != nullptr && arena() == other.arena()) {
+            ArenaStringAccessor::swap(other);
+        } else {
+            ::std::string tmp(*underlying());
+            assign(other);
+            other.assign(::std::move(tmp));
+        }
+    }
+
+    inline void resize(size_type size) {
+        if (arena() != nullptr) {
+            ArenaStringAccessor::resize(size);
+        } else {
+            underlying()->resize(size);
+        }
+    }
+    inline void resize(size_type size, value_type c) {
+        if (arena() != nullptr) {
+            ArenaStringAccessor::resize(size, c);
+        } else {
+            underlying()->resize(size, c);
+        }
+    }
+
+    ////////////////////////////////////////////////////////////////////////////
+    // 修改ArenaStringAccessor中不同于std::string的特殊功能
+
+    inline MaybeArenaStringAccessor(::std::string* string) noexcept :
+        ArenaStringAccessor(nullptr, string) {}
+
+    using ArenaStringAccessor::arena;
+    using ArenaStringAccessor::underlying;
+
+    inline pointer resize_uninitialized(size_type size) {
+        if (arena() != nullptr) {
+            return ArenaStringAccessor::resize_uninitialized(size);
+        } else {
+            underlying()->resize(size);
+            return &(*underlying())[0];
+        }
+    }
+
+    inline static MaybeArenaStringAccessor create(Arena* arena) {
+        if (arena != nullptr) {
+            return ArenaStringAccessor::create(arena);
+        } else {
+            return MaybeArenaStringAccessor(new ::std::string);
+        }
+    }
+    
+    template <typename T>
+    inline static MaybeArenaStringAccessor create(Arena* arena, T&& value) {
+        return create(arena) = ::std::forward<T>(value);
+    }
+    ////////////////////////////////////////////////////////////////////////////
+
+    ////////////////////////////////////////////////////////////////////////////
+    // 提供更多不同于std::string的特殊功能
+
+    // 仿自身指针，以便尽量接近std::string*的行为
+    inline MaybeArenaStringAccessor* operator->() {
+        return this;
+    }
+    inline const MaybeArenaStringAccessor* operator->() const {
+        return this;
+    }
+    inline MaybeArenaStringAccessor& operator*() {
+        return *this;
+    }
+    inline const MaybeArenaStringAccessor& operator*() const {
+        return *this;
+    }
+
+    inline static void clear(::std::string* ptr) noexcept {
+        MaybeArenaStringAccessor(ptr).clear();
+    }
+    ////////////////////////////////////////////////////////////////////////////
+    
+    inline void destroy() noexcept {
+        if (arena() == nullptr) {
+            delete underlying();
+        }
+    }
+};
+
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+using MutableStringType = MaybeArenaStringAccessor;
+using MutableStringReferenceType = MaybeArenaStringAccessor;
+#else // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+using MutableStringType = ::std::string*;
+using MutableStringReferenceType = ::std::string&;
+#endif // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+
+} // namespace protobuf
+} // namespace google
+
+#include <google/protobuf/port_undef.inc>
diff --git a/src/google/protobuf/patch/extension_set_heavy_with_arenastring.cc b/src/google/protobuf/patch/extension_set_heavy_with_arenastring.cc
new file mode 100644
index 000000000..92efc28ca
--- /dev/null
+++ b/src/google/protobuf/patch/extension_set_heavy_with_arenastring.cc
@@ -0,0 +1,545 @@
+// Protocol Buffers - Google's data interchange format
+// Copyright 2008 Google Inc.  All rights reserved.
+// https://developers.google.com/protocol-buffers/
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Author: kenton@google.com (Kenton Varda)
+//  Based on original Protocol Buffers design by
+//  Sanjay Ghemawat, Jeff Dean, and others.
+//
+// Contains methods defined in extension_set.h which cannot be part of the
+// lite library because they use descriptors or reflection.
+
+#include <google/protobuf/stubs/casts.h>
+#include <google/protobuf/descriptor.pb.h>
+#include <google/protobuf/parse_context.h>
+#include <google/protobuf/io/coded_stream.h>
+#include <google/protobuf/arena.h>
+#include <google/protobuf/descriptor.h>
+#include <google/protobuf/patch/extension_set_with_arenastring.h>
+#include <google/protobuf/patch/extension_set_inl_with_arenastring.h>
+#include <google/protobuf/message.h>
+#include <google/protobuf/message_lite.h>
+//#include <google/protobuf/repeated_field.h>
+#include <google/protobuf/unknown_field_set.h>
+#include <google/protobuf/wire_format.h>
+#include <google/protobuf/wire_format_lite.h>
+
+
+#include <google/protobuf/port_def.inc>
+
+namespace google {
+namespace protobuf {
+namespace internal {
+
+// A FieldSkipper used to store unknown MessageSet fields into UnknownFieldSet.
+class MessageSetFieldSkipperWithArenaString : public UnknownFieldSetFieldSkipper {
+ public:
+  explicit MessageSetFieldSkipperWithArenaString(UnknownFieldSet* unknown_fields)
+      : UnknownFieldSetFieldSkipper(unknown_fields) {}
+  ~MessageSetFieldSkipperWithArenaString() override {}
+ 
+  virtual bool SkipMessageSetField(io::CodedInputStream* input,
+                                   int field_number);
+};
+bool MessageSetFieldSkipperWithArenaString::SkipMessageSetField(io::CodedInputStream* input,
+                                                 int field_number) {
+  uint32_t length;
+  if (!input->ReadVarint32(&length)) return false;
+  if (unknown_fields_ == nullptr) {
+    return input->Skip(length);
+  } else {
+    return input->ReadString(unknown_fields_->AddLengthDelimited(field_number),
+                             length);
+  }
+}
+
+// Implementation of ExtensionFinder which finds extensions in a given
+// DescriptorPool, using the given MessageFactory to construct sub-objects.
+// This class is implemented in extension_set_heavy.cc.
+class DescriptorPoolExtensionFinderWithArenaString : public ExtensionFinder {
+ public:
+  DescriptorPoolExtensionFinderWithArenaString(const DescriptorPool* pool,
+                                MessageFactory* factory,
+                                const Descriptor* containing_type)
+      : pool_(pool), factory_(factory), containing_type_(containing_type) {}
+  ~DescriptorPoolExtensionFinderWithArenaString() override {}
+
+  bool Find(int number, ExtensionInfo* output) override;
+
+ private:
+  const DescriptorPool* pool_;
+  MessageFactory* factory_;
+  const Descriptor* containing_type_;
+};
+
+void ExtensionSetWithArenaString::AppendToList(
+    const Descriptor* containing_type, const DescriptorPool* pool,
+    std::vector<const FieldDescriptor*>* output) const {
+  ForEach([containing_type, pool, &output](int number, const Extension& ext) {
+    bool has = false;
+    if (ext.is_repeated) {
+      has = ext.GetSize() > 0;
+    } else {
+      has = !ext.is_cleared;
+    }
+
+    if (has) {
+      // TODO(kenton): Looking up each field by number is somewhat unfortunate.
+      //   Is there a better way?  The problem is that descriptors are lazily-
+      //   initialized, so they might not even be constructed until
+      //   AppendToList() is called.
+
+      if (ext.descriptor == nullptr) {
+        output->push_back(pool->FindExtensionByNumber(containing_type, number));
+      } else {
+        output->push_back(ext.descriptor);
+      }
+    }
+  });
+}
+
+inline FieldDescriptor::Type real_type(FieldType type) {
+  GOOGLE_DCHECK(type > 0 && type <= FieldDescriptor::MAX_TYPE);
+  return static_cast<FieldDescriptor::Type>(type);
+}
+
+inline FieldDescriptor::CppType cpp_type(FieldType type) {
+  return FieldDescriptor::TypeToCppType(
+      static_cast<FieldDescriptor::Type>(type));
+}
+
+inline WireFormatLite::FieldType field_type(FieldType type) {
+  GOOGLE_DCHECK(type > 0 && type <= WireFormatLite::MAX_FIELD_TYPE);
+  return static_cast<WireFormatLite::FieldType>(type);
+}
+
+#define GOOGLE_DCHECK_TYPE(EXTENSION, LABEL, CPPTYPE)                         \
+  GOOGLE_DCHECK_EQ((EXTENSION).is_repeated ? FieldDescriptor::LABEL_REPEATED  \
+                                    : FieldDescriptor::LABEL_OPTIONAL, \
+            FieldDescriptor::LABEL_##LABEL);                           \
+  GOOGLE_DCHECK_EQ(cpp_type((EXTENSION).type), FieldDescriptor::CPPTYPE_##CPPTYPE)
+
+const MessageLite& ExtensionSetWithArenaString::GetMessage(int number,
+                                            const Descriptor* message_type,
+                                            MessageFactory* factory) const {
+  const Extension* extension = FindOrNull(number);
+  if (extension == nullptr || extension->is_cleared) {
+    // Not present.  Return the default value.
+    return *factory->GetPrototype(message_type);
+  } else {
+    GOOGLE_DCHECK_TYPE(*extension, OPTIONAL, MESSAGE);
+    if (extension->is_lazy) {
+      return extension->lazymessage_value->GetMessage(
+          *factory->GetPrototype(message_type));
+    } else {
+      return *extension->message_value;
+    }
+  }
+}
+
+MessageLite* ExtensionSetWithArenaString::MutableMessage(const FieldDescriptor* descriptor,
+                                          MessageFactory* factory) {
+  Extension* extension;
+  if (MaybeNewExtension(descriptor->number(), descriptor, &extension)) {
+    extension->type = descriptor->type();
+    GOOGLE_DCHECK_EQ(cpp_type(extension->type), FieldDescriptor::CPPTYPE_MESSAGE);
+    extension->is_repeated = false;
+    extension->is_packed = false;
+    const MessageLite* prototype =
+        factory->GetPrototype(descriptor->message_type());
+    extension->is_lazy = false;
+    extension->message_value = prototype->New(arena_);
+    extension->is_cleared = false;
+    return extension->message_value;
+  } else {
+    GOOGLE_DCHECK_TYPE(*extension, OPTIONAL, MESSAGE);
+    extension->is_cleared = false;
+    if (extension->is_lazy) {
+      return extension->lazymessage_value->MutableMessage(
+          *factory->GetPrototype(descriptor->message_type()), arena_);
+    } else {
+      return extension->message_value;
+    }
+  }
+}
+
+MessageLite* ExtensionSetWithArenaString::ReleaseMessage(const FieldDescriptor* descriptor,
+                                          MessageFactory* factory) {
+  Extension* extension = FindOrNull(descriptor->number());
+  if (extension == nullptr) {
+    // Not present.  Return NULL.
+    return nullptr;
+  } else {
+    GOOGLE_DCHECK_TYPE(*extension, OPTIONAL, MESSAGE);
+    MessageLite* ret = nullptr;
+    if (extension->is_lazy) {
+      ret = extension->lazymessage_value->ReleaseMessage(
+          *factory->GetPrototype(descriptor->message_type()));
+      if (arena_ == nullptr) {
+        delete extension->lazymessage_value;
+      }
+    } else {
+      if (arena_ != nullptr) {
+        ret = extension->message_value->New();
+        ret->CheckTypeAndMergeFrom(*extension->message_value);
+      } else {
+        ret = extension->message_value;
+      }
+    }
+    Erase(descriptor->number());
+    return ret;
+  }
+}
+
+MessageLite* ExtensionSetWithArenaString::UnsafeArenaReleaseMessage(
+    const FieldDescriptor* descriptor, MessageFactory* factory) {
+  Extension* extension = FindOrNull(descriptor->number());
+  if (extension == nullptr) {
+    // Not present.  Return NULL.
+    return nullptr;
+  } else {
+    GOOGLE_DCHECK_TYPE(*extension, OPTIONAL, MESSAGE);
+    MessageLite* ret = nullptr;
+    if (extension->is_lazy) {
+      ret = extension->lazymessage_value->UnsafeArenaReleaseMessage(
+          *factory->GetPrototype(descriptor->message_type()));
+      if (arena_ == nullptr) {
+        delete extension->lazymessage_value;
+      }
+    } else {
+      ret = extension->message_value;
+    }
+    Erase(descriptor->number());
+    return ret;
+  }
+}
+
+ExtensionSetWithArenaString::Extension* ExtensionSetWithArenaString::MaybeNewRepeatedExtension(
+    const FieldDescriptor* descriptor) {
+  Extension* extension;
+  if (MaybeNewExtension(descriptor->number(), descriptor, &extension)) {
+    extension->type = descriptor->type();
+    GOOGLE_DCHECK_EQ(cpp_type(extension->type), FieldDescriptor::CPPTYPE_MESSAGE);
+    extension->is_repeated = true;
+    extension->repeated_message_value =
+        Arena::CreateMessage<RepeatedArenaPtrField<MessageLite> >(arena_);
+  } else {
+    GOOGLE_DCHECK_TYPE(*extension, REPEATED, MESSAGE);
+  }
+  return extension;
+}
+
+MessageLite* ExtensionSetWithArenaString::AddMessage(const FieldDescriptor* descriptor,
+                                      MessageFactory* factory) {
+  Extension* extension = MaybeNewRepeatedExtension(descriptor);
+
+  // RepeatedArenaPtrField<Message> does not know how to Add() since it cannot
+  // allocate an abstract object, so we have to be tricky.
+  MessageLite* result =
+      reinterpret_cast<internal::RepeatedArenaPtrFieldBase*>(
+          extension->repeated_message_value)
+          ->AddFromCleared<GenericTypeHandler<MessageLite> >();
+  if (result == nullptr) {
+    const MessageLite* prototype;
+    if (extension->repeated_message_value->empty()) {
+      prototype = factory->GetPrototype(descriptor->message_type());
+      GOOGLE_CHECK(prototype != nullptr);
+    } else {
+      prototype = &extension->repeated_message_value->Get(0);
+    }
+    result = prototype->New(arena_);
+    extension->repeated_message_value->AddAllocated(result);
+  }
+  return result;
+}
+
+void ExtensionSetWithArenaString::AddAllocatedMessage(const FieldDescriptor* descriptor,
+                                       MessageLite* new_entry) {
+  Extension* extension = MaybeNewRepeatedExtension(descriptor);
+
+  extension->repeated_message_value->AddAllocated(new_entry);
+}
+
+void ExtensionSetWithArenaString::UnsafeArenaAddAllocatedMessage(
+    const FieldDescriptor* descriptor, MessageLite* new_entry) {
+  Extension* extension = MaybeNewRepeatedExtension(descriptor);
+
+  extension->repeated_message_value->UnsafeArenaAddAllocated(new_entry);
+}
+
+static bool ValidateEnumUsingDescriptor(const void* arg, int number) {
+  return reinterpret_cast<const EnumDescriptor*>(arg)->FindValueByNumber(
+             number) != nullptr;
+}
+
+bool DescriptorPoolExtensionFinderWithArenaString::Find(int number, ExtensionInfo* output) {
+  const FieldDescriptor* extension =
+      pool_->FindExtensionByNumber(containing_type_, number);
+  if (extension == nullptr) {
+    return false;
+  } else {
+    output->type = extension->type();
+    output->is_repeated = extension->is_repeated();
+    output->is_packed = extension->options().packed();
+    output->descriptor = extension;
+    if (extension->cpp_type() == FieldDescriptor::CPPTYPE_MESSAGE) {
+      output->message_info.prototype =
+          factory_->GetPrototype(extension->message_type());
+      GOOGLE_CHECK(output->message_info.prototype != nullptr)
+          << "Extension factory's GetPrototype() returned NULL for extension: "
+          << extension->full_name();
+    } else if (extension->cpp_type() == FieldDescriptor::CPPTYPE_ENUM) {
+      output->enum_validity_check.func = ValidateEnumUsingDescriptor;
+      output->enum_validity_check.arg = extension->enum_type();
+    }
+
+    return true;
+  }
+}
+
+
+bool ExtensionSetWithArenaString::FindExtension(int wire_type, uint32_t field,
+                                 const Message* containing_type,
+                                 const internal::ParseContext* ctx,
+                                 ExtensionInfo* extension,
+                                 bool* was_packed_on_wire) {
+  if (ctx->data().pool == nullptr) {
+    GeneratedExtensionFinder finder(containing_type);
+    if (!FindExtensionInfoFromFieldNumber(wire_type, field, &finder, extension,
+                                          was_packed_on_wire)) {
+      return false;
+    }
+  } else {
+    DescriptorPoolExtensionFinderWithArenaString finder(ctx->data().pool, ctx->data().factory,
+                                         containing_type->GetDescriptor());
+    if (!FindExtensionInfoFromFieldNumber(wire_type, field, &finder, extension,
+                                          was_packed_on_wire)) {
+      return false;
+    }
+  }
+  return true;
+}
+
+const char* ExtensionSetWithArenaString::ParseField(uint64_t tag, const char* ptr,
+                                     const Message* containing_type,
+                                     internal::InternalMetadata* metadata,
+                                     internal::ParseContext* ctx) {
+  int number = tag >> 3;
+  bool was_packed_on_wire;
+  ExtensionInfo extension;
+  if (!FindExtension(tag & 7, number, containing_type, ctx, &extension,
+                     &was_packed_on_wire)) {
+    return UnknownFieldParse(
+        tag, metadata->mutable_unknown_fields<UnknownFieldSet>(), ptr, ctx);
+  }
+  return ParseFieldWithExtensionInfo<UnknownFieldSet>(
+      number, was_packed_on_wire, extension, metadata, ptr, ctx);
+}
+
+const char* ExtensionSetWithArenaString::ParseFieldMaybeLazily(
+    uint64_t tag, const char* ptr, const Message* containing_type,
+    internal::InternalMetadata* metadata, internal::ParseContext* ctx) {
+  return ParseField(tag, ptr, containing_type, metadata, ctx);
+}
+
+const char* ExtensionSetWithArenaString::ParseMessageSetItem(
+    const char* ptr, const Message* containing_type,
+    internal::InternalMetadata* metadata, internal::ParseContext* ctx) {
+  return ParseMessageSetItemTmpl<Message, UnknownFieldSet>(ptr, containing_type,
+                                                           metadata, ctx);
+}
+
+bool ExtensionSetWithArenaString::ParseField(uint32_t tag, io::CodedInputStream* input,
+                              const Message* containing_type,
+                              UnknownFieldSet* unknown_fields) {
+  UnknownFieldSetFieldSkipper skipper(unknown_fields);
+  if (input->GetExtensionPool() == nullptr) {
+    GeneratedExtensionFinder finder(containing_type);
+    return ParseField(tag, input, &finder, &skipper);
+  } else {
+    DescriptorPoolExtensionFinderWithArenaString finder(input->GetExtensionPool(),
+                                         input->GetExtensionFactory(),
+                                         containing_type->GetDescriptor());
+    return ParseField(tag, input, &finder, &skipper);
+  }
+}
+
+bool ExtensionSetWithArenaString::ParseMessageSet(io::CodedInputStream* input,
+                                   const Message* containing_type,
+                                   UnknownFieldSet* unknown_fields) {
+  MessageSetFieldSkipperWithArenaString skipper(unknown_fields);
+  if (input->GetExtensionPool() == nullptr) {
+    GeneratedExtensionFinder finder(containing_type);
+    return ParseMessageSet(input, &finder, &skipper);
+  } else {
+    DescriptorPoolExtensionFinderWithArenaString finder(input->GetExtensionPool(),
+                                         input->GetExtensionFactory(),
+                                         containing_type->GetDescriptor());
+    return ParseMessageSet(input, &finder, &skipper);
+  }
+}
+
+int ExtensionSetWithArenaString::SpaceUsedExcludingSelf() const {
+  return internal::FromIntSize(SpaceUsedExcludingSelfLong());
+}
+
+size_t ExtensionSetWithArenaString::SpaceUsedExcludingSelfLong() const {
+  size_t total_size = Size() * sizeof(KeyValue);
+  ForEach([&total_size](int /* number */, const Extension& ext) {
+    total_size += ext.SpaceUsedExcludingSelfLong();
+  });
+  return total_size;
+}
+
+inline size_t ExtensionSetWithArenaString::RepeatedMessage_SpaceUsedExcludingSelfLong(
+    RepeatedArenaPtrFieldBase* field) {
+  return field->SpaceUsedExcludingSelfLong<ArenaGenericTypeHandler<Message> >();
+}
+
+size_t ExtensionSetWithArenaString::Extension::SpaceUsedExcludingSelfLong() const {
+  size_t total_size = 0;
+  if (is_repeated) {
+    switch (cpp_type(type)) {
+#define HANDLE_TYPE(UPPERCASE, LOWERCASE)                                     \
+  case FieldDescriptor::CPPTYPE_##UPPERCASE:                                  \
+    total_size += sizeof(*repeated_##LOWERCASE##_value) +                     \
+                  repeated_##LOWERCASE##_value->SpaceUsedExcludingSelfLong(); \
+    break
+
+      HANDLE_TYPE(INT32, int32_t);
+      HANDLE_TYPE(INT64, int64_t);
+      HANDLE_TYPE(UINT32, uint32_t);
+      HANDLE_TYPE(UINT64, uint64_t);
+      HANDLE_TYPE(FLOAT, float);
+      HANDLE_TYPE(DOUBLE, double);
+      HANDLE_TYPE(BOOL, bool);
+      HANDLE_TYPE(ENUM, enum);
+      HANDLE_TYPE(STRING, string);
+#undef HANDLE_TYPE
+
+      case FieldDescriptor::CPPTYPE_MESSAGE:
+        // repeated_message_value is actually a RepeatedArenaPtrField<MessageLite>,
+        // but MessageLite has no SpaceUsedLong(), so we must directly call
+        // RepeatedArenaPtrFieldBase::SpaceUsedExcludingSelfLong() with a different
+        // type handler.
+        total_size += sizeof(*repeated_message_value) +
+                      RepeatedMessage_SpaceUsedExcludingSelfLong(
+                          reinterpret_cast<internal::RepeatedArenaPtrFieldBase*>(
+                              repeated_message_value));
+        break;
+    }
+  } else {
+    switch (cpp_type(type)) {
+      case FieldDescriptor::CPPTYPE_STRING:
+          total_size += sizeof(*string_value.Get()) +
+                       StringSpaceUsedExcludingSelfLong(*string_value.Get());
+          break;
+      case FieldDescriptor::CPPTYPE_MESSAGE:
+        if (is_lazy) {
+          total_size += lazymessage_value->SpaceUsedLong();
+        } else {
+          total_size += down_cast<Message*>(message_value)->SpaceUsedLong();
+        }
+        break;
+      default:
+        // No extra storage costs for primitive types.
+        break;
+    }
+  }
+  return total_size;
+}
+
+uint8_t* ExtensionSetWithArenaString::SerializeMessageSetWithCachedSizesToArray(
+    const MessageLite* extendee, uint8_t* target) const {
+  io::EpsCopyOutputStream stream(
+      target, MessageSetByteSize(),
+      io::CodedOutputStream::IsDefaultSerializationDeterministic());
+  return InternalSerializeMessageSetWithCachedSizesToArray(extendee, target,
+                                                           &stream);
+}
+
+bool ExtensionSetWithArenaString::ParseFieldMaybeLazily(
+    int wire_type, int field_number, io::CodedInputStream* input,
+    ExtensionFinder* extension_finder, MessageSetFieldSkipperWithArenaString* field_skipper) {
+  return ParseField(
+      WireFormatLite::MakeTag(field_number,
+                              static_cast<WireFormatLite::WireType>(wire_type)),
+      input, extension_finder, field_skipper);
+}
+
+bool ExtensionSetWithArenaString::ParseMessageSet(io::CodedInputStream* input,
+                                   ExtensionFinder* extension_finder,
+                                   MessageSetFieldSkipperWithArenaString* field_skipper) {
+  while (true) {
+    const uint32_t tag = input->ReadTag();
+    switch (tag) {
+      case 0:
+        return true;
+      case WireFormatLite::kMessageSetItemStartTag:
+        if (!ParseMessageSetItem(input, extension_finder, field_skipper)) {
+          return false;
+        }
+        break;
+      default:
+        if (!ParseField(tag, input, extension_finder, field_skipper)) {
+          return false;
+        }
+        break;
+    }
+  }
+}
+
+bool ExtensionSetWithArenaString::ParseMessageSetItem(io::CodedInputStream* input,
+                                       ExtensionFinder* extension_finder,
+                                       MessageSetFieldSkipperWithArenaString* field_skipper) {
+  struct MSFull {
+    bool ParseField(int type_id, io::CodedInputStream* input) {
+      return me->ParseFieldMaybeLazily(
+          WireFormatLite::WIRETYPE_LENGTH_DELIMITED, type_id, input,
+          extension_finder, field_skipper);
+    }
+
+    bool SkipField(uint32_t tag, io::CodedInputStream* input) {
+      return field_skipper->SkipField(input, tag);
+    }
+
+    ExtensionSetWithArenaString* me;
+    ExtensionFinder* extension_finder;
+    MessageSetFieldSkipperWithArenaString* field_skipper;
+  };
+
+  return ParseMessageSetItemImpl(input,
+                                 MSFull{this, extension_finder, field_skipper});
+}
+
+}  // namespace internal
+}  // namespace protobuf
+}  // namespace google
+
+#include <google/protobuf/port_undef.inc>
diff --git a/src/google/protobuf/patch/extension_set_inl_with_arenastring.h b/src/google/protobuf/patch/extension_set_inl_with_arenastring.h
new file mode 100644
index 000000000..5e1b87a5f
--- /dev/null
+++ b/src/google/protobuf/patch/extension_set_inl_with_arenastring.h
@@ -0,0 +1,274 @@
+// Protocol Buffers - Google's data interchange format
+// Copyright 2008 Google Inc.  All rights reserved.
+// https://developers.google.com/protocol-buffers/
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef GOOGLE_PROTOBUF_PATCH_EXTENSION_SET_WITH_ARENASTRING_INL_H__
+#define GOOGLE_PROTOBUF_PATCH_EXTENSION_SET_WITH_ARENASTRING_INL_H__
+
+#include <google/protobuf/parse_context.h>
+#include <google/protobuf/patch/extension_set_with_arenastring.h>
+#include <google/protobuf/metadata_lite.h>
+
+namespace google {
+namespace protobuf {
+namespace internal {
+
+template <typename T>
+const char* google::protobuf::internal::ExtensionSetWithArenaString::ParseFieldWithExtensionInfo(
+    int number, bool was_packed_on_wire, const ExtensionInfo& extension,
+    InternalMetadata* metadata, const char* ptr, internal::ParseContext* ctx) {
+  if (was_packed_on_wire) {
+    switch (extension.type) {
+#define HANDLE_TYPE_WITH_ARENASTRING(UPPERCASE, CPP_CAMELCASE)                                \
+  case WireFormatLite::TYPE_##UPPERCASE:                                     \
+    return internal::Packed##CPP_CAMELCASE##Parser(                          \
+        MutableRawRepeatedField(number, extension.type, extension.is_packed, \
+                                extension.descriptor),                       \
+        ptr, ctx);
+      HANDLE_TYPE_WITH_ARENASTRING(INT32, Int32);
+      HANDLE_TYPE_WITH_ARENASTRING(INT64, Int64);
+      HANDLE_TYPE_WITH_ARENASTRING(UINT32, UInt32);
+      HANDLE_TYPE_WITH_ARENASTRING(UINT64, UInt64);
+      HANDLE_TYPE_WITH_ARENASTRING(SINT32, SInt32);
+      HANDLE_TYPE_WITH_ARENASTRING(SINT64, SInt64);
+      HANDLE_TYPE_WITH_ARENASTRING(FIXED32, Fixed32);
+      HANDLE_TYPE_WITH_ARENASTRING(FIXED64, Fixed64);
+      HANDLE_TYPE_WITH_ARENASTRING(SFIXED32, SFixed32);
+      HANDLE_TYPE_WITH_ARENASTRING(SFIXED64, SFixed64);
+      HANDLE_TYPE_WITH_ARENASTRING(FLOAT, Float);
+      HANDLE_TYPE_WITH_ARENASTRING(DOUBLE, Double);
+      HANDLE_TYPE_WITH_ARENASTRING(BOOL, Bool);
+#undef HANDLE_TYPE_WITH_ARENASTRING
+
+      case WireFormatLite::TYPE_ENUM:
+        return internal::PackedEnumParserArg<T>(
+            MutableRawRepeatedField(number, extension.type, extension.is_packed,
+                                    extension.descriptor),
+            ptr, ctx, extension.enum_validity_check.func,
+            extension.enum_validity_check.arg, metadata, number);
+      case WireFormatLite::TYPE_STRING:
+      case WireFormatLite::TYPE_BYTES:
+      case WireFormatLite::TYPE_GROUP:
+      case WireFormatLite::TYPE_MESSAGE:
+        GOOGLE_LOG(FATAL) << "Non-primitive types can't be packed.";
+        break;
+    }
+  } else {
+    switch (extension.type) {
+#define HANDLE_VARINT_TYPE_WITH_ARENA_STRING(UPPERCASE, CPP_CAMELCASE)                        \
+  case WireFormatLite::TYPE_##UPPERCASE: {                                  \
+    uint64_t value;                                                         \
+    ptr = VarintParse(ptr, &value);                                         \
+    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);                                    \
+    if (extension.is_repeated) {                                            \
+      Add##CPP_CAMELCASE(number, WireFormatLite::TYPE_##UPPERCASE,          \
+                         extension.is_packed, value, extension.descriptor); \
+    } else {                                                                \
+      Set##CPP_CAMELCASE(number, WireFormatLite::TYPE_##UPPERCASE, value,   \
+                         extension.descriptor);                             \
+    }                                                                       \
+  } break
+
+      HANDLE_VARINT_TYPE_WITH_ARENA_STRING(INT32, Int32);
+      HANDLE_VARINT_TYPE_WITH_ARENA_STRING(INT64, Int64);
+      HANDLE_VARINT_TYPE_WITH_ARENA_STRING(UINT32, UInt32);
+      HANDLE_VARINT_TYPE_WITH_ARENA_STRING(UINT64, UInt64);
+      HANDLE_VARINT_TYPE_WITH_ARENA_STRING(BOOL, Bool);
+#undef HANDLE_VARINT_TYPE_WITH_ARENA_STRING
+#define HANDLE_SVARINT_TYPE_WITH_ARENA_STRING(UPPERCASE, CPP_CAMELCASE, SIZE)                 \
+  case WireFormatLite::TYPE_##UPPERCASE: {                                  \
+    uint64_t val;                                                           \
+    ptr = VarintParse(ptr, &val);                                           \
+    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);                                    \
+    auto value = WireFormatLite::ZigZagDecode##SIZE(val);                   \
+    if (extension.is_repeated) {                                            \
+      Add##CPP_CAMELCASE(number, WireFormatLite::TYPE_##UPPERCASE,          \
+                         extension.is_packed, value, extension.descriptor); \
+    } else {                                                                \
+      Set##CPP_CAMELCASE(number, WireFormatLite::TYPE_##UPPERCASE, value,   \
+                         extension.descriptor);                             \
+    }                                                                       \
+  } break
+
+      HANDLE_SVARINT_TYPE_WITH_ARENA_STRING(SINT32, Int32, 32);
+      HANDLE_SVARINT_TYPE_WITH_ARENA_STRING(SINT64, Int64, 64);
+#undef HANDLE_SVARINT_TYPE_WITH_ARENA_STRING
+#define HANDLE_FIXED_TYPE_WITH_ARENASTRING(UPPERCASE, CPP_CAMELCASE, CPPTYPE)                \
+  case WireFormatLite::TYPE_##UPPERCASE: {                                  \
+    auto value = UnalignedLoad<CPPTYPE>(ptr);                               \
+    ptr += sizeof(CPPTYPE);                                                 \
+    if (extension.is_repeated) {                                            \
+      Add##CPP_CAMELCASE(number, WireFormatLite::TYPE_##UPPERCASE,          \
+                         extension.is_packed, value, extension.descriptor); \
+    } else {                                                                \
+      Set##CPP_CAMELCASE(number, WireFormatLite::TYPE_##UPPERCASE, value,   \
+                         extension.descriptor);                             \
+    }                                                                       \
+  } break
+
+      HANDLE_FIXED_TYPE_WITH_ARENASTRING(FIXED32, UInt32, uint32_t);
+      HANDLE_FIXED_TYPE_WITH_ARENASTRING(FIXED64, UInt64, uint64_t);
+      HANDLE_FIXED_TYPE_WITH_ARENASTRING(SFIXED32, Int32, int32_t);
+      HANDLE_FIXED_TYPE_WITH_ARENASTRING(SFIXED64, Int64, int64_t);
+      HANDLE_FIXED_TYPE_WITH_ARENASTRING(FLOAT, Float, float);
+      HANDLE_FIXED_TYPE_WITH_ARENASTRING(DOUBLE, Double, double);
+#undef HANDLE_FIXED_TYPE_WITH_ARENASTRING
+
+      case WireFormatLite::TYPE_ENUM: {
+        uint64_t val;
+        ptr = VarintParse(ptr, &val);
+        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
+        int value = val;
+
+        if (!extension.enum_validity_check.func(
+                extension.enum_validity_check.arg, value)) {
+          WriteVarint(number, val, metadata->mutable_unknown_fields<T>());
+        } else if (extension.is_repeated) {
+          AddEnum(number, WireFormatLite::TYPE_ENUM, extension.is_packed, value,
+                  extension.descriptor);
+        } else {
+          SetEnum(number, WireFormatLite::TYPE_ENUM, value,
+                  extension.descriptor);
+        }
+        break;
+      }
+
+      case WireFormatLite::TYPE_BYTES:
+      case WireFormatLite::TYPE_STRING: {
+       auto accessor = 
+            extension.is_repeated
+                ? AddAccessor(number, WireFormatLite::TYPE_STRING,
+                              extension.descriptor)
+                : MutableAccessor(number, WireFormatLite::TYPE_STRING,
+                                  extension.descriptor);
+        return ctx->ReadArenaString(ptr, accessor);
+      }
+
+      case WireFormatLite::TYPE_GROUP: {
+        MessageLite* value =
+            extension.is_repeated
+                ? AddMessage(number, WireFormatLite::TYPE_GROUP,
+                             *extension.message_info.prototype,
+                             extension.descriptor)
+                : MutableMessage(number, WireFormatLite::TYPE_GROUP,
+                                 *extension.message_info.prototype,
+                                 extension.descriptor);
+        uint32_t tag = (number << 3) + WireFormatLite::WIRETYPE_START_GROUP;
+        return ctx->ParseGroup(value, ptr, tag);
+      }
+
+      case WireFormatLite::TYPE_MESSAGE: {
+        MessageLite* value =
+            extension.is_repeated
+                ? AddMessage(number, WireFormatLite::TYPE_MESSAGE,
+                             *extension.message_info.prototype,
+                             extension.descriptor)
+                : MutableMessage(number, WireFormatLite::TYPE_MESSAGE,
+                                 *extension.message_info.prototype,
+                                 extension.descriptor);
+        return ctx->ParseMessage(value, ptr);
+      }
+    }
+  }
+  return ptr;
+}
+
+template <typename Msg, typename T>
+const char* ExtensionSetWithArenaString::ParseMessageSetItemTmpl(
+    const char* ptr, const Msg* extendee, internal::InternalMetadata* metadata,
+    internal::ParseContext* ctx) {
+  std::string payload;
+  uint32_t type_id = 0;
+  bool payload_read = false;
+  while (!ctx->Done(&ptr)) {
+    uint32_t tag = static_cast<uint8_t>(*ptr++);
+    if (tag == WireFormatLite::kMessageSetTypeIdTag) {
+      uint64_t tmp;
+      ptr = ParseBigVarint(ptr, &tmp);
+      GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
+      type_id = tmp;
+      if (payload_read) {
+        ExtensionInfo extension;
+        bool was_packed_on_wire;
+        if (!FindExtension(2, type_id, extendee, ctx, &extension,
+                           &was_packed_on_wire)) {
+          WriteLengthDelimited(type_id, payload,
+                               metadata->mutable_unknown_fields<T>());
+        } else {
+          MessageLite* value =
+              extension.is_repeated
+                  ? AddMessage(type_id, WireFormatLite::TYPE_MESSAGE,
+                               *extension.message_info.prototype,
+                               extension.descriptor)
+                  : MutableMessage(type_id, WireFormatLite::TYPE_MESSAGE,
+                                   *extension.message_info.prototype,
+                                   extension.descriptor);
+
+          const char* p;
+          // We can't use regular parse from string as we have to track
+          // proper recursion depth and descriptor pools.
+          ParseContext tmp_ctx(ctx->depth(), false, &p, payload);
+          tmp_ctx.data().pool = ctx->data().pool;
+          tmp_ctx.data().factory = ctx->data().factory;
+          GOOGLE_PROTOBUF_PARSER_ASSERT(value->_InternalParse(p, &tmp_ctx) &&
+                                         tmp_ctx.EndedAtLimit());
+        }
+        type_id = 0;
+      }
+    } else if (tag == WireFormatLite::kMessageSetMessageTag) {
+      if (type_id != 0) {
+        ptr = ParseFieldMaybeLazily(static_cast<uint64_t>(type_id) * 8 + 2, ptr,
+                                    extendee, metadata, ctx);
+        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
+        type_id = 0;
+      } else {
+        int32_t size = ReadSize(&ptr);
+        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
+        ptr = ctx->ReadString(ptr, size, &payload);
+        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
+        payload_read = true;
+      }
+    } else {
+      ptr = ReadTag(ptr - 1, &tag);
+      if (tag == 0 || (tag & 7) == 4) {
+        ctx->SetLastTag(tag);
+        return ptr;
+      }
+      ptr = ParseField(tag, ptr, extendee, metadata, ctx);
+      GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
+    }
+  }
+  return ptr;
+}
+
+}  // namespace internal
+}  // namespace protobuf
+}  // namespace google
+
+#endif  // GOOGLE_PROTOBUF_PATCH_EXTENSION_SET_WITH_ARENASTRING_INL_H__
diff --git a/src/google/protobuf/patch/extension_set_with_arenastring.cc b/src/google/protobuf/patch/extension_set_with_arenastring.cc
new file mode 100644
index 000000000..65ea0a99f
--- /dev/null
+++ b/src/google/protobuf/patch/extension_set_with_arenastring.cc
@@ -0,0 +1,2308 @@
+// Protocol Buffers - Google's data interchange format
+// Copyright 2008 Google Inc.  All rights reserved.
+// https://developers.google.com/protocol-buffers/
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Author: kenton@google.com (Kenton Varda)
+//  Based on original Protocol Buffers design by
+//  Sanjay Ghemawat, Jeff Dean, and others.
+
+#include <google/protobuf/patch/extension_set_with_arenastring.h>
+
+#include <tuple>
+#include <unordered_set>
+#include <utility>
+
+#include <google/protobuf/stubs/common.h>
+#include <google/protobuf/patch/extension_set_inl_with_arenastring.h>
+#include <google/protobuf/parse_context.h>
+#include <google/protobuf/io/coded_stream.h>
+#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
+#include <google/protobuf/arena.h>
+#include <google/protobuf/message_lite.h>
+#include <google/protobuf/metadata_lite.h>
+//#include <google/protobuf/repeated_field.h>
+#include <google/protobuf/stubs/map_util.h>
+#include <google/protobuf/stubs/hash.h>
+
+// clang-format off
+#include <google/protobuf/port_def.inc>  // must be last.
+// clang-format on
+namespace google {
+namespace protobuf {
+namespace internal {
+
+namespace {
+
+inline WireFormatLite::FieldType real_type(FieldType type) {
+  GOOGLE_DCHECK(type > 0 && type <= WireFormatLite::MAX_FIELD_TYPE);
+  return static_cast<WireFormatLite::FieldType>(type);
+}
+
+inline WireFormatLite::CppType cpp_type(FieldType type) {
+  return WireFormatLite::FieldTypeToCppType(real_type(type));
+}
+
+inline bool is_packable(WireFormatLite::WireType type) {
+  switch (type) {
+    case WireFormatLite::WIRETYPE_VARINT:
+    case WireFormatLite::WIRETYPE_FIXED64:
+    case WireFormatLite::WIRETYPE_FIXED32:
+      return true;
+    case WireFormatLite::WIRETYPE_LENGTH_DELIMITED:
+    case WireFormatLite::WIRETYPE_START_GROUP:
+    case WireFormatLite::WIRETYPE_END_GROUP:
+      return false;
+
+      // Do not add a default statement. Let the compiler complain when someone
+      // adds a new wire type.
+  }
+  GOOGLE_LOG(FATAL) << "can't reach here.";
+  return false;
+}
+
+// Registry stuff.
+
+// Note that we cannot use hetererogeneous lookup for std containers since we
+// need to support C++11.
+struct ExtensionEq {
+  bool operator()(const ExtensionInfo& lhs, const ExtensionInfo& rhs) const {
+    return lhs.message == rhs.message && lhs.number == rhs.number;
+  }
+};
+
+struct ExtensionHasher {
+  std::size_t operator()(const ExtensionInfo& info) const {
+    return std::hash<const MessageLite*>{}(info.message) ^
+           std::hash<int>{}(info.number);
+  }
+};
+
+using ExtensionRegistry =
+    std::unordered_set<ExtensionInfo, ExtensionHasher, ExtensionEq>;
+
+static const ExtensionRegistry* global_registry = nullptr;
+
+// This function is only called at startup, so there is no need for thread-
+// safety.
+void Register(const ExtensionInfo& info) {
+  static auto local_static_registry = OnShutdownDelete(new ExtensionRegistry);
+  global_registry = local_static_registry;
+  if (!InsertIfNotPresent(local_static_registry, info)) {
+    GOOGLE_LOG(FATAL) << "Multiple extension registrations for type \""
+               << info.message->GetTypeName() << "\", field number "
+               << info.number << ".";
+  }
+}
+#if 0
+const ExtensionInfo* FindRegisteredExtension(const MessageLite* extendee,
+                                             int number) {
+  if (!global_registry) return nullptr;
+
+  ExtensionInfo info;
+  info.message = extendee;
+  info.number = number;
+
+  auto it = global_registry->find(info);
+  if (it == global_registry->end()) {
+    return nullptr;
+  } else {
+    return &*it;
+  }
+}
+#endif
+}  // namespace
+
+void ExtensionSetWithArenaString::RegisterExtension(const MessageLite* extendee, int number,
+                                     FieldType type, bool is_repeated,
+                                     bool is_packed) {
+  GOOGLE_CHECK_NE(type, WireFormatLite::TYPE_ENUM);
+  GOOGLE_CHECK_NE(type, WireFormatLite::TYPE_MESSAGE);
+  GOOGLE_CHECK_NE(type, WireFormatLite::TYPE_GROUP);
+  ExtensionInfo info(extendee, number, type, is_repeated, is_packed);
+  Register(info);
+}
+
+static bool CallNoArgValidityFunc(const void* arg, int number) {
+  // Note:  Must use C-style cast here rather than reinterpret_cast because
+  //   the C++ standard at one point did not allow casts between function and
+  //   data pointers and some compilers enforce this for C++-style casts.  No
+  //   compiler enforces it for C-style casts since lots of C-style code has
+  //   relied on these kinds of casts for a long time, despite being
+  //   technically undefined.  See:
+  //     http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#195
+  // Also note:  Some compilers do not allow function pointers to be "const".
+  //   Which makes sense, I suppose, because it's meaningless.
+  return ((EnumValidityFunc*)arg)(number);
+}
+
+void ExtensionSetWithArenaString::RegisterEnumExtension(const MessageLite* extendee,
+                                         int number, FieldType type,
+                                         bool is_repeated, bool is_packed,
+                                         EnumValidityFunc* is_valid) {
+  GOOGLE_CHECK_EQ(type, WireFormatLite::TYPE_ENUM);
+  ExtensionInfo info(extendee, number, type, is_repeated, is_packed);
+  info.enum_validity_check.func = CallNoArgValidityFunc;
+  // See comment in CallNoArgValidityFunc() about why we use a c-style cast.
+  info.enum_validity_check.arg = (void*)is_valid;
+  Register(info);
+}
+
+void ExtensionSetWithArenaString::RegisterMessageExtension(const MessageLite* extendee,
+                                            int number, FieldType type,
+                                            bool is_repeated, bool is_packed,
+                                            const MessageLite* prototype) {
+  GOOGLE_CHECK(type == WireFormatLite::TYPE_MESSAGE ||
+        type == WireFormatLite::TYPE_GROUP);
+  ExtensionInfo info(extendee, number, type, is_repeated, is_packed);
+  info.message_info = {prototype};
+  Register(info);
+}
+
+// ===================================================================
+// Constructors and basic methods.
+
+ExtensionSetWithArenaString::ExtensionSetWithArenaString(Arena* arena)
+    : arena_(arena),
+      flat_capacity_(0),
+      flat_size_(0),
+      map_{flat_capacity_ == 0
+               ? NULL
+               : Arena::CreateArray<KeyValue>(arena_, flat_capacity_)} {}
+
+ExtensionSetWithArenaString::~ExtensionSetWithArenaString() {
+  // Deletes all allocated extensions.
+  if (arena_ == NULL) {
+    ForEach([](int /* number */, Extension& ext) { ext.Free(); });
+    if (PROTOBUF_PREDICT_FALSE(is_large())) {
+      delete map_.large;
+    } else {
+      DeleteFlatMap(map_.flat, flat_capacity_);
+    }
+  }
+}
+
+void ExtensionSetWithArenaString::DeleteFlatMap(const ExtensionSetWithArenaString::KeyValue* flat,
+                                 uint16_t flat_capacity) {
+#ifdef __cpp_sized_deallocation
+  // Arena::CreateArray already requires a trivially destructible type, but
+  // ensure this constraint is not violated in the future.
+  static_assert(std::is_trivially_destructible<KeyValue>::value,
+                "CreateArray requires a trivially destructible type");
+  // A const-cast is needed, but this is safe as we are about to deallocate the
+  // array.
+  ::operator delete[](const_cast<ExtensionSetWithArenaString::KeyValue*>(flat),
+                      sizeof(*flat) * flat_capacity);
+#else   // !__cpp_sized_deallocation
+  delete[] flat;
+#endif  // !__cpp_sized_deallocation
+}
+
+// Defined in extension_set_heavy.cc.
+// void ExtensionSetWithArenaString::AppendToList(const Descriptor* extendee,
+//                                 const DescriptorPool* pool,
+//                                 vector<const FieldDescriptor*>* output) const
+
+bool ExtensionSetWithArenaString::Has(int number) const {
+  const Extension* ext = FindOrNull(number);
+  if (ext == NULL) return false;
+  GOOGLE_DCHECK(!ext->is_repeated);
+  return !ext->is_cleared;
+}
+
+int ExtensionSetWithArenaString::NumExtensions() const {
+  int result = 0;
+  ForEach([&result](int /* number */, const Extension& ext) {
+    if (!ext.is_cleared) {
+      ++result;
+    }
+  });
+  return result;
+}
+
+int ExtensionSetWithArenaString::ExtensionSize(int number) const {
+  const Extension* ext = FindOrNull(number);
+  return ext == NULL ? 0 : ext->GetSize();
+}
+
+FieldType ExtensionSetWithArenaString::ExtensionType(int number) const {
+  const Extension* ext = FindOrNull(number);
+  if (ext == NULL) {
+    GOOGLE_LOG(DFATAL) << "Don't lookup extension types if they aren't present (1). ";
+    return 0;
+  }
+  if (ext->is_cleared) {
+    GOOGLE_LOG(DFATAL) << "Don't lookup extension types if they aren't present (2). ";
+  }
+  return ext->type;
+}
+
+void ExtensionSetWithArenaString::ClearExtension(int number) {
+  Extension* ext = FindOrNull(number);
+  if (ext == NULL) return;
+  ext->Clear();
+}
+
+// ===================================================================
+// Field accessors
+
+namespace {
+
+enum { REPEATED_FIELD, OPTIONAL_FIELD };
+
+}  // namespace
+
+#define GOOGLE_DCHECK_TYPE(EXTENSION, LABEL, CPPTYPE)                                 \
+  GOOGLE_DCHECK_EQ((EXTENSION).is_repeated ? REPEATED_FIELD : OPTIONAL_FIELD, LABEL); \
+  GOOGLE_DCHECK_EQ(cpp_type((EXTENSION).type), WireFormatLite::CPPTYPE_##CPPTYPE)
+
+// -------------------------------------------------------------------
+// Primitives
+
+#define PRIMITIVE_ACCESSORS(UPPERCASE, LOWERCASE, CAMELCASE)                  \
+                                                                              \
+  LOWERCASE ExtensionSetWithArenaString::Get##CAMELCASE(int number, LOWERCASE default_value) \
+      const {                                                                 \
+    const Extension* extension = FindOrNull(number);                          \
+    if (extension == NULL || extension->is_cleared) {                         \
+      return default_value;                                                   \
+    } else {                                                                  \
+      GOOGLE_DCHECK_TYPE(*extension, OPTIONAL_FIELD, UPPERCASE);                     \
+      return extension->LOWERCASE##_value;                                    \
+    }                                                                         \
+  }                                                                           \
+                                                                              \
+  const LOWERCASE& ExtensionSetWithArenaString::GetRef##CAMELCASE(                           \
+      int number, const LOWERCASE& default_value) const {                     \
+    const Extension* extension = FindOrNull(number);                          \
+    if (extension == NULL || extension->is_cleared) {                         \
+      return default_value;                                                   \
+    } else {                                                                  \
+      GOOGLE_DCHECK_TYPE(*extension, OPTIONAL_FIELD, UPPERCASE);                     \
+      return extension->LOWERCASE##_value;                                    \
+    }                                                                         \
+  }                                                                           \
+                                                                              \
+  void ExtensionSetWithArenaString::Set##CAMELCASE(int number, FieldType type,               \
+                                    LOWERCASE value,                          \
+                                    const FieldDescriptor* descriptor) {      \
+    Extension* extension;                                                     \
+    if (MaybeNewExtension(number, descriptor, &extension)) {                  \
+      extension->type = type;                                                 \
+      GOOGLE_DCHECK_EQ(cpp_type(extension->type),                                    \
+                WireFormatLite::CPPTYPE_##UPPERCASE);                         \
+      extension->is_repeated = false;                                         \
+    } else {                                                                  \
+      GOOGLE_DCHECK_TYPE(*extension, OPTIONAL_FIELD, UPPERCASE);                     \
+    }                                                                         \
+    extension->is_cleared = false;                                            \
+    extension->LOWERCASE##_value = value;                                     \
+  }                                                                           \
+                                                                              \
+  LOWERCASE ExtensionSetWithArenaString::GetRepeated##CAMELCASE(int number, int index)       \
+      const {                                                                 \
+    const Extension* extension = FindOrNull(number);                          \
+    GOOGLE_CHECK(extension != NULL) << "Index out-of-bounds (field is empty).";      \
+    GOOGLE_DCHECK_TYPE(*extension, REPEATED_FIELD, UPPERCASE);                       \
+    return extension->repeated_##LOWERCASE##_value->Get(index);               \
+  }                                                                           \
+                                                                              \
+  const LOWERCASE& ExtensionSetWithArenaString::GetRefRepeated##CAMELCASE(int number,        \
+                                                           int index) const { \
+    const Extension* extension = FindOrNull(number);                          \
+    GOOGLE_CHECK(extension != NULL) << "Index out-of-bounds (field is empty).";      \
+    GOOGLE_DCHECK_TYPE(*extension, REPEATED_FIELD, UPPERCASE);                       \
+    return extension->repeated_##LOWERCASE##_value->Get(index);               \
+  }                                                                           \
+                                                                              \
+  void ExtensionSetWithArenaString::SetRepeated##CAMELCASE(int number, int index,            \
+                                            LOWERCASE value) {                \
+    Extension* extension = FindOrNull(number);                                \
+    GOOGLE_CHECK(extension != NULL) << "Index out-of-bounds (field is empty).";      \
+    GOOGLE_DCHECK_TYPE(*extension, REPEATED_FIELD, UPPERCASE);                       \
+    extension->repeated_##LOWERCASE##_value->Set(index, value);               \
+  }                                                                           \
+                                                                              \
+  void ExtensionSetWithArenaString::Add##CAMELCASE(int number, FieldType type, bool packed,  \
+                                    LOWERCASE value,                          \
+                                    const FieldDescriptor* descriptor) {      \
+    Extension* extension;                                                     \
+    if (MaybeNewExtension(number, descriptor, &extension)) {                  \
+      extension->type = type;                                                 \
+      GOOGLE_DCHECK_EQ(cpp_type(extension->type),                                    \
+                WireFormatLite::CPPTYPE_##UPPERCASE);                         \
+      extension->is_repeated = true;                                          \
+      extension->is_packed = packed;                                          \
+      extension->repeated_##LOWERCASE##_value =                               \
+          Arena::CreateMessage<RepeatedField<LOWERCASE>>(arena_);             \
+    } else {                                                                  \
+      GOOGLE_DCHECK_TYPE(*extension, REPEATED_FIELD, UPPERCASE);                     \
+      GOOGLE_DCHECK_EQ(extension->is_packed, packed);                                \
+    }                                                                         \
+    extension->repeated_##LOWERCASE##_value->Add(value);                      \
+  }
+
+PRIMITIVE_ACCESSORS(INT32, int32_t, Int32)
+PRIMITIVE_ACCESSORS(INT64, int64_t, Int64)
+PRIMITIVE_ACCESSORS(UINT32, uint32_t, UInt32)
+PRIMITIVE_ACCESSORS(UINT64, uint64_t, UInt64)
+PRIMITIVE_ACCESSORS(FLOAT, float, Float)
+PRIMITIVE_ACCESSORS(DOUBLE, double, Double)
+PRIMITIVE_ACCESSORS(BOOL, bool, Bool)
+
+#undef PRIMITIVE_ACCESSORS
+
+const void* ExtensionSetWithArenaString::GetRawRepeatedField(int number,
+                                              const void* default_value) const {
+  const Extension* extension = FindOrNull(number);
+  if (extension == NULL) {
+    return default_value;
+  }
+  // We assume that all the RepeatedField<>* pointers have the same
+  // size and alignment within the anonymous union in Extension.
+  return extension->repeated_int32_t_value;
+}
+
+void* ExtensionSetWithArenaString::MutableRawRepeatedField(int number, FieldType field_type,
+                                            bool packed,
+                                            const FieldDescriptor* desc) {
+  Extension* extension;
+
+  // We instantiate an empty Repeated{,Ptr}Field if one doesn't exist for this
+  // extension.
+  if (MaybeNewExtension(number, desc, &extension)) {
+    extension->is_repeated = true;
+    extension->type = field_type;
+    extension->is_packed = packed;
+
+    switch (WireFormatLite::FieldTypeToCppType(
+        static_cast<WireFormatLite::FieldType>(field_type))) {
+      case WireFormatLite::CPPTYPE_INT32:
+        extension->repeated_int32_t_value =
+            Arena::CreateMessage<RepeatedField<int32_t>>(arena_);
+        break;
+      case WireFormatLite::CPPTYPE_INT64:
+        extension->repeated_int64_t_value =
+            Arena::CreateMessage<RepeatedField<int64_t>>(arena_);
+        break;
+      case WireFormatLite::CPPTYPE_UINT32:
+        extension->repeated_uint32_t_value =
+            Arena::CreateMessage<RepeatedField<uint32_t>>(arena_);
+        break;
+      case WireFormatLite::CPPTYPE_UINT64:
+        extension->repeated_uint64_t_value =
+            Arena::CreateMessage<RepeatedField<uint64_t>>(arena_);
+        break;
+      case WireFormatLite::CPPTYPE_DOUBLE:
+        extension->repeated_double_value =
+            Arena::CreateMessage<RepeatedField<double>>(arena_);
+        break;
+      case WireFormatLite::CPPTYPE_FLOAT:
+        extension->repeated_float_value =
+            Arena::CreateMessage<RepeatedField<float>>(arena_);
+        break;
+      case WireFormatLite::CPPTYPE_BOOL:
+        extension->repeated_bool_value =
+            Arena::CreateMessage<RepeatedField<bool>>(arena_);
+        break;
+      case WireFormatLite::CPPTYPE_ENUM:
+        extension->repeated_enum_value =
+            Arena::CreateMessage<RepeatedField<int>>(arena_);
+        break;
+      case WireFormatLite::CPPTYPE_STRING:
+        extension->repeated_string_value =
+            Arena::CreateMessage<RepeatedArenaPtrField<std::string>>(arena_);
+        break;
+      case WireFormatLite::CPPTYPE_MESSAGE:
+        extension->repeated_message_value =
+            Arena::CreateMessage<RepeatedArenaPtrField<MessageLite>>(arena_);
+        break;
+    }
+  }
+
+  // We assume that all the RepeatedField<>* pointers have the same
+  // size and alignment within the anonymous union in Extension.
+  return extension->repeated_int32_t_value;
+}
+
+// Compatible version using old call signature. Does not create extensions when
+// the don't already exist; instead, just GOOGLE_CHECK-fails.
+void* ExtensionSetWithArenaString::MutableRawRepeatedField(int number) {
+  Extension* extension = FindOrNull(number);
+  GOOGLE_CHECK(extension != NULL) << "Extension not found.";
+  // We assume that all the RepeatedField<>* pointers have the same
+  // size and alignment within the anonymous union in Extension.
+  return extension->repeated_int32_t_value;
+}
+
+// -------------------------------------------------------------------
+// Enums
+
+int ExtensionSetWithArenaString::GetEnum(int number, int default_value) const {
+  const Extension* extension = FindOrNull(number);
+  if (extension == NULL || extension->is_cleared) {
+    // Not present.  Return the default value.
+    return default_value;
+  } else {
+    GOOGLE_DCHECK_TYPE(*extension, OPTIONAL_FIELD, ENUM);
+    return extension->enum_value;
+  }
+}
+
+const int& ExtensionSetWithArenaString::GetRefEnum(int number,
+                                    const int& default_value) const {
+  const Extension* extension = FindOrNull(number);
+  if (extension == nullptr || extension->is_cleared) {
+    // Not present.  Return the default value.
+    return default_value;
+  } else {
+    GOOGLE_DCHECK_TYPE(*extension, OPTIONAL_FIELD, ENUM);
+    return extension->enum_value;
+  }
+}
+
+void ExtensionSetWithArenaString::SetEnum(int number, FieldType type, int value,
+                           const FieldDescriptor* descriptor) {
+  Extension* extension;
+  if (MaybeNewExtension(number, descriptor, &extension)) {
+    extension->type = type;
+    GOOGLE_DCHECK_EQ(cpp_type(extension->type), WireFormatLite::CPPTYPE_ENUM);
+    extension->is_repeated = false;
+  } else {
+    GOOGLE_DCHECK_TYPE(*extension, OPTIONAL_FIELD, ENUM);
+  }
+  extension->is_cleared = false;
+  extension->enum_value = value;
+}
+
+int ExtensionSetWithArenaString::GetRepeatedEnum(int number, int index) const {
+  const Extension* extension = FindOrNull(number);
+  GOOGLE_CHECK(extension != nullptr) << "Index out-of-bounds (field is empty).";
+  GOOGLE_DCHECK_TYPE(*extension, REPEATED_FIELD, ENUM);
+  return extension->repeated_enum_value->Get(index);
+}
+
+const int& ExtensionSetWithArenaString::GetRefRepeatedEnum(int number, int index) const {
+  const Extension* extension = FindOrNull(number);
+  GOOGLE_CHECK(extension != nullptr) << "Index out-of-bounds (field is empty).";
+  GOOGLE_DCHECK_TYPE(*extension, REPEATED_FIELD, ENUM);
+  return extension->repeated_enum_value->Get(index);
+}
+
+void ExtensionSetWithArenaString::SetRepeatedEnum(int number, int index, int value) {
+  Extension* extension = FindOrNull(number);
+  GOOGLE_CHECK(extension != nullptr) << "Index out-of-bounds (field is empty).";
+  GOOGLE_DCHECK_TYPE(*extension, REPEATED_FIELD, ENUM);
+  extension->repeated_enum_value->Set(index, value);
+}
+
+void ExtensionSetWithArenaString::AddEnum(int number, FieldType type, bool packed, int value,
+                           const FieldDescriptor* descriptor) {
+  Extension* extension;
+  if (MaybeNewExtension(number, descriptor, &extension)) {
+    extension->type = type;
+    GOOGLE_DCHECK_EQ(cpp_type(extension->type), WireFormatLite::CPPTYPE_ENUM);
+    extension->is_repeated = true;
+    extension->is_packed = packed;
+    extension->repeated_enum_value =
+        Arena::CreateMessage<RepeatedField<int>>(arena_);
+  } else {
+    GOOGLE_DCHECK_TYPE(*extension, REPEATED_FIELD, ENUM);
+    GOOGLE_DCHECK_EQ(extension->is_packed, packed);
+  }
+  extension->repeated_enum_value->Add(value);
+}
+
+// -------------------------------------------------------------------
+// Strings
+
+const std::string& ExtensionSetWithArenaString::GetString(
+    int number, const std::string& default_value) const {
+  const Extension* extension = FindOrNull(number);
+  if (extension == NULL || extension->is_cleared) {
+    // Not present.  Return the default value.
+    return default_value;
+  } else {
+    GOOGLE_DCHECK_TYPE(*extension, OPTIONAL_FIELD, STRING);
+    return *extension->string_value.Get();
+  }
+}
+
+MutableStringType ExtensionSetWithArenaString::MutableString(int number, FieldType type,
+                                         const FieldDescriptor* descriptor) {
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  return MutableAccessor(number, type, descriptor);
+#else // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  Extension* extension;
+  if (MaybeNewExtension(number, descriptor, &extension)) {
+    extension->type = type;
+    GOOGLE_DCHECK_EQ(cpp_type(extension->type), WireFormatLite::CPPTYPE_STRING);
+    extension->is_repeated = false;
+    auto string = Arena::Create<std::string>(arena_);
+    if (arena_ != nullptr) {
+      extension->string_value.SetMutableArena(string);
+    } else {
+      extension->string_value.SetAllocated(string);
+    }
+    extension->is_cleared = false;
+    return string;
+  } else {
+    GOOGLE_DCHECK_TYPE(*extension, OPTIONAL_FIELD, STRING);
+    auto string = extension->string_value.Get();
+    if (extension->string_value.IsFixedSizeArena()) {
+      string = Arena::Create<std::string>(arena_, *string);
+      extension->string_value.SetMutableArena(string);
+    }
+    extension->is_cleared = false;
+    return string;
+  }
+#endif  // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+}
+
+MaybeArenaStringAccessor ExtensionSetWithArenaString::MutableAccessor(
+        int number, FieldType type, const FieldDescriptor* descriptor) {
+  Extension* extension;
+  if (MaybeNewExtension(number, descriptor, &extension)) {
+    extension->type = type;
+    GOOGLE_DCHECK_EQ(cpp_type(extension->type), WireFormatLite::CPPTYPE_STRING);
+    extension->is_repeated = false;
+    auto accessor = MaybeArenaStringAccessor::create(arena_);
+    if (arena_ != nullptr) {
+      extension->string_value.SetFixedSizeArena(accessor.underlying());
+    } else {
+      extension->string_value.SetAllocated(accessor.underlying());
+    }
+    extension->is_cleared = false;
+    return accessor;
+  } else {
+    GOOGLE_DCHECK_TYPE(*extension, OPTIONAL_FIELD, STRING);
+    extension->is_cleared = false;
+    return MaybeArenaStringAccessor(
+            extension->string_value.IsFixedSizeArena() ? arena_ : nullptr,
+            extension->string_value.Get());
+  }
+}
+
+const std::string& ExtensionSetWithArenaString::GetRepeatedString(int number,
+                                                   int index) const {
+  const Extension* extension = FindOrNull(number);
+  GOOGLE_CHECK(extension != NULL) << "Index out-of-bounds (field is empty).";
+  GOOGLE_DCHECK_TYPE(*extension, REPEATED_FIELD, STRING);
+  return extension->repeated_string_value->Get(index);
+}
+
+MutableStringType ExtensionSetWithArenaString::MutableRepeatedString(int number, int index) {
+  Extension* extension = FindOrNull(number);
+  GOOGLE_CHECK(extension != NULL) << "Index out-of-bounds (field is empty).";
+  GOOGLE_DCHECK_TYPE(*extension, REPEATED_FIELD, STRING);
+  return extension->repeated_string_value->Mutable(index);
+}
+
+MaybeArenaStringAccessor ExtensionSetWithArenaString::MutableRepeatedAccessor(int number, int index) {
+  Extension* extension = FindOrNull(number);
+  GOOGLE_CHECK(extension != nullptr) << "Index out-of-bounds (field is empty).";
+  GOOGLE_DCHECK_TYPE(*extension, REPEATED_FIELD, STRING);
+  return extension->repeated_string_value->MutableAccessor(index);
+}
+
+MutableStringType ExtensionSetWithArenaString::AddString(int number, FieldType type,
+                                     const FieldDescriptor* descriptor) {
+  Extension* extension;
+  if (MaybeNewExtension(number, descriptor, &extension)) {
+    extension->type = type;
+    GOOGLE_DCHECK_EQ(cpp_type(extension->type), WireFormatLite::CPPTYPE_STRING);
+    extension->is_repeated = true;
+    extension->is_packed = false;
+    extension->repeated_string_value =
+        Arena::CreateMessage<RepeatedArenaPtrField<std::string>>(arena_);
+  } else {
+    GOOGLE_DCHECK_TYPE(*extension, REPEATED_FIELD, STRING);
+  }
+  return extension->repeated_string_value->Add();
+}
+
+MaybeArenaStringAccessor ExtensionSetWithArenaString::AddAccessor(int number, FieldType type,
+                                                   const FieldDescriptor* descriptor) {
+  Extension* extension;
+  if (MaybeNewExtension(number, descriptor, &extension)) {
+    extension->type = type;
+    GOOGLE_DCHECK_EQ(cpp_type(extension->type), WireFormatLite::CPPTYPE_STRING);
+    extension->is_repeated = true;
+    extension->is_packed = false;
+    extension->repeated_string_value =
+        Arena::CreateMessage<RepeatedArenaPtrField<std::string>>(arena_);
+  } else {
+    GOOGLE_DCHECK_TYPE(*extension, REPEATED_FIELD, STRING);
+  }
+  return extension->repeated_string_value->AddAccessor();
+}
+
+// -------------------------------------------------------------------
+// Messages
+
+const MessageLite& ExtensionSetWithArenaString::GetMessage(
+    int number, const MessageLite& default_value) const {
+  const Extension* extension = FindOrNull(number);
+  if (extension == NULL) {
+    // Not present.  Return the default value.
+    return default_value;
+  } else {
+    GOOGLE_DCHECK_TYPE(*extension, OPTIONAL_FIELD, MESSAGE);
+    if (extension->is_lazy) {
+      return extension->lazymessage_value->GetMessage(default_value);
+    } else {
+      return *extension->message_value;
+    }
+  }
+}
+
+// Defined in extension_set_heavy.cc.
+// const MessageLite& ExtensionSetWithArenaString::GetMessage(int number,
+//                                             const Descriptor* message_type,
+//                                             MessageFactory* factory) const
+
+MessageLite* ExtensionSetWithArenaString::MutableMessage(int number, FieldType type,
+                                          const MessageLite& prototype,
+                                          const FieldDescriptor* descriptor) {
+  Extension* extension;
+  if (MaybeNewExtension(number, descriptor, &extension)) {
+    extension->type = type;
+    GOOGLE_DCHECK_EQ(cpp_type(extension->type), WireFormatLite::CPPTYPE_MESSAGE);
+    extension->is_repeated = false;
+    extension->is_lazy = false;
+    extension->message_value = prototype.New(arena_);
+    extension->is_cleared = false;
+    return extension->message_value;
+  } else {
+    GOOGLE_DCHECK_TYPE(*extension, OPTIONAL_FIELD, MESSAGE);
+    extension->is_cleared = false;
+    if (extension->is_lazy) {
+      return extension->lazymessage_value->MutableMessage(prototype, arena_);
+    } else {
+      return extension->message_value;
+    }
+  }
+}
+
+// Defined in extension_set_heavy.cc.
+// MessageLite* ExtensionSetWithArenaString::MutableMessage(int number, FieldType type,
+//                                           const Descriptor* message_type,
+//                                           MessageFactory* factory)
+
+void ExtensionSetWithArenaString::SetAllocatedMessage(int number, FieldType type,
+                                       const FieldDescriptor* descriptor,
+                                       MessageLite* message) {
+  if (message == NULL) {
+    ClearExtension(number);
+    return;
+  }
+  GOOGLE_DCHECK(message->GetOwningArena() == nullptr ||
+         message->GetOwningArena() == arena_);
+  Arena* message_arena = message->GetOwningArena();
+  Extension* extension;
+  if (MaybeNewExtension(number, descriptor, &extension)) {
+    extension->type = type;
+    GOOGLE_DCHECK_EQ(cpp_type(extension->type), WireFormatLite::CPPTYPE_MESSAGE);
+    extension->is_repeated = false;
+    extension->is_lazy = false;
+    if (message_arena == arena_) {
+      extension->message_value = message;
+    } else if (message_arena == NULL) {
+      extension->message_value = message;
+      arena_->Own(message);  // not NULL because not equal to message_arena
+    } else {
+      extension->message_value = message->New(arena_);
+      extension->message_value->CheckTypeAndMergeFrom(*message);
+    }
+  } else {
+    GOOGLE_DCHECK_TYPE(*extension, OPTIONAL_FIELD, MESSAGE);
+    if (extension->is_lazy) {
+      extension->lazymessage_value->SetAllocatedMessage(message);
+    } else {
+      if (arena_ == NULL) {
+        delete extension->message_value;
+      }
+      if (message_arena == arena_) {
+        extension->message_value = message;
+      } else if (message_arena == NULL) {
+        extension->message_value = message;
+        arena_->Own(message);  // not NULL because not equal to message_arena
+      } else {
+        extension->message_value = message->New(arena_);
+        extension->message_value->CheckTypeAndMergeFrom(*message);
+      }
+    }
+  }
+  extension->is_cleared = false;
+}
+
+void ExtensionSetWithArenaString::UnsafeArenaSetAllocatedMessage(
+    int number, FieldType type, const FieldDescriptor* descriptor,
+    MessageLite* message) {
+  if (message == NULL) {
+    ClearExtension(number);
+    return;
+  }
+  Extension* extension;
+  if (MaybeNewExtension(number, descriptor, &extension)) {
+    extension->type = type;
+    GOOGLE_DCHECK_EQ(cpp_type(extension->type), WireFormatLite::CPPTYPE_MESSAGE);
+    extension->is_repeated = false;
+    extension->is_lazy = false;
+    extension->message_value = message;
+  } else {
+    GOOGLE_DCHECK_TYPE(*extension, OPTIONAL_FIELD, MESSAGE);
+    if (extension->is_lazy) {
+      extension->lazymessage_value->UnsafeArenaSetAllocatedMessage(message);
+    } else {
+      if (arena_ == NULL) {
+        delete extension->message_value;
+      }
+      extension->message_value = message;
+    }
+  }
+  extension->is_cleared = false;
+}
+
+MessageLite* ExtensionSetWithArenaString::ReleaseMessage(int number,
+                                          const MessageLite& prototype) {
+  Extension* extension = FindOrNull(number);
+  if (extension == NULL) {
+    // Not present.  Return NULL.
+    return NULL;
+  } else {
+    GOOGLE_DCHECK_TYPE(*extension, OPTIONAL_FIELD, MESSAGE);
+    MessageLite* ret = NULL;
+    if (extension->is_lazy) {
+      ret = extension->lazymessage_value->ReleaseMessage(prototype);
+      if (arena_ == NULL) {
+        delete extension->lazymessage_value;
+      }
+    } else {
+      if (arena_ == NULL) {
+        ret = extension->message_value;
+      } else {
+        // ReleaseMessage() always returns a heap-allocated message, and we are
+        // on an arena, so we need to make a copy of this message to return.
+        ret = extension->message_value->New();
+        ret->CheckTypeAndMergeFrom(*extension->message_value);
+      }
+    }
+    Erase(number);
+    return ret;
+  }
+}
+
+MessageLite* ExtensionSetWithArenaString::UnsafeArenaReleaseMessage(
+    int number, const MessageLite& prototype) {
+  Extension* extension = FindOrNull(number);
+  if (extension == NULL) {
+    // Not present.  Return NULL.
+    return NULL;
+  } else {
+    GOOGLE_DCHECK_TYPE(*extension, OPTIONAL_FIELD, MESSAGE);
+    MessageLite* ret = NULL;
+    if (extension->is_lazy) {
+      ret = extension->lazymessage_value->UnsafeArenaReleaseMessage(prototype);
+      if (arena_ == NULL) {
+        delete extension->lazymessage_value;
+      }
+    } else {
+      ret = extension->message_value;
+    }
+    Erase(number);
+    return ret;
+  }
+}
+
+// Defined in extension_set_heavy.cc.
+// MessageLite* ExtensionSetWithArenaString::ReleaseMessage(const FieldDescriptor* descriptor,
+//                                           MessageFactory* factory);
+
+const MessageLite& ExtensionSetWithArenaString::GetRepeatedMessage(int number,
+                                                    int index) const {
+  const Extension* extension = FindOrNull(number);
+  GOOGLE_CHECK(extension != NULL) << "Index out-of-bounds (field is empty).";
+  GOOGLE_DCHECK_TYPE(*extension, REPEATED_FIELD, MESSAGE);
+  return extension->repeated_message_value->Get(index);
+}
+
+MessageLite* ExtensionSetWithArenaString::MutableRepeatedMessage(int number, int index) {
+  Extension* extension = FindOrNull(number);
+  GOOGLE_CHECK(extension != NULL) << "Index out-of-bounds (field is empty).";
+  GOOGLE_DCHECK_TYPE(*extension, REPEATED_FIELD, MESSAGE);
+  return extension->repeated_message_value->Mutable(index);
+}
+
+MessageLite* ExtensionSetWithArenaString::AddMessage(int number, FieldType type,
+                                      const MessageLite& prototype,
+                                      const FieldDescriptor* descriptor) {
+  Extension* extension;
+  if (MaybeNewExtension(number, descriptor, &extension)) {
+    extension->type = type;
+    GOOGLE_DCHECK_EQ(cpp_type(extension->type), WireFormatLite::CPPTYPE_MESSAGE);
+    extension->is_repeated = true;
+    extension->repeated_message_value =
+        Arena::CreateMessage<RepeatedArenaPtrField<MessageLite>>(arena_);
+  } else {
+    GOOGLE_DCHECK_TYPE(*extension, REPEATED_FIELD, MESSAGE);
+  }
+
+  // RepeatedArenaPtrField<MessageLite> does not know how to Add() since it cannot
+  // allocate an abstract object, so we have to be tricky.
+  MessageLite* result = reinterpret_cast<internal::RepeatedArenaPtrFieldBase*>(
+                            extension->repeated_message_value)
+                            ->AddFromCleared<ArenaGenericTypeHandler<MessageLite>>();
+  if (result == NULL) {
+    result = prototype.New(arena_);
+    extension->repeated_message_value->AddAllocated(result);
+  }
+  return result;
+}
+
+// Defined in extension_set_heavy.cc.
+// MessageLite* ExtensionSetWithArenaString::AddMessage(int number, FieldType type,
+//                                       const Descriptor* message_type,
+//                                       MessageFactory* factory)
+
+#undef GOOGLE_DCHECK_TYPE
+
+void ExtensionSetWithArenaString::RemoveLast(int number) {
+  Extension* extension = FindOrNull(number);
+  GOOGLE_CHECK(extension != NULL) << "Index out-of-bounds (field is empty).";
+  GOOGLE_DCHECK(extension->is_repeated);
+
+  switch (cpp_type(extension->type)) {
+    case WireFormatLite::CPPTYPE_INT32:
+      extension->repeated_int32_t_value->RemoveLast();
+      break;
+    case WireFormatLite::CPPTYPE_INT64:
+      extension->repeated_int64_t_value->RemoveLast();
+      break;
+    case WireFormatLite::CPPTYPE_UINT32:
+      extension->repeated_uint32_t_value->RemoveLast();
+      break;
+    case WireFormatLite::CPPTYPE_UINT64:
+      extension->repeated_uint64_t_value->RemoveLast();
+      break;
+    case WireFormatLite::CPPTYPE_FLOAT:
+      extension->repeated_float_value->RemoveLast();
+      break;
+    case WireFormatLite::CPPTYPE_DOUBLE:
+      extension->repeated_double_value->RemoveLast();
+      break;
+    case WireFormatLite::CPPTYPE_BOOL:
+      extension->repeated_bool_value->RemoveLast();
+      break;
+    case WireFormatLite::CPPTYPE_ENUM:
+      extension->repeated_enum_value->RemoveLast();
+      break;
+    case WireFormatLite::CPPTYPE_STRING:
+      extension->repeated_string_value->RemoveLast();
+      break;
+    case WireFormatLite::CPPTYPE_MESSAGE:
+      extension->repeated_message_value->RemoveLast();
+      break;
+  }
+}
+
+MessageLite* ExtensionSetWithArenaString::ReleaseLast(int number) {
+  Extension* extension = FindOrNull(number);
+  GOOGLE_CHECK(extension != NULL) << "Index out-of-bounds (field is empty).";
+  GOOGLE_DCHECK(extension->is_repeated);
+  GOOGLE_DCHECK(cpp_type(extension->type) == WireFormatLite::CPPTYPE_MESSAGE);
+  return extension->repeated_message_value->ReleaseLast();
+}
+
+MessageLite* ExtensionSetWithArenaString::UnsafeArenaReleaseLast(int number) {
+  Extension* extension = FindOrNull(number);
+  GOOGLE_CHECK(extension != nullptr) << "Index out-of-bounds (field is empty).";
+  GOOGLE_DCHECK(extension->is_repeated);
+  GOOGLE_DCHECK(cpp_type(extension->type) == WireFormatLite::CPPTYPE_MESSAGE);
+  return extension->repeated_message_value->UnsafeArenaReleaseLast();
+}
+
+void ExtensionSetWithArenaString::SwapElements(int number, int index1, int index2) {
+  Extension* extension = FindOrNull(number);
+  GOOGLE_CHECK(extension != NULL) << "Index out-of-bounds (field is empty).";
+  GOOGLE_DCHECK(extension->is_repeated);
+
+  switch (cpp_type(extension->type)) {
+    case WireFormatLite::CPPTYPE_INT32:
+      extension->repeated_int32_t_value->SwapElements(index1, index2);
+      break;
+    case WireFormatLite::CPPTYPE_INT64:
+      extension->repeated_int64_t_value->SwapElements(index1, index2);
+      break;
+    case WireFormatLite::CPPTYPE_UINT32:
+      extension->repeated_uint32_t_value->SwapElements(index1, index2);
+      break;
+    case WireFormatLite::CPPTYPE_UINT64:
+      extension->repeated_uint64_t_value->SwapElements(index1, index2);
+      break;
+    case WireFormatLite::CPPTYPE_FLOAT:
+      extension->repeated_float_value->SwapElements(index1, index2);
+      break;
+    case WireFormatLite::CPPTYPE_DOUBLE:
+      extension->repeated_double_value->SwapElements(index1, index2);
+      break;
+    case WireFormatLite::CPPTYPE_BOOL:
+      extension->repeated_bool_value->SwapElements(index1, index2);
+      break;
+    case WireFormatLite::CPPTYPE_ENUM:
+      extension->repeated_enum_value->SwapElements(index1, index2);
+      break;
+    case WireFormatLite::CPPTYPE_STRING:
+      extension->repeated_string_value->SwapElements(index1, index2);
+      break;
+    case WireFormatLite::CPPTYPE_MESSAGE:
+      extension->repeated_message_value->SwapElements(index1, index2);
+      break;
+  }
+}
+
+// ===================================================================
+
+void ExtensionSetWithArenaString::Clear() {
+  ForEach([](int /* number */, Extension& ext) { ext.Clear(); });
+}
+
+namespace {
+// Computes the size of a std::set_union without constructing the union.
+template <typename ItX, typename ItY>
+size_t SizeOfUnion(ItX it_xs, ItX end_xs, ItY it_ys, ItY end_ys) {
+  size_t result = 0;
+  while (it_xs != end_xs && it_ys != end_ys) {
+    ++result;
+    if (it_xs->first < it_ys->first) {
+      ++it_xs;
+    } else if (it_xs->first == it_ys->first) {
+      ++it_xs;
+      ++it_ys;
+    } else {
+      ++it_ys;
+    }
+  }
+  result += std::distance(it_xs, end_xs);
+  result += std::distance(it_ys, end_ys);
+  return result;
+}
+}  // namespace
+
+void ExtensionSetWithArenaString::MergeFrom(const ExtensionSetWithArenaString& other) {
+  if (PROTOBUF_PREDICT_TRUE(!is_large())) {
+    if (PROTOBUF_PREDICT_TRUE(!other.is_large())) {
+      GrowCapacity(SizeOfUnion(flat_begin(), flat_end(), other.flat_begin(),
+                               other.flat_end()));
+    } else {
+      GrowCapacity(SizeOfUnion(flat_begin(), flat_end(),
+                               other.map_.large->begin(),
+                               other.map_.large->end()));
+    }
+  }
+  other.ForEach([this](int number, const Extension& ext) {
+    this->InternalExtensionMergeFrom(number, ext);
+  });
+}
+
+void ExtensionSetWithArenaString::InternalExtensionMergeFrom(
+    int number, const Extension& other_extension) {
+  if (other_extension.is_repeated) {
+    Extension* extension;
+    bool is_new =
+        MaybeNewExtension(number, other_extension.descriptor, &extension);
+    if (is_new) {
+      // Extension did not already exist in set.
+      extension->type = other_extension.type;
+      extension->is_packed = other_extension.is_packed;
+      extension->is_repeated = true;
+    } else {
+      GOOGLE_DCHECK_EQ(extension->type, other_extension.type);
+      GOOGLE_DCHECK_EQ(extension->is_packed, other_extension.is_packed);
+      GOOGLE_DCHECK(extension->is_repeated);
+    }
+
+    switch (cpp_type(other_extension.type)) {
+#define HANDLE_TYPE(UPPERCASE, LOWERCASE, REPEATED_TYPE) \
+  case WireFormatLite::CPPTYPE_##UPPERCASE:              \
+    if (is_new) {                                        \
+      extension->repeated_##LOWERCASE##_value =          \
+          Arena::CreateMessage<REPEATED_TYPE>(arena_);   \
+    }                                                    \
+    extension->repeated_##LOWERCASE##_value->MergeFrom(  \
+        *other_extension.repeated_##LOWERCASE##_value);  \
+    break;
+
+      HANDLE_TYPE(INT32, int32_t, RepeatedField<int32_t>);
+      HANDLE_TYPE(INT64, int64_t, RepeatedField<int64_t>);
+      HANDLE_TYPE(UINT32, uint32_t, RepeatedField<uint32_t>);
+      HANDLE_TYPE(UINT64, uint64_t, RepeatedField<uint64_t>);
+      HANDLE_TYPE(FLOAT, float, RepeatedField<float>);
+      HANDLE_TYPE(DOUBLE, double, RepeatedField<double>);
+      HANDLE_TYPE(BOOL, bool, RepeatedField<bool>);
+      HANDLE_TYPE(ENUM, enum, RepeatedField<int>);
+      HANDLE_TYPE(STRING, string, RepeatedArenaPtrField<std::string>);
+#undef HANDLE_TYPE
+
+      case WireFormatLite::CPPTYPE_MESSAGE:
+        if (is_new) {
+          extension->repeated_message_value =
+              Arena::CreateMessage<RepeatedArenaPtrField<MessageLite>>(arena_);
+        }
+        // We can't call RepeatedArenaPtrField<MessageLite>::MergeFrom() because
+        // it would attempt to allocate new objects.
+        RepeatedArenaPtrField<MessageLite>* other_repeated_message =
+            other_extension.repeated_message_value;
+        for (int i = 0; i < other_repeated_message->size(); i++) {
+          const MessageLite& other_message = other_repeated_message->Get(i);
+          MessageLite* target =
+              reinterpret_cast<internal::RepeatedArenaPtrFieldBase*>(
+                  extension->repeated_message_value)
+                  ->AddFromCleared<GenericTypeHandler<MessageLite>>();
+          if (target == NULL) {
+            target = other_message.New(arena_);
+            extension->repeated_message_value->AddAllocated(target);
+          }
+          target->CheckTypeAndMergeFrom(other_message);
+        }
+        break;
+    }
+  } else {
+    if (!other_extension.is_cleared) {
+      switch (cpp_type(other_extension.type)) {
+#define HANDLE_TYPE(UPPERCASE, LOWERCASE, CAMELCASE)  \
+  case WireFormatLite::CPPTYPE_##UPPERCASE:           \
+    Set##CAMELCASE(number, other_extension.type,      \
+                   other_extension.LOWERCASE##_value, \
+                   other_extension.descriptor);       \
+    break;
+
+        HANDLE_TYPE(INT32, int32_t, Int32);
+        HANDLE_TYPE(INT64, int64_t, Int64);
+        HANDLE_TYPE(UINT32, uint32_t, UInt32);
+        HANDLE_TYPE(UINT64, uint64_t, UInt64);
+        HANDLE_TYPE(FLOAT, float, Float);
+        HANDLE_TYPE(DOUBLE, double, Double);
+        HANDLE_TYPE(BOOL, bool, Bool);
+        HANDLE_TYPE(ENUM, enum, Enum);
+#undef HANDLE_TYPE
+        case WireFormatLite::CPPTYPE_STRING:
+          SetString(number, other_extension.type, *other_extension.string_value.Get(),
+                    other_extension.descriptor);
+          break;
+        case WireFormatLite::CPPTYPE_MESSAGE: {
+          Extension* extension;
+          bool is_new =
+              MaybeNewExtension(number, other_extension.descriptor, &extension);
+          if (is_new) {
+            extension->type = other_extension.type;
+            extension->is_packed = other_extension.is_packed;
+            extension->is_repeated = false;
+            if (other_extension.is_lazy) {
+              extension->is_lazy = true;
+              extension->lazymessage_value =
+                  other_extension.lazymessage_value->New(arena_);
+              extension->lazymessage_value->MergeFrom(
+                  *other_extension.lazymessage_value, arena_);
+            } else {
+              extension->is_lazy = false;
+              extension->message_value =
+                  other_extension.message_value->New(arena_);
+              extension->message_value->CheckTypeAndMergeFrom(
+                  *other_extension.message_value);
+            }
+          } else {
+            GOOGLE_DCHECK_EQ(extension->type, other_extension.type);
+            GOOGLE_DCHECK_EQ(extension->is_packed, other_extension.is_packed);
+            GOOGLE_DCHECK(!extension->is_repeated);
+            if (other_extension.is_lazy) {
+              if (extension->is_lazy) {
+                extension->lazymessage_value->MergeFrom(
+                    *other_extension.lazymessage_value, arena_);
+              } else {
+                extension->message_value->CheckTypeAndMergeFrom(
+                    other_extension.lazymessage_value->GetMessage(
+                        *extension->message_value));
+              }
+            } else {
+              if (extension->is_lazy) {
+                extension->lazymessage_value
+                    ->MutableMessage(*other_extension.message_value, arena_)
+                    ->CheckTypeAndMergeFrom(*other_extension.message_value);
+              } else {
+                extension->message_value->CheckTypeAndMergeFrom(
+                    *other_extension.message_value);
+              }
+            }
+          }
+          extension->is_cleared = false;
+          break;
+        }
+      }
+    }
+  }
+}
+
+void ExtensionSetWithArenaString::Swap(ExtensionSetWithArenaString* x) {
+#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+  if (GetArena() != nullptr && GetArena() == x->GetArena()) {
+#else   // PROTOBUF_FORCE_COPY_IN_SWAP
+  if (GetArena() == x->GetArena()) {
+#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+    InternalSwap(x);
+  } else {
+    // TODO(cfallin, rohananil): We maybe able to optimize a case where we are
+    // swapping from heap to arena-allocated extension set, by just Own()'ing
+    // the extensions.
+    ExtensionSetWithArenaString extension_set;
+    extension_set.MergeFrom(*x);
+    x->Clear();
+    x->MergeFrom(*this);
+    Clear();
+    MergeFrom(extension_set);
+  }
+}
+
+void ExtensionSetWithArenaString::InternalSwap(ExtensionSetWithArenaString* other) {
+  using std::swap;
+  swap(arena_, other->arena_);
+  swap(flat_capacity_, other->flat_capacity_);
+  swap(flat_size_, other->flat_size_);
+  swap(map_, other->map_);
+}
+
+void ExtensionSetWithArenaString::SwapExtension(ExtensionSetWithArenaString* other, int number) {
+  if (this == other) return;
+
+  if (GetArena() == other->GetArena()) {
+    UnsafeShallowSwapExtension(other, number);
+    return;
+  }
+
+  Extension* this_ext = FindOrNull(number);
+  Extension* other_ext = other->FindOrNull(number);
+
+  if (this_ext == other_ext) return;
+
+  if (this_ext != nullptr && other_ext != nullptr) {
+    // TODO(cfallin, rohananil): We could further optimize these cases,
+    // especially avoid creation of ExtensionSetWithArenaString, and move MergeFrom logic
+    // into Extensions itself (which takes arena as an argument).
+    // We do it this way to reuse the copy-across-arenas logic already
+    // implemented in ExtensionSetWithArenaString's MergeFrom.
+    ExtensionSetWithArenaString temp;
+    temp.InternalExtensionMergeFrom(number, *other_ext);
+    Extension* temp_ext = temp.FindOrNull(number);
+    other_ext->Clear();
+    other->InternalExtensionMergeFrom(number, *this_ext);
+    this_ext->Clear();
+    InternalExtensionMergeFrom(number, *temp_ext);
+  } else if (this_ext == nullptr) {
+    InternalExtensionMergeFrom(number, *other_ext);
+    if (other->GetArena() == nullptr) other_ext->Free();
+    other->Erase(number);
+  } else {
+    other->InternalExtensionMergeFrom(number, *this_ext);
+    if (GetArena() == nullptr) this_ext->Free();
+    Erase(number);
+  }
+}
+
+void ExtensionSetWithArenaString::UnsafeShallowSwapExtension(ExtensionSetWithArenaString* other, int number) {
+  if (this == other) return;
+
+  Extension* this_ext = FindOrNull(number);
+  Extension* other_ext = other->FindOrNull(number);
+
+  if (this_ext == other_ext) return;
+
+  GOOGLE_DCHECK_EQ(GetArena(), other->GetArena());
+
+  if (this_ext != nullptr && other_ext != nullptr) {
+    std::swap(*this_ext, *other_ext);
+  } else if (this_ext == nullptr) {
+    *Insert(number).first = *other_ext;
+    other->Erase(number);
+  } else {
+    *other->Insert(number).first = *this_ext;
+    Erase(number);
+  }
+}
+
+bool ExtensionSetWithArenaString::IsInitialized() const {
+  // Extensions are never required.  However, we need to check that all
+  // embedded messages are initialized.
+  if (PROTOBUF_PREDICT_FALSE(is_large())) {
+    for (const auto& kv : *map_.large) {
+      if (!kv.second.IsInitialized()) return false;
+    }
+    return true;
+  }
+  for (const KeyValue* it = flat_begin(); it != flat_end(); ++it) {
+    if (!it->second.IsInitialized()) return false;
+  }
+  return true;
+}
+
+bool ExtensionSetWithArenaString::FindExtensionInfoFromTag(uint32_t tag,
+                                            ExtensionFinder* extension_finder,
+                                            int* field_number,
+                                            ExtensionInfo* extension,
+                                            bool* was_packed_on_wire) {
+  *field_number = WireFormatLite::GetTagFieldNumber(tag);
+  WireFormatLite::WireType wire_type = WireFormatLite::GetTagWireType(tag);
+  return FindExtensionInfoFromFieldNumber(wire_type, *field_number,
+                                          extension_finder, extension,
+                                          was_packed_on_wire);
+}
+
+bool ExtensionSetWithArenaString::FindExtensionInfoFromFieldNumber(
+    int wire_type, int field_number, ExtensionFinder* extension_finder,
+    ExtensionInfo* extension, bool* was_packed_on_wire) const {
+  if (!extension_finder->Find(field_number, extension)) {
+    return false;
+  }
+
+  WireFormatLite::WireType expected_wire_type =
+      WireFormatLite::WireTypeForFieldType(real_type(extension->type));
+
+  // Check if this is a packed field.
+  *was_packed_on_wire = false;
+  if (extension->is_repeated &&
+      wire_type == WireFormatLite::WIRETYPE_LENGTH_DELIMITED &&
+      is_packable(expected_wire_type)) {
+    *was_packed_on_wire = true;
+    return true;
+  }
+  // Otherwise the wire type must match.
+  return expected_wire_type == wire_type;
+}
+
+bool ExtensionSetWithArenaString::ParseField(uint32_t tag, io::CodedInputStream* input,
+                              ExtensionFinder* extension_finder,
+                              FieldSkipper* field_skipper) {
+  int number;
+  bool was_packed_on_wire;
+  ExtensionInfo extension;
+  if (!FindExtensionInfoFromTag(tag, extension_finder, &number, &extension,
+                                &was_packed_on_wire)) {
+    return field_skipper->SkipField(input, tag);
+  } else {
+    return ParseFieldWithExtensionInfo(number, was_packed_on_wire, extension,
+                                       input, field_skipper);
+  }
+}
+
+const char* ExtensionSetWithArenaString::ParseField(uint64_t tag, const char* ptr,
+                                     const MessageLite* extendee,
+                                     internal::InternalMetadata* metadata,
+                                     internal::ParseContext* ctx) {
+  GeneratedExtensionFinder finder(extendee);
+  int number = tag >> 3;
+  bool was_packed_on_wire;
+  ExtensionInfo extension;
+  if (!FindExtensionInfoFromFieldNumber(tag & 7, number, &finder, &extension,
+                                        &was_packed_on_wire)) {
+    return UnknownFieldParse(
+        tag, metadata->mutable_unknown_fields<std::string>(), ptr, ctx);
+  }
+  return ParseFieldWithExtensionInfo<std::string>(
+      number, was_packed_on_wire, extension, metadata, ptr, ctx);
+}
+
+const char* ExtensionSetWithArenaString::ParseMessageSetItem(
+    const char* ptr, const MessageLite* extendee,
+    internal::InternalMetadata* metadata, internal::ParseContext* ctx) {
+  return ParseMessageSetItemTmpl<MessageLite, std::string>(ptr, extendee,
+                                                           metadata, ctx);
+}
+
+bool ExtensionSetWithArenaString::ParseFieldWithExtensionInfo(int number,
+                                               bool was_packed_on_wire,
+                                               const ExtensionInfo& extension,
+                                               io::CodedInputStream* input,
+                                               FieldSkipper* field_skipper) {
+  // Explicitly not read extension.is_packed, instead check whether the field
+  // was encoded in packed form on the wire.
+  if (was_packed_on_wire) {
+    uint32_t size;
+    if (!input->ReadVarint32(&size)) return false;
+    io::CodedInputStream::Limit limit = input->PushLimit(size);
+
+    switch (extension.type) {
+#define HANDLE_TYPE(UPPERCASE, CPP_CAMELCASE, CPP_LOWERCASE)                \
+  case WireFormatLite::TYPE_##UPPERCASE:                                    \
+    while (input->BytesUntilLimit() > 0) {                                  \
+      CPP_LOWERCASE value;                                                  \
+      if (!WireFormatLite::ReadPrimitive<CPP_LOWERCASE,                     \
+                                         WireFormatLite::TYPE_##UPPERCASE>( \
+              input, &value))                                               \
+        return false;                                                       \
+      Add##CPP_CAMELCASE(number, WireFormatLite::TYPE_##UPPERCASE,          \
+                         extension.is_packed, value, extension.descriptor); \
+    }                                                                       \
+    break
+
+      HANDLE_TYPE(INT32, Int32, int32_t);
+      HANDLE_TYPE(INT64, Int64, int64_t);
+      HANDLE_TYPE(UINT32, UInt32, uint32_t);
+      HANDLE_TYPE(UINT64, UInt64, uint64_t);
+      HANDLE_TYPE(SINT32, Int32, int32_t);
+      HANDLE_TYPE(SINT64, Int64, int64_t);
+      HANDLE_TYPE(FIXED32, UInt32, uint32_t);
+      HANDLE_TYPE(FIXED64, UInt64, uint64_t);
+      HANDLE_TYPE(SFIXED32, Int32, int32_t);
+      HANDLE_TYPE(SFIXED64, Int64, int64_t);
+      HANDLE_TYPE(FLOAT, Float, float);
+      HANDLE_TYPE(DOUBLE, Double, double);
+      HANDLE_TYPE(BOOL, Bool, bool);
+#undef HANDLE_TYPE
+
+      case WireFormatLite::TYPE_ENUM:
+        while (input->BytesUntilLimit() > 0) {
+          int value;
+          if (!WireFormatLite::ReadPrimitive<int, WireFormatLite::TYPE_ENUM>(
+                  input, &value))
+            return false;
+          if (extension.enum_validity_check.func(
+                  extension.enum_validity_check.arg, value)) {
+            AddEnum(number, WireFormatLite::TYPE_ENUM, extension.is_packed,
+                    value, extension.descriptor);
+          } else {
+            // Invalid value.  Treat as unknown.
+            field_skipper->SkipUnknownEnum(number, value);
+          }
+        }
+        break;
+
+      case WireFormatLite::TYPE_STRING:
+      case WireFormatLite::TYPE_BYTES:
+      case WireFormatLite::TYPE_GROUP:
+      case WireFormatLite::TYPE_MESSAGE:
+        GOOGLE_LOG(FATAL) << "Non-primitive types can't be packed.";
+        break;
+    }
+
+    input->PopLimit(limit);
+  } else {
+    switch (extension.type) {
+#define HANDLE_TYPE(UPPERCASE, CPP_CAMELCASE, CPP_LOWERCASE)                \
+  case WireFormatLite::TYPE_##UPPERCASE: {                                  \
+    CPP_LOWERCASE value;                                                    \
+    if (!WireFormatLite::ReadPrimitive<CPP_LOWERCASE,                       \
+                                       WireFormatLite::TYPE_##UPPERCASE>(   \
+            input, &value))                                                 \
+      return false;                                                         \
+    if (extension.is_repeated) {                                            \
+      Add##CPP_CAMELCASE(number, WireFormatLite::TYPE_##UPPERCASE,          \
+                         extension.is_packed, value, extension.descriptor); \
+    } else {                                                                \
+      Set##CPP_CAMELCASE(number, WireFormatLite::TYPE_##UPPERCASE, value,   \
+                         extension.descriptor);                             \
+    }                                                                       \
+  } break
+
+      HANDLE_TYPE(INT32, Int32, int32_t);
+      HANDLE_TYPE(INT64, Int64, int64_t);
+      HANDLE_TYPE(UINT32, UInt32, uint32_t);
+      HANDLE_TYPE(UINT64, UInt64, uint64_t);
+      HANDLE_TYPE(SINT32, Int32, int32_t);
+      HANDLE_TYPE(SINT64, Int64, int64_t);
+      HANDLE_TYPE(FIXED32, UInt32, uint32_t);
+      HANDLE_TYPE(FIXED64, UInt64, uint64_t);
+      HANDLE_TYPE(SFIXED32, Int32, int32_t);
+      HANDLE_TYPE(SFIXED64, Int64, int64_t);
+      HANDLE_TYPE(FLOAT, Float, float);
+      HANDLE_TYPE(DOUBLE, Double, double);
+      HANDLE_TYPE(BOOL, Bool, bool);
+#undef HANDLE_TYPE
+
+      case WireFormatLite::TYPE_ENUM: {
+        int value;
+        if (!WireFormatLite::ReadPrimitive<int, WireFormatLite::TYPE_ENUM>(
+                input, &value))
+          return false;
+
+        if (!extension.enum_validity_check.func(
+                extension.enum_validity_check.arg, value)) {
+          // Invalid value.  Treat as unknown.
+          field_skipper->SkipUnknownEnum(number, value);
+        } else if (extension.is_repeated) {
+          AddEnum(number, WireFormatLite::TYPE_ENUM, extension.is_packed, value,
+                  extension.descriptor);
+        } else {
+          SetEnum(number, WireFormatLite::TYPE_ENUM, value,
+                  extension.descriptor);
+        }
+        break;
+      }
+
+      case WireFormatLite::TYPE_STRING: {
+#if 0
+        std::string* value =
+            extension.is_repeated
+                ? AddString(number, WireFormatLite::TYPE_STRING,
+                            extension.descriptor)
+                : MutableString(number, WireFormatLite::TYPE_STRING,
+                                extension.descriptor);
+        if (!WireFormatLite::ReadString(input, value)) return false;
+#endif
+        auto accessor = 
+            extension.is_repeated
+                ? AddAccessor(number, WireFormatLite::TYPE_STRING,
+                              extension.descriptor)
+                : MutableAccessor(number, WireFormatLite::TYPE_STRING,
+                                  extension.descriptor);
+        if (!WireFormatLite::ReadArenaString(input, accessor)) return false;
+        break;
+      }
+
+      case WireFormatLite::TYPE_BYTES: {
+#if 0
+        std::string* value =
+            extension.is_repeated
+                ? AddString(number, WireFormatLite::TYPE_BYTES,
+                            extension.descriptor)
+                : MutableString(number, WireFormatLite::TYPE_BYTES,
+                                extension.descriptor);
+        if (!WireFormatLite::ReadBytes(input, value)) return false;
+#endif
+        auto accessor = 
+            extension.is_repeated
+                ? AddAccessor(number, WireFormatLite::TYPE_BYTES,
+                              extension.descriptor)
+                : MutableAccessor(number, WireFormatLite::TYPE_BYTES,
+                                  extension.descriptor);
+        if (!WireFormatLite::ReadArenaString(input, accessor)) return false;
+        break;
+
+        break;
+      }
+
+      case WireFormatLite::TYPE_GROUP: {
+        MessageLite* value =
+            extension.is_repeated
+                ? AddMessage(number, WireFormatLite::TYPE_GROUP,
+                             *extension.message_info.prototype,
+                             extension.descriptor)
+                : MutableMessage(number, WireFormatLite::TYPE_GROUP,
+                                 *extension.message_info.prototype,
+                                 extension.descriptor);
+        if (!WireFormatLite::ReadGroup(number, input, value)) return false;
+        break;
+      }
+
+      case WireFormatLite::TYPE_MESSAGE: {
+        MessageLite* value =
+            extension.is_repeated
+                ? AddMessage(number, WireFormatLite::TYPE_MESSAGE,
+                             *extension.message_info.prototype,
+                             extension.descriptor)
+                : MutableMessage(number, WireFormatLite::TYPE_MESSAGE,
+                                 *extension.message_info.prototype,
+                                 extension.descriptor);
+        if (!WireFormatLite::ReadMessage(input, value)) return false;
+        break;
+      }
+    }
+  }
+
+  return true;
+}
+
+bool ExtensionSetWithArenaString::ParseField(uint32_t tag, io::CodedInputStream* input,
+                              const MessageLite* extendee) {
+  FieldSkipper skipper;
+  GeneratedExtensionFinder finder(extendee);
+  return ParseField(tag, input, &finder, &skipper);
+}
+
+bool ExtensionSetWithArenaString::ParseField(uint32_t tag, io::CodedInputStream* input,
+                              const MessageLite* extendee,
+                              io::CodedOutputStream* unknown_fields) {
+  CodedOutputStreamFieldSkipper skipper(unknown_fields);
+  GeneratedExtensionFinder finder(extendee);
+  return ParseField(tag, input, &finder, &skipper);
+}
+
+bool ExtensionSetWithArenaString::ParseMessageSetLite(io::CodedInputStream* input,
+                                       ExtensionFinder* extension_finder,
+                                       FieldSkipper* field_skipper) {
+  while (true) {
+    const uint32_t tag = input->ReadTag();
+    switch (tag) {
+      case 0:
+        return true;
+      case WireFormatLite::kMessageSetItemStartTag:
+        if (!ParseMessageSetItemLite(input, extension_finder, field_skipper)) {
+          return false;
+        }
+        break;
+      default:
+        if (!ParseField(tag, input, extension_finder, field_skipper)) {
+          return false;
+        }
+        break;
+    }
+  }
+}
+
+bool ExtensionSetWithArenaString::ParseMessageSetItemLite(io::CodedInputStream* input,
+                                           ExtensionFinder* extension_finder,
+                                           FieldSkipper* field_skipper) {
+  struct MSLite {
+    bool ParseField(int type_id, io::CodedInputStream* input) {
+      return me->ParseField(
+          WireFormatLite::WIRETYPE_LENGTH_DELIMITED + 8 * type_id, input,
+          extension_finder, field_skipper);
+    }
+
+    bool SkipField(uint32_t tag, io::CodedInputStream* input) {
+      return field_skipper->SkipField(input, tag);
+    }
+
+    ExtensionSetWithArenaString* me;
+    ExtensionFinder* extension_finder;
+    FieldSkipper* field_skipper;
+  };
+
+  return ParseMessageSetItemImpl(input,
+                                 MSLite{this, extension_finder, field_skipper});
+}
+
+bool ExtensionSetWithArenaString::ParseMessageSet(io::CodedInputStream* input,
+                                   const MessageLite* extendee,
+                                   std::string* unknown_fields) {
+  io::StringOutputStream zcis(unknown_fields);
+  io::CodedOutputStream output(&zcis);
+  CodedOutputStreamFieldSkipper skipper(&output);
+  GeneratedExtensionFinder finder(extendee);
+  return ParseMessageSetLite(input, &finder, &skipper);
+}
+
+uint8_t* ExtensionSetWithArenaString::_InternalSerializeImpl(
+    const MessageLite* extendee, int start_field_number, int end_field_number,
+    uint8_t* target, io::EpsCopyOutputStream* stream) const {
+  if (PROTOBUF_PREDICT_FALSE(is_large())) {
+    const auto& end = map_.large->end();
+    for (auto it = map_.large->lower_bound(start_field_number);
+         it != end && it->first < end_field_number; ++it) {
+      target = it->second.InternalSerializeFieldWithCachedSizesToArray(
+          extendee, this, it->first, target, stream);
+    }
+    return target;
+  }
+  const KeyValue* end = flat_end();
+  for (const KeyValue* it = std::lower_bound(
+           flat_begin(), end, start_field_number, KeyValue::FirstComparator());
+       it != end && it->first < end_field_number; ++it) {
+    target = it->second.InternalSerializeFieldWithCachedSizesToArray(
+        extendee, this, it->first, target, stream);
+  }
+  return target;
+}
+
+uint8_t* ExtensionSetWithArenaString::InternalSerializeMessageSetWithCachedSizesToArray(
+    const MessageLite* extendee, uint8_t* target,
+    io::EpsCopyOutputStream* stream) const {
+  const ExtensionSetWithArenaString* extension_set = this;
+  ForEach([&target, extendee, stream, extension_set](int number,
+                                                     const Extension& ext) {
+    target = ext.InternalSerializeMessageSetItemWithCachedSizesToArray(
+        extendee, extension_set, number, target, stream);
+  });
+  return target;
+}
+
+size_t ExtensionSetWithArenaString::ByteSize() const {
+  size_t total_size = 0;
+  ForEach([&total_size](int number, const Extension& ext) {
+    total_size += ext.ByteSize(number);
+  });
+  return total_size;
+}
+
+// Defined in extension_set_heavy.cc.
+// int ExtensionSetWithArenaString::SpaceUsedExcludingSelf() const
+
+bool ExtensionSetWithArenaString::MaybeNewExtension(int number,
+                                     const FieldDescriptor* descriptor,
+                                     Extension** result) {
+  bool extension_is_new = false;
+  std::tie(*result, extension_is_new) = Insert(number);
+  (*result)->descriptor = descriptor;
+  return extension_is_new;
+}
+
+// ===================================================================
+// Methods of ExtensionSetWithArenaString::Extension
+
+void ExtensionSetWithArenaString::Extension::Clear() {
+  if (is_repeated) {
+    switch (cpp_type(type)) {
+#define HANDLE_TYPE(UPPERCASE, LOWERCASE)   \
+  case WireFormatLite::CPPTYPE_##UPPERCASE: \
+    repeated_##LOWERCASE##_value->Clear();  \
+    break
+
+      HANDLE_TYPE(INT32, int32_t);
+      HANDLE_TYPE(INT64, int64_t);
+      HANDLE_TYPE(UINT32, uint32_t);
+      HANDLE_TYPE(UINT64, uint64_t);
+      HANDLE_TYPE(FLOAT, float);
+      HANDLE_TYPE(DOUBLE, double);
+      HANDLE_TYPE(BOOL, bool);
+      HANDLE_TYPE(ENUM, enum);
+      HANDLE_TYPE(STRING, string);
+      HANDLE_TYPE(MESSAGE, message);
+#undef HANDLE_TYPE
+    }
+  } else {
+    if (!is_cleared) {
+      switch (cpp_type(type)) {
+        case WireFormatLite::CPPTYPE_STRING:
+          //string_value->clear();
+          MaybeArenaStringAccessor::clear(string_value.Get());
+          break;
+        case WireFormatLite::CPPTYPE_MESSAGE:
+          if (is_lazy) {
+            lazymessage_value->Clear();
+          } else {
+            message_value->Clear();
+          }
+          break;
+        default:
+          // No need to do anything.  Get*() will return the default value
+          // as long as is_cleared is true and Set*() will overwrite the
+          // previous value.
+          break;
+      }
+
+      is_cleared = true;
+    }
+  }
+}
+
+size_t ExtensionSetWithArenaString::Extension::ByteSize(int number) const {
+  size_t result = 0;
+
+  if (is_repeated) {
+    if (is_packed) {
+      switch (real_type(type)) {
+#define HANDLE_TYPE(UPPERCASE, CAMELCASE, LOWERCASE)                 \
+  case WireFormatLite::TYPE_##UPPERCASE:                             \
+    for (int i = 0; i < repeated_##LOWERCASE##_value->size(); i++) { \
+      result += WireFormatLite::CAMELCASE##Size(                     \
+          repeated_##LOWERCASE##_value->Get(i));                     \
+    }                                                                \
+    break
+
+        HANDLE_TYPE(INT32, Int32, int32_t);
+        HANDLE_TYPE(INT64, Int64, int64_t);
+        HANDLE_TYPE(UINT32, UInt32, uint32_t);
+        HANDLE_TYPE(UINT64, UInt64, uint64_t);
+        HANDLE_TYPE(SINT32, SInt32, int32_t);
+        HANDLE_TYPE(SINT64, SInt64, int64_t);
+        HANDLE_TYPE(ENUM, Enum, enum);
+#undef HANDLE_TYPE
+
+        // Stuff with fixed size.
+#define HANDLE_TYPE(UPPERCASE, CAMELCASE, LOWERCASE)             \
+  case WireFormatLite::TYPE_##UPPERCASE:                         \
+    result += WireFormatLite::k##CAMELCASE##Size *               \
+              FromIntSize(repeated_##LOWERCASE##_value->size()); \
+    break
+        HANDLE_TYPE(FIXED32, Fixed32, uint32_t);
+        HANDLE_TYPE(FIXED64, Fixed64, uint64_t);
+        HANDLE_TYPE(SFIXED32, SFixed32, int32_t);
+        HANDLE_TYPE(SFIXED64, SFixed64, int64_t);
+        HANDLE_TYPE(FLOAT, Float, float);
+        HANDLE_TYPE(DOUBLE, Double, double);
+        HANDLE_TYPE(BOOL, Bool, bool);
+#undef HANDLE_TYPE
+
+        case WireFormatLite::TYPE_STRING:
+        case WireFormatLite::TYPE_BYTES:
+        case WireFormatLite::TYPE_GROUP:
+        case WireFormatLite::TYPE_MESSAGE:
+          GOOGLE_LOG(FATAL) << "Non-primitive types can't be packed.";
+          break;
+      }
+
+      cached_size = ToCachedSize(result);
+      if (result > 0) {
+        result += io::CodedOutputStream::VarintSize32(result);
+        result += io::CodedOutputStream::VarintSize32(WireFormatLite::MakeTag(
+            number, WireFormatLite::WIRETYPE_LENGTH_DELIMITED));
+      }
+    } else {
+      size_t tag_size = WireFormatLite::TagSize(number, real_type(type));
+
+      switch (real_type(type)) {
+#define HANDLE_TYPE(UPPERCASE, CAMELCASE, LOWERCASE)                        \
+  case WireFormatLite::TYPE_##UPPERCASE:                                    \
+    result += tag_size * FromIntSize(repeated_##LOWERCASE##_value->size()); \
+    for (int i = 0; i < repeated_##LOWERCASE##_value->size(); i++) {        \
+      result += WireFormatLite::CAMELCASE##Size(                            \
+          repeated_##LOWERCASE##_value->Get(i));                            \
+    }                                                                       \
+    break
+
+        HANDLE_TYPE(INT32, Int32, int32_t);
+        HANDLE_TYPE(INT64, Int64, int64_t);
+        HANDLE_TYPE(UINT32, UInt32, uint32_t);
+        HANDLE_TYPE(UINT64, UInt64, uint64_t);
+        HANDLE_TYPE(SINT32, SInt32, int32_t);
+        HANDLE_TYPE(SINT64, SInt64, int64_t);
+        HANDLE_TYPE(STRING, String, string);
+        HANDLE_TYPE(BYTES, Bytes, string);
+        HANDLE_TYPE(ENUM, Enum, enum);
+        HANDLE_TYPE(GROUP, Group, message);
+        HANDLE_TYPE(MESSAGE, Message, message);
+#undef HANDLE_TYPE
+
+        // Stuff with fixed size.
+#define HANDLE_TYPE(UPPERCASE, CAMELCASE, LOWERCASE)             \
+  case WireFormatLite::TYPE_##UPPERCASE:                         \
+    result += (tag_size + WireFormatLite::k##CAMELCASE##Size) *  \
+              FromIntSize(repeated_##LOWERCASE##_value->size()); \
+    break
+        HANDLE_TYPE(FIXED32, Fixed32, uint32_t);
+        HANDLE_TYPE(FIXED64, Fixed64, uint64_t);
+        HANDLE_TYPE(SFIXED32, SFixed32, int32_t);
+        HANDLE_TYPE(SFIXED64, SFixed64, int64_t);
+        HANDLE_TYPE(FLOAT, Float, float);
+        HANDLE_TYPE(DOUBLE, Double, double);
+        HANDLE_TYPE(BOOL, Bool, bool);
+#undef HANDLE_TYPE
+      }
+    }
+  } else if (!is_cleared) {
+    result += WireFormatLite::TagSize(number, real_type(type));
+    switch (real_type(type)) {
+#define HANDLE_TYPE(UPPERCASE, CAMELCASE, LOWERCASE)      \
+  case WireFormatLite::TYPE_##UPPERCASE:                  \
+    result += WireFormatLite::CAMELCASE##Size(LOWERCASE); \
+    break
+
+      HANDLE_TYPE(INT32, Int32, int32_t_value);
+      HANDLE_TYPE(INT64, Int64, int64_t_value);
+      HANDLE_TYPE(UINT32, UInt32, uint32_t_value);
+      HANDLE_TYPE(UINT64, UInt64, uint64_t_value);
+      HANDLE_TYPE(SINT32, SInt32, int32_t_value);
+      HANDLE_TYPE(SINT64, SInt64, int64_t_value);
+      HANDLE_TYPE(STRING, String, *string_value.Get());
+      HANDLE_TYPE(BYTES, Bytes, *string_value.Get());
+      HANDLE_TYPE(ENUM, Enum, enum_value);
+      HANDLE_TYPE(GROUP, Group, *message_value);
+#undef HANDLE_TYPE
+      case WireFormatLite::TYPE_MESSAGE: {
+        if (is_lazy) {
+          size_t size = lazymessage_value->ByteSizeLong();
+          result += io::CodedOutputStream::VarintSize32(size) + size;
+        } else {
+          result += WireFormatLite::MessageSize(*message_value);
+        }
+        break;
+      }
+
+      // Stuff with fixed size.
+#define HANDLE_TYPE(UPPERCASE, CAMELCASE)         \
+  case WireFormatLite::TYPE_##UPPERCASE:          \
+    result += WireFormatLite::k##CAMELCASE##Size; \
+    break
+        HANDLE_TYPE(FIXED32, Fixed32);
+        HANDLE_TYPE(FIXED64, Fixed64);
+        HANDLE_TYPE(SFIXED32, SFixed32);
+        HANDLE_TYPE(SFIXED64, SFixed64);
+        HANDLE_TYPE(FLOAT, Float);
+        HANDLE_TYPE(DOUBLE, Double);
+        HANDLE_TYPE(BOOL, Bool);
+#undef HANDLE_TYPE
+    }
+  }
+
+  return result;
+}
+
+int ExtensionSetWithArenaString::Extension::GetSize() const {
+  GOOGLE_DCHECK(is_repeated);
+  switch (cpp_type(type)) {
+#define HANDLE_TYPE(UPPERCASE, LOWERCASE)   \
+  case WireFormatLite::CPPTYPE_##UPPERCASE: \
+    return repeated_##LOWERCASE##_value->size()
+
+    HANDLE_TYPE(INT32, int32_t);
+    HANDLE_TYPE(INT64, int64_t);
+    HANDLE_TYPE(UINT32, uint32_t);
+    HANDLE_TYPE(UINT64, uint64_t);
+    HANDLE_TYPE(FLOAT, float);
+    HANDLE_TYPE(DOUBLE, double);
+    HANDLE_TYPE(BOOL, bool);
+    HANDLE_TYPE(ENUM, enum);
+    HANDLE_TYPE(STRING, string);
+    HANDLE_TYPE(MESSAGE, message);
+#undef HANDLE_TYPE
+  }
+
+  GOOGLE_LOG(FATAL) << "Can't get here.";
+  return 0;
+}
+
+// This function deletes all allocated objects. This function should be only
+// called if the Extension was created without an arena.
+void ExtensionSetWithArenaString::Extension::Free() {
+  if (is_repeated) {
+    switch (cpp_type(type)) {
+#define HANDLE_TYPE(UPPERCASE, LOWERCASE)   \
+  case WireFormatLite::CPPTYPE_##UPPERCASE: \
+    delete repeated_##LOWERCASE##_value;    \
+    break
+
+      HANDLE_TYPE(INT32, int32_t);
+      HANDLE_TYPE(INT64, int64_t);
+      HANDLE_TYPE(UINT32, uint32_t);
+      HANDLE_TYPE(UINT64, uint64_t);
+      HANDLE_TYPE(FLOAT, float);
+      HANDLE_TYPE(DOUBLE, double);
+      HANDLE_TYPE(BOOL, bool);
+      HANDLE_TYPE(ENUM, enum);
+      HANDLE_TYPE(STRING, string);
+      HANDLE_TYPE(MESSAGE, message);
+#undef HANDLE_TYPE
+    }
+  } else {
+    switch (cpp_type(type)) {
+      case WireFormatLite::CPPTYPE_STRING:
+        delete string_value.Get();
+        break;
+      case WireFormatLite::CPPTYPE_MESSAGE:
+        if (is_lazy) {
+          delete lazymessage_value;
+        } else {
+          delete message_value;
+        }
+        break;
+      default:
+        break;
+    }
+  }
+}
+
+// Defined in extension_set_heavy.cc.
+// int ExtensionSetWithArenaString::Extension::SpaceUsedExcludingSelf() const
+
+bool ExtensionSetWithArenaString::Extension::IsInitialized() const {
+  if (cpp_type(type) == WireFormatLite::CPPTYPE_MESSAGE) {
+    if (is_repeated) {
+      for (int i = 0; i < repeated_message_value->size(); i++) {
+        if (!repeated_message_value->Get(i).IsInitialized()) {
+          return false;
+        }
+      }
+    } else {
+      if (!is_cleared) {
+        if (is_lazy) {
+          if (!lazymessage_value->IsInitialized()) return false;
+        } else {
+          if (!message_value->IsInitialized()) return false;
+        }
+      }
+    }
+  }
+  return true;
+}
+
+// Dummy key method to avoid weak vtable.
+void ExtensionSetWithArenaString::LazyMessageExtension::UnusedKeyMethod() {}
+
+const ExtensionSetWithArenaString::Extension* ExtensionSetWithArenaString::FindOrNull(int key) const {
+  if (flat_size_ == 0) {
+    return nullptr;
+  } else if (PROTOBUF_PREDICT_TRUE(!is_large())) {
+    auto it = std::lower_bound(flat_begin(), flat_end() - 1, key,
+                               KeyValue::FirstComparator());
+    return it->first == key ? &it->second : nullptr;
+  } else {
+    return FindOrNullInLargeMap(key);
+  }
+}
+
+const ExtensionSetWithArenaString::Extension* ExtensionSetWithArenaString::FindOrNullInLargeMap(
+    int key) const {
+  assert(is_large());
+  LargeMap::const_iterator it = map_.large->find(key);
+  if (it != map_.large->end()) {
+    return &it->second;
+  }
+  return NULL;
+}
+
+ExtensionSetWithArenaString::Extension* ExtensionSetWithArenaString::FindOrNull(int key) {
+  const auto* const_this = this;
+  return const_cast<ExtensionSetWithArenaString::Extension*>(const_this->FindOrNull(key));
+}
+
+ExtensionSetWithArenaString::Extension* ExtensionSetWithArenaString::FindOrNullInLargeMap(int key) {
+  const auto* const_this = this;
+  return const_cast<ExtensionSetWithArenaString::Extension*>(
+      const_this->FindOrNullInLargeMap(key));
+}
+
+std::pair<ExtensionSetWithArenaString::Extension*, bool> ExtensionSetWithArenaString::Insert(int key) {
+  if (PROTOBUF_PREDICT_FALSE(is_large())) {
+    auto maybe = map_.large->insert({key, Extension()});
+    return {&maybe.first->second, maybe.second};
+  }
+  KeyValue* end = flat_end();
+  KeyValue* it =
+      std::lower_bound(flat_begin(), end, key, KeyValue::FirstComparator());
+  if (it != end && it->first == key) {
+    return {&it->second, false};
+  }
+  if (flat_size_ < flat_capacity_) {
+    std::copy_backward(it, end, end + 1);
+    ++flat_size_;
+    it->first = key;
+    it->second = Extension();
+    return {&it->second, true};
+  }
+  GrowCapacity(flat_size_ + 1);
+  return Insert(key);
+}
+
+void ExtensionSetWithArenaString::GrowCapacity(size_t minimum_new_capacity) {
+  if (PROTOBUF_PREDICT_FALSE(is_large())) {
+    return;  // LargeMap does not have a "reserve" method.
+  }
+  if (flat_capacity_ >= minimum_new_capacity) {
+    return;
+  }
+
+  auto new_flat_capacity = flat_capacity_;
+  do {
+    new_flat_capacity = new_flat_capacity == 0 ? 1 : new_flat_capacity * 4;
+  } while (new_flat_capacity < minimum_new_capacity);
+
+  const KeyValue* begin = flat_begin();
+  const KeyValue* end = flat_end();
+  AllocatedData new_map;
+  if (new_flat_capacity > kMaximumFlatCapacity) {
+    new_map.large = Arena::Create<LargeMap>(arena_);
+    LargeMap::iterator hint = new_map.large->begin();
+    for (const KeyValue* it = begin; it != end; ++it) {
+      hint = new_map.large->insert(hint, {it->first, it->second});
+    }
+    flat_size_ = static_cast<uint16_t>(-1);
+    GOOGLE_DCHECK(is_large());
+  } else {
+    new_map.flat = Arena::CreateArray<KeyValue>(arena_, new_flat_capacity);
+    std::copy(begin, end, new_map.flat);
+  }
+
+  if (arena_ == nullptr) {
+    DeleteFlatMap(begin, flat_capacity_);
+  }
+  flat_capacity_ = new_flat_capacity;
+  map_ = new_map;
+}
+
+// static
+constexpr uint16_t ExtensionSetWithArenaString::kMaximumFlatCapacity;
+
+void ExtensionSetWithArenaString::Erase(int key) {
+  if (PROTOBUF_PREDICT_FALSE(is_large())) {
+    map_.large->erase(key);
+    return;
+  }
+  KeyValue* end = flat_end();
+  KeyValue* it =
+      std::lower_bound(flat_begin(), end, key, KeyValue::FirstComparator());
+  if (it != end && it->first == key) {
+    std::copy(it + 1, end, it);
+    --flat_size_;
+  }
+}
+
+// ==================================================================
+// Default repeated field instances for iterator-compatible accessors
+#if 0
+const RepeatedPrimitiveDefaults* RepeatedPrimitiveDefaults::default_instance() {
+  static auto instance = OnShutdownDelete(new RepeatedPrimitiveDefaults);
+  return instance;
+}
+
+const RepeatedStringTypeTraits::RepeatedFieldType*
+RepeatedStringTypeTraits::GetDefaultRepeatedField() {
+  static auto instance = OnShutdownDelete(new RepeatedFieldType);
+  return instance;
+}
+#endif
+
+uint8_t* ExtensionSetWithArenaString::Extension::InternalSerializeFieldWithCachedSizesToArray(
+    const MessageLite* extendee, const ExtensionSetWithArenaString* extension_set, int number,
+    uint8_t* target, io::EpsCopyOutputStream* stream) const {
+  if (is_repeated) {
+    if (is_packed) {
+      if (cached_size == 0) return target;
+
+      target = stream->EnsureSpace(target);
+      target = WireFormatLite::WriteTagToArray(
+          number, WireFormatLite::WIRETYPE_LENGTH_DELIMITED, target);
+      target = WireFormatLite::WriteInt32NoTagToArray(cached_size, target);
+
+      switch (real_type(type)) {
+#define HANDLE_TYPE(UPPERCASE, CAMELCASE, LOWERCASE)                 \
+  case WireFormatLite::TYPE_##UPPERCASE:                             \
+    for (int i = 0; i < repeated_##LOWERCASE##_value->size(); i++) { \
+      target = stream->EnsureSpace(target);                          \
+      target = WireFormatLite::Write##CAMELCASE##NoTagToArray(       \
+          repeated_##LOWERCASE##_value->Get(i), target);             \
+    }                                                                \
+    break
+
+        HANDLE_TYPE(INT32, Int32, int32_t);
+        HANDLE_TYPE(INT64, Int64, int64_t);
+        HANDLE_TYPE(UINT32, UInt32, uint32_t);
+        HANDLE_TYPE(UINT64, UInt64, uint64_t);
+        HANDLE_TYPE(SINT32, SInt32, int32_t);
+        HANDLE_TYPE(SINT64, SInt64, int64_t);
+        HANDLE_TYPE(FIXED32, Fixed32, uint32_t);
+        HANDLE_TYPE(FIXED64, Fixed64, uint64_t);
+        HANDLE_TYPE(SFIXED32, SFixed32, int32_t);
+        HANDLE_TYPE(SFIXED64, SFixed64, int64_t);
+        HANDLE_TYPE(FLOAT, Float, float);
+        HANDLE_TYPE(DOUBLE, Double, double);
+        HANDLE_TYPE(BOOL, Bool, bool);
+        HANDLE_TYPE(ENUM, Enum, enum);
+#undef HANDLE_TYPE
+
+        case WireFormatLite::TYPE_STRING:
+        case WireFormatLite::TYPE_BYTES:
+        case WireFormatLite::TYPE_GROUP:
+        case WireFormatLite::TYPE_MESSAGE:
+          GOOGLE_LOG(FATAL) << "Non-primitive types can't be packed.";
+          break;
+      }
+    } else {
+      switch (real_type(type)) {
+#define HANDLE_TYPE(UPPERCASE, CAMELCASE, LOWERCASE)                 \
+  case WireFormatLite::TYPE_##UPPERCASE:                             \
+    for (int i = 0; i < repeated_##LOWERCASE##_value->size(); i++) { \
+      target = stream->EnsureSpace(target);                          \
+      target = WireFormatLite::Write##CAMELCASE##ToArray(            \
+          number, repeated_##LOWERCASE##_value->Get(i), target);     \
+    }                                                                \
+    break
+
+        HANDLE_TYPE(INT32, Int32, int32_t);
+        HANDLE_TYPE(INT64, Int64, int64_t);
+        HANDLE_TYPE(UINT32, UInt32, uint32_t);
+        HANDLE_TYPE(UINT64, UInt64, uint64_t);
+        HANDLE_TYPE(SINT32, SInt32, int32_t);
+        HANDLE_TYPE(SINT64, SInt64, int64_t);
+        HANDLE_TYPE(FIXED32, Fixed32, uint32_t);
+        HANDLE_TYPE(FIXED64, Fixed64, uint64_t);
+        HANDLE_TYPE(SFIXED32, SFixed32, int32_t);
+        HANDLE_TYPE(SFIXED64, SFixed64, int64_t);
+        HANDLE_TYPE(FLOAT, Float, float);
+        HANDLE_TYPE(DOUBLE, Double, double);
+        HANDLE_TYPE(BOOL, Bool, bool);
+        HANDLE_TYPE(ENUM, Enum, enum);
+#undef HANDLE_TYPE
+#define HANDLE_TYPE(UPPERCASE, CAMELCASE, LOWERCASE)                 \
+  case WireFormatLite::TYPE_##UPPERCASE:                             \
+    for (int i = 0; i < repeated_##LOWERCASE##_value->size(); i++) { \
+      target = stream->EnsureSpace(target);                          \
+      target = stream->WriteString(                                  \
+          number, repeated_##LOWERCASE##_value->Get(i), target);     \
+    }                                                                \
+    break
+        HANDLE_TYPE(STRING, String, string);
+        HANDLE_TYPE(BYTES, Bytes, string);
+#undef HANDLE_TYPE
+#define HANDLE_TYPE(UPPERCASE, CAMELCASE, LOWERCASE)                     \
+  case WireFormatLite::TYPE_##UPPERCASE:                                 \
+    for (int i = 0; i < repeated_##LOWERCASE##_value->size(); i++) {     \
+      target = stream->EnsureSpace(target);                              \
+      target = WireFormatLite::InternalWrite##CAMELCASE(                 \
+          number, repeated_##LOWERCASE##_value->Get(i), target, stream); \
+    }                                                                    \
+    break
+
+        HANDLE_TYPE(GROUP, Group, message);
+        HANDLE_TYPE(MESSAGE, Message, message);
+#undef HANDLE_TYPE
+      }
+    }
+  } else if (!is_cleared) {
+    switch (real_type(type)) {
+#define HANDLE_TYPE(UPPERCASE, CAMELCASE, VALUE)                               \
+  case WireFormatLite::TYPE_##UPPERCASE:                                       \
+    target = stream->EnsureSpace(target);                                      \
+    target = WireFormatLite::Write##CAMELCASE##ToArray(number, VALUE, target); \
+    break
+
+      HANDLE_TYPE(INT32, Int32, int32_t_value);
+      HANDLE_TYPE(INT64, Int64, int64_t_value);
+      HANDLE_TYPE(UINT32, UInt32, uint32_t_value);
+      HANDLE_TYPE(UINT64, UInt64, uint64_t_value);
+      HANDLE_TYPE(SINT32, SInt32, int32_t_value);
+      HANDLE_TYPE(SINT64, SInt64, int64_t_value);
+      HANDLE_TYPE(FIXED32, Fixed32, uint32_t_value);
+      HANDLE_TYPE(FIXED64, Fixed64, uint64_t_value);
+      HANDLE_TYPE(SFIXED32, SFixed32, int32_t_value);
+      HANDLE_TYPE(SFIXED64, SFixed64, int64_t_value);
+      HANDLE_TYPE(FLOAT, Float, float_value);
+      HANDLE_TYPE(DOUBLE, Double, double_value);
+      HANDLE_TYPE(BOOL, Bool, bool_value);
+      HANDLE_TYPE(ENUM, Enum, enum_value);
+#undef HANDLE_TYPE
+#define HANDLE_TYPE(UPPERCASE, CAMELCASE, VALUE)         \
+  case WireFormatLite::TYPE_##UPPERCASE:                 \
+    target = stream->EnsureSpace(target);                \
+    target = stream->WriteString(number, VALUE, target); \
+    break
+      HANDLE_TYPE(STRING, String, *string_value.Get());
+      HANDLE_TYPE(BYTES, Bytes, *string_value.Get());
+#undef HANDLE_TYPE
+      case WireFormatLite::TYPE_GROUP:
+        target = stream->EnsureSpace(target);
+        target = WireFormatLite::InternalWriteGroup(number, *message_value,
+                                                    target, stream);
+        break;
+      case WireFormatLite::TYPE_MESSAGE:
+        if (is_lazy) {
+          const auto* prototype =
+              extension_set->GetPrototypeForLazyMessage(extendee, number);
+          target = lazymessage_value->WriteMessageToArray(prototype, number,
+                                                          target, stream);
+        } else {
+          target = stream->EnsureSpace(target);
+          target = WireFormatLite::InternalWriteMessage(number, *message_value,
+                                                        target, stream);
+        }
+        break;
+    }
+  }
+  return target;
+}
+
+const MessageLite* ExtensionSetWithArenaString::GetPrototypeForLazyMessage(
+    const MessageLite* extendee, int number) const {
+  GeneratedExtensionFinder finder(extendee);
+  bool was_packed_on_wire = false;
+  ExtensionInfo extension_info;
+  if (!FindExtensionInfoFromFieldNumber(
+          WireFormatLite::WireType::WIRETYPE_LENGTH_DELIMITED, number, &finder,
+          &extension_info, &was_packed_on_wire)) {
+    return nullptr;
+  }
+  return extension_info.message_info.prototype;
+}
+
+uint8_t*
+ExtensionSetWithArenaString::Extension::InternalSerializeMessageSetItemWithCachedSizesToArray(
+    const MessageLite* extendee, const ExtensionSetWithArenaString* extension_set, int number,
+    uint8_t* target, io::EpsCopyOutputStream* stream) const {
+  if (type != WireFormatLite::TYPE_MESSAGE || is_repeated) {
+    // Not a valid MessageSet extension, but serialize it the normal way.
+    GOOGLE_LOG(WARNING) << "Invalid message set extension.";
+    return InternalSerializeFieldWithCachedSizesToArray(extendee, extension_set,
+                                                        number, target, stream);
+  }
+
+  if (is_cleared) return target;
+
+  target = stream->EnsureSpace(target);
+  // Start group.
+  target = io::CodedOutputStream::WriteTagToArray(
+      WireFormatLite::kMessageSetItemStartTag, target);
+  // Write type ID.
+  target = WireFormatLite::WriteUInt32ToArray(
+      WireFormatLite::kMessageSetTypeIdNumber, number, target);
+  // Write message.
+  if (is_lazy) {
+    const auto* prototype =
+        extension_set->GetPrototypeForLazyMessage(extendee, number);
+    target = lazymessage_value->WriteMessageToArray(
+        prototype, WireFormatLite::kMessageSetMessageNumber, target, stream);
+  } else {
+    target = WireFormatLite::InternalWriteMessage(
+        WireFormatLite::kMessageSetMessageNumber, *message_value, target,
+        stream);
+  }
+  // End group.
+  target = stream->EnsureSpace(target);
+  target = io::CodedOutputStream::WriteTagToArray(
+      WireFormatLite::kMessageSetItemEndTag, target);
+  return target;
+}
+
+size_t ExtensionSetWithArenaString::Extension::MessageSetItemByteSize(int number) const {
+  if (type != WireFormatLite::TYPE_MESSAGE || is_repeated) {
+    // Not a valid MessageSet extension, but compute the byte size for it the
+    // normal way.
+    return ByteSize(number);
+  }
+
+  if (is_cleared) return 0;
+
+  size_t our_size = WireFormatLite::kMessageSetItemTagsSize;
+
+  // type_id
+  our_size += io::CodedOutputStream::VarintSize32(number);
+
+  // message
+  size_t message_size = 0;
+  if (is_lazy) {
+    message_size = lazymessage_value->ByteSizeLong();
+  } else {
+    message_size = message_value->ByteSizeLong();
+  }
+
+  our_size += io::CodedOutputStream::VarintSize32(message_size);
+  our_size += message_size;
+
+  return our_size;
+}
+
+size_t ExtensionSetWithArenaString::MessageSetByteSize() const {
+  size_t total_size = 0;
+  ForEach([&total_size](int number, const Extension& ext) {
+    total_size += ext.MessageSetItemByteSize(number);
+  });
+  return total_size;
+}
+
+
+}  // namespace internal
+}  // namespace protobuf
+}  // namespace google
+
+#include <google/protobuf/port_undef.inc>
diff --git a/src/google/protobuf/patch/extension_set_with_arenastring.h b/src/google/protobuf/patch/extension_set_with_arenastring.h
new file mode 100644
index 000000000..04653b2ea
--- /dev/null
+++ b/src/google/protobuf/patch/extension_set_with_arenastring.h
@@ -0,0 +1,1031 @@
+// Protocol Buffers - Google's data interchange format
+// Copyright 2008 Google Inc.  All rights reserved.
+// https://developers.google.com/protocol-buffers/
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Author: kenton@google.com (Kenton Varda)
+//  Based on original Protocol Buffers design by
+//  Sanjay Ghemawat, Jeff Dean, and others.
+//
+// This header is logically internal, but is made public because it is used
+// from protocol-compiler-generated code, which may reside in other components.
+
+#ifndef GOOGLE_PROTOBUF_PATCH_EXTENSION_SET_WITH_ARENASTRING_H__
+#define GOOGLE_PROTOBUF_PATCH_EXTENSION_SET_WITH_ARENASTRING_H__
+
+#include <algorithm>
+#include <cassert>
+#include <map>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include <google/protobuf/stubs/common.h>
+#include <google/protobuf/stubs/logging.h>
+#include <google/protobuf/extension_set.h>
+#include <google/protobuf/parse_context.h>
+#include <google/protobuf/io/coded_stream.h>
+#include <google/protobuf/port.h>
+//#include <google/protobuf/repeated_field.h>
+#include <google/protobuf/patch/repeated_arenastring_field.h>
+#include <google/protobuf/wire_format_lite.h>
+
+// clang-format off
+#include <google/protobuf/port_def.inc>  // Must be last
+// clang-format on
+
+#ifdef SWIG
+#error "You cannot SWIG proto headers"
+#endif
+
+namespace google {
+namespace protobuf {
+class Arena;
+class Descriptor;       // descriptor.h
+class FieldDescriptor;  // descriptor.h
+class DescriptorPool;   // descriptor.h
+class MessageLite;      // message_lite.h
+class Message;          // message.h
+class MessageFactory;   // message.h
+class UnknownFieldSet;  // unknown_field_set.h
+namespace internal {
+class FieldSkipper;  // wire_format_lite.h
+}  // namespace internal
+}  // namespace protobuf
+}  // namespace google
+
+namespace google {
+namespace protobuf {
+namespace internal {
+
+class InternalMetadata;
+
+// A FieldSkipper used for parsing MessageSet.
+class MessageSetFieldSkipperWithArenaString;
+
+// Note:  extension_set_heavy.cc defines DescriptorPoolExtensionFinder for
+// finding extensions from a DescriptorPool.
+
+// This is an internal helper class intended for use within the protocol buffer
+// library and generated classes.  Clients should not use it directly.  Instead,
+// use the generated accessors such as GetExtension() of the class being
+// extended.
+//
+// This class manages extensions for a protocol message object.  The
+// message's HasExtension(), GetExtension(), MutableExtension(), and
+// ClearExtension() methods are just thin wrappers around the embedded
+// ExtensionSetWithArenaString.  When parsing, if a tag number is encountered which is
+// inside one of the message type's extension ranges, the tag is passed
+// off to the ExtensionSetWithArenaString for parsing.  Etc.
+//class PROTOBUF_EXPORT ExtensionSetWithArenaString {
+class ExtensionSetWithArenaString {
+ public:
+  constexpr ExtensionSetWithArenaString();
+  explicit ExtensionSetWithArenaString(Arena* arena);
+  ~ExtensionSetWithArenaString();
+
+  // These are called at startup by protocol-compiler-generated code to
+  // register known extensions.  The registrations are used by ParseField()
+  // to look up extensions for parsed field numbers.  Note that dynamic parsing
+  // does not use ParseField(); only protocol-compiler-generated parsing
+  // methods do.
+  static void RegisterExtension(const MessageLite* extendee, int number,
+                                FieldType type, bool is_repeated,
+                                bool is_packed);
+  static void RegisterEnumExtension(const MessageLite* extendee, int number,
+                                    FieldType type, bool is_repeated,
+                                    bool is_packed, EnumValidityFunc* is_valid);
+  static void RegisterMessageExtension(const MessageLite* extendee, int number,
+                                       FieldType type, bool is_repeated,
+                                       bool is_packed,
+                                       const MessageLite* prototype);
+
+  // =================================================================
+
+  // Add all fields which are currently present to the given vector.  This
+  // is useful to implement Reflection::ListFields().
+  void AppendToList(const Descriptor* extendee, const DescriptorPool* pool,
+                    std::vector<const FieldDescriptor*>* output) const;
+
+  // =================================================================
+  // Accessors
+  //
+  // Generated message classes include type-safe templated wrappers around
+  // these methods.  Generally you should use those rather than call these
+  // directly, unless you are doing low-level memory management.
+  //
+  // When calling any of these accessors, the extension number requested
+  // MUST exist in the DescriptorPool provided to the constructor.  Otherwise,
+  // the method will fail an assert.  Normally, though, you would not call
+  // these directly; you would either call the generated accessors of your
+  // message class (e.g. GetExtension()) or you would call the accessors
+  // of the reflection interface.  In both cases, it is impossible to
+  // trigger this assert failure:  the generated accessors only accept
+  // linked-in extension types as parameters, while the Reflection interface
+  // requires you to provide the FieldDescriptor describing the extension.
+  //
+  // When calling any of these accessors, a protocol-compiler-generated
+  // implementation of the extension corresponding to the number MUST
+  // be linked in, and the FieldDescriptor used to refer to it MUST be
+  // the one generated by that linked-in code.  Otherwise, the method will
+  // die on an assert failure.  The message objects returned by the message
+  // accessors are guaranteed to be of the correct linked-in type.
+  //
+  // These methods pretty much match Reflection except that:
+  // - They're not virtual.
+  // - They identify fields by number rather than FieldDescriptors.
+  // - They identify enum values using integers rather than descriptors.
+  // - Strings provide Mutable() in addition to Set() accessors.
+
+  bool Has(int number) const;
+  int ExtensionSize(int number) const;  // Size of a repeated extension.
+  int NumExtensions() const;            // The number of extensions
+  FieldType ExtensionType(int number) const;
+  void ClearExtension(int number);
+
+  // singular fields -------------------------------------------------
+
+  int32_t GetInt32(int number, int32_t default_value) const;
+  int64_t GetInt64(int number, int64_t default_value) const;
+  uint32_t GetUInt32(int number, uint32_t default_value) const;
+  uint64_t GetUInt64(int number, uint64_t default_value) const;
+  float GetFloat(int number, float default_value) const;
+  double GetDouble(int number, double default_value) const;
+  bool GetBool(int number, bool default_value) const;
+  int GetEnum(int number, int default_value) const;
+  const std::string& GetString(int number,
+                               const std::string& default_value) const;
+  const MessageLite& GetMessage(int number,
+                                const MessageLite& default_value) const;
+  const MessageLite& GetMessage(int number, const Descriptor* message_type,
+                                MessageFactory* factory) const;
+
+  // |descriptor| may be NULL so long as it is known that the descriptor for
+  // the extension lives in the same pool as the descriptor for the containing
+  // type.
+#define desc_with_arenastring const FieldDescriptor* descriptor  // avoid line wrapping
+  void SetInt32(int number, FieldType type, int32_t value, desc_with_arenastring);
+  void SetInt64(int number, FieldType type, int64_t value, desc_with_arenastring);
+  void SetUInt32(int number, FieldType type, uint32_t value, desc_with_arenastring);
+  void SetUInt64(int number, FieldType type, uint64_t value, desc_with_arenastring);
+  void SetFloat(int number, FieldType type, float value, desc_with_arenastring);
+  void SetDouble(int number, FieldType type, double value, desc_with_arenastring);
+  void SetBool(int number, FieldType type, bool value, desc_with_arenastring);
+  void SetEnum(int number, FieldType type, int value, desc_with_arenastring);
+  void SetString(int number, FieldType type, std::string value, desc_with_arenastring);
+  //std::string* MutableString(int number, FieldType type, desc);
+  MutableStringType MutableString(int number, FieldType type, desc_with_arenastring);
+  MaybeArenaStringAccessor MutableAccessor(int number, FieldType type, desc_with_arenastring);
+
+  MessageLite* MutableMessage(int number, FieldType type,
+                              const MessageLite& prototype, desc_with_arenastring);
+  MessageLite* MutableMessage(const FieldDescriptor* descriptor,
+                              MessageFactory* factory);
+  // Adds the given message to the ExtensionSetWithArenaString, taking ownership of the
+  // message object. Existing message with the same number will be deleted.
+  // If "message" is NULL, this is equivalent to "ClearExtension(number)".
+  void SetAllocatedMessage(int number, FieldType type,
+                           const FieldDescriptor* descriptor,
+                           MessageLite* message);
+  void UnsafeArenaSetAllocatedMessage(int number, FieldType type,
+                                      const FieldDescriptor* descriptor,
+                                      MessageLite* message);
+  PROTOBUF_MUST_USE_RESULT MessageLite* ReleaseMessage(
+      int number, const MessageLite& prototype);
+  MessageLite* UnsafeArenaReleaseMessage(int number,
+                                         const MessageLite& prototype);
+
+  PROTOBUF_MUST_USE_RESULT MessageLite* ReleaseMessage(
+      const FieldDescriptor* descriptor, MessageFactory* factory);
+  MessageLite* UnsafeArenaReleaseMessage(const FieldDescriptor* descriptor,
+                                         MessageFactory* factory);
+#undef desc
+  Arena* GetArena() const { return arena_; }
+
+  // repeated fields -------------------------------------------------
+
+  // Fetches a RepeatedField extension by number; returns |default_value|
+  // if no such extension exists. User should not touch this directly; it is
+  // used by the GetRepeatedExtension() method.
+  const void* GetRawRepeatedField(int number, const void* default_value) const;
+  // Fetches a mutable version of a RepeatedField extension by number,
+  // instantiating one if none exists. Similar to above, user should not use
+  // this directly; it underlies MutableRepeatedExtension().
+  void* MutableRawRepeatedField(int number, FieldType field_type, bool packed,
+                                const FieldDescriptor* desc);
+
+  // This is an overload of MutableRawRepeatedField to maintain compatibility
+  // with old code using a previous API. This version of
+  // MutableRawRepeatedField() will GOOGLE_CHECK-fail on a missing extension.
+  // (E.g.: borg/clients/internal/proto1/proto2_reflection.cc.)
+  void* MutableRawRepeatedField(int number);
+
+  int32_t GetRepeatedInt32(int number, int index) const;
+  int64_t GetRepeatedInt64(int number, int index) const;
+  uint32_t GetRepeatedUInt32(int number, int index) const;
+  uint64_t GetRepeatedUInt64(int number, int index) const;
+  float GetRepeatedFloat(int number, int index) const;
+  double GetRepeatedDouble(int number, int index) const;
+  bool GetRepeatedBool(int number, int index) const;
+  int GetRepeatedEnum(int number, int index) const;
+  const std::string& GetRepeatedString(int number, int index) const;
+  const MessageLite& GetRepeatedMessage(int number, int index) const;
+
+  void SetRepeatedInt32(int number, int index, int32_t value);
+  void SetRepeatedInt64(int number, int index, int64_t value);
+  void SetRepeatedUInt32(int number, int index, uint32_t value);
+  void SetRepeatedUInt64(int number, int index, uint64_t value);
+  void SetRepeatedFloat(int number, int index, float value);
+  void SetRepeatedDouble(int number, int index, double value);
+  void SetRepeatedBool(int number, int index, bool value);
+  void SetRepeatedEnum(int number, int index, int value);
+  void SetRepeatedString(int number, int index, std::string value);
+  //std::string* MutableRepeatedString(int number, int index);
+  MutableStringType MutableRepeatedString(int number, int index);
+  MaybeArenaStringAccessor MutableRepeatedAccessor(int number, int index);
+
+  MessageLite* MutableRepeatedMessage(int number, int index);
+
+#define desc const FieldDescriptor* descriptor  // avoid line wrapping
+  void AddInt32(int number, FieldType type, bool packed, int32_t value, desc);
+  void AddInt64(int number, FieldType type, bool packed, int64_t value, desc);
+  void AddUInt32(int number, FieldType type, bool packed, uint32_t value, desc);
+  void AddUInt64(int number, FieldType type, bool packed, uint64_t value, desc);
+  void AddFloat(int number, FieldType type, bool packed, float value, desc);
+  void AddDouble(int number, FieldType type, bool packed, double value, desc);
+  void AddBool(int number, FieldType type, bool packed, bool value, desc);
+  void AddEnum(int number, FieldType type, bool packed, int value, desc);
+  void AddString(int number, FieldType type, std::string value, desc);
+  //std::string* AddString(int number, FieldType type, desc);
+  MutableStringType AddString(int number, FieldType type, desc);
+  MaybeArenaStringAccessor AddAccessor(int number, FieldType type, desc);
+
+  MessageLite* AddMessage(int number, FieldType type,
+                          const MessageLite& prototype, desc);
+  MessageLite* AddMessage(const FieldDescriptor* descriptor,
+                          MessageFactory* factory);
+  void AddAllocatedMessage(const FieldDescriptor* descriptor,
+                           MessageLite* new_entry);
+  void UnsafeArenaAddAllocatedMessage(const FieldDescriptor* descriptor,
+                                      MessageLite* new_entry);
+#undef desc
+
+  void RemoveLast(int number);
+  PROTOBUF_MUST_USE_RESULT MessageLite* ReleaseLast(int number);
+  MessageLite* UnsafeArenaReleaseLast(int number);
+  void SwapElements(int number, int index1, int index2);
+
+  // -----------------------------------------------------------------
+  // TODO(kenton):  Hardcore memory management accessors
+
+  // =================================================================
+  // convenience methods for implementing methods of Message
+  //
+  // These could all be implemented in terms of the other methods of this
+  // class, but providing them here helps keep the generated code size down.
+
+  void Clear();
+  void MergeFrom(const ExtensionSetWithArenaString& other);
+  void Swap(ExtensionSetWithArenaString* other);
+  void InternalSwap(ExtensionSetWithArenaString* other);
+  void SwapExtension(ExtensionSetWithArenaString* other, int number);
+  void UnsafeShallowSwapExtension(ExtensionSetWithArenaString* other, int number);
+  bool IsInitialized() const;
+
+  // Parses a single extension from the input. The input should start out
+  // positioned immediately after the tag.
+  bool ParseField(uint32_t tag, io::CodedInputStream* input,
+                  ExtensionFinder* extension_finder,
+                  FieldSkipper* field_skipper);
+
+  // Specific versions for lite or full messages (constructs the appropriate
+  // FieldSkipper automatically).  |extendee| is the default
+  // instance for the containing message; it is used only to look up the
+  // extension by number.  See RegisterExtension(), above.  Unlike the other
+  // methods of ExtensionSetWithArenaString, this only works for generated message types --
+  // it looks up extensions registered using RegisterExtension().
+  bool ParseField(uint32_t tag, io::CodedInputStream* input,
+                  const MessageLite* extendee);
+  bool ParseField(uint32_t tag, io::CodedInputStream* input,
+                  const Message* extendee, UnknownFieldSet* unknown_fields);
+  bool ParseField(uint32_t tag, io::CodedInputStream* input,
+                  const MessageLite* extendee,
+                  io::CodedOutputStream* unknown_fields);
+
+  // Lite parser
+  const char* ParseField(uint64_t tag, const char* ptr,
+                         const MessageLite* extendee,
+                         internal::InternalMetadata* metadata,
+                         internal::ParseContext* ctx);
+  // Full parser
+  const char* ParseField(uint64_t tag, const char* ptr, const Message* extendee,
+                         internal::InternalMetadata* metadata,
+                         internal::ParseContext* ctx);
+  template <typename Msg>
+  const char* ParseMessageSet(const char* ptr, const Msg* extendee,
+                              InternalMetadata* metadata,
+                              internal::ParseContext* ctx) {
+    struct MessageSetItem {
+      const char* _InternalParse(const char* ptr, ParseContext* ctx) {
+        return me->ParseMessageSetItem(ptr, extendee, metadata, ctx);
+      }
+      ExtensionSetWithArenaString* me;
+      const Msg* extendee;
+      InternalMetadata* metadata;
+    } item{this, extendee, metadata};
+    while (!ctx->Done(&ptr)) {
+      uint32_t tag;
+      ptr = ReadTag(ptr, &tag);
+      GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
+      if (tag == WireFormatLite::kMessageSetItemStartTag) {
+        ptr = ctx->ParseGroup(&item, ptr, tag);
+        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
+      } else {
+        if (tag == 0 || (tag & 7) == 4) {
+          ctx->SetLastTag(tag);
+          return ptr;
+        }
+        ptr = ParseField(tag, ptr, extendee, metadata, ctx);
+        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
+      }
+    }
+    return ptr;
+  }
+
+  // Parse an entire message in MessageSet format.  Such messages have no
+  // fields, only extensions.
+  bool ParseMessageSetLite(io::CodedInputStream* input,
+                           ExtensionFinder* extension_finder,
+                           FieldSkipper* field_skipper);
+  bool ParseMessageSet(io::CodedInputStream* input,
+                       ExtensionFinder* extension_finder,
+                       MessageSetFieldSkipperWithArenaString* field_skipper);
+
+  // Specific versions for lite or full messages (constructs the appropriate
+  // FieldSkipper automatically).
+  bool ParseMessageSet(io::CodedInputStream* input, const MessageLite* extendee,
+                       std::string* unknown_fields);
+  bool ParseMessageSet(io::CodedInputStream* input, const Message* extendee,
+                       UnknownFieldSet* unknown_fields);
+
+  // Write all extension fields with field numbers in the range
+  //   [start_field_number, end_field_number)
+  // to the output stream, using the cached sizes computed when ByteSize() was
+  // last called.  Note that the range bounds are inclusive-exclusive.
+  void SerializeWithCachedSizes(const MessageLite* extendee,
+                                int start_field_number, int end_field_number,
+                                io::CodedOutputStream* output) const {
+    output->SetCur(_InternalSerialize(extendee, start_field_number,
+                                      end_field_number, output->Cur(),
+                                      output->EpsCopy()));
+  }
+
+  // Same as SerializeWithCachedSizes, but without any bounds checking.
+  // The caller must ensure that target has sufficient capacity for the
+  // serialized extensions.
+  //
+  // Returns a pointer past the last written byte.
+
+  uint8_t* _InternalSerialize(const MessageLite* extendee,
+                              int start_field_number, int end_field_number,
+                              uint8_t* target,
+                              io::EpsCopyOutputStream* stream) const {
+    if (flat_size_ == 0) {
+      assert(!is_large());
+      return target;
+    }
+    return _InternalSerializeImpl(extendee, start_field_number,
+                                  end_field_number, target, stream);
+  }
+
+  // Like above but serializes in MessageSet format.
+  void SerializeMessageSetWithCachedSizes(const MessageLite* extendee,
+                                          io::CodedOutputStream* output) const {
+    output->SetCur(InternalSerializeMessageSetWithCachedSizesToArray(
+        extendee, output->Cur(), output->EpsCopy()));
+  }
+  uint8_t* InternalSerializeMessageSetWithCachedSizesToArray(
+      const MessageLite* extendee, uint8_t* target,
+      io::EpsCopyOutputStream* stream) const;
+
+  // For backward-compatibility, versions of two of the above methods that
+  // serialize deterministically iff SetDefaultSerializationDeterministic()
+  // has been called.
+  uint8_t* SerializeWithCachedSizesToArray(int start_field_number,
+                                           int end_field_number,
+                                           uint8_t* target) const;
+  uint8_t* SerializeMessageSetWithCachedSizesToArray(
+      const MessageLite* extendee, uint8_t* target) const;
+
+  // Returns the total serialized size of all the extensions.
+  size_t ByteSize() const;
+
+  // Like ByteSize() but uses MessageSet format.
+  size_t MessageSetByteSize() const;
+
+  // Returns (an estimate of) the total number of bytes used for storing the
+  // extensions in memory, excluding sizeof(*this).  If the ExtensionSetWithArenaString is
+  // for a lite message (and thus possibly contains lite messages), the results
+  // are undefined (might work, might crash, might corrupt data, might not even
+  // be linked in).  It's up to the protocol compiler to avoid calling this on
+  // such ExtensionSetWithArenaStrings (easy enough since lite messages don't implement
+  // SpaceUsed()).
+  size_t SpaceUsedExcludingSelfLong() const;
+
+  // This method just calls SpaceUsedExcludingSelfLong() but it can not be
+  // inlined because the definition of SpaceUsedExcludingSelfLong() is not
+  // included in lite runtime and when an inline method refers to it MSVC
+  // will complain about unresolved symbols when building the lite runtime
+  // as .dll.
+  int SpaceUsedExcludingSelf() const;
+
+ private:
+  template <typename Type>
+  friend class PrimitiveTypeTraits;
+
+  template <typename Type>
+  friend class RepeatedPrimitiveTypeTraits;
+
+  template <typename Type, bool IsValid(int)>
+  friend class EnumTypeTraits;
+
+  template <typename Type, bool IsValid(int)>
+  friend class RepeatedEnumTypeTraits;
+
+  const int32_t& GetRefInt32(int number, const int32_t& default_value) const;
+  const int64_t& GetRefInt64(int number, const int64_t& default_value) const;
+  const uint32_t& GetRefUInt32(int number, const uint32_t& default_value) const;
+  const uint64_t& GetRefUInt64(int number, const uint64_t& default_value) const;
+  const float& GetRefFloat(int number, const float& default_value) const;
+  const double& GetRefDouble(int number, const double& default_value) const;
+  const bool& GetRefBool(int number, const bool& default_value) const;
+  const int& GetRefEnum(int number, const int& default_value) const;
+  const int32_t& GetRefRepeatedInt32(int number, int index) const;
+  const int64_t& GetRefRepeatedInt64(int number, int index) const;
+  const uint32_t& GetRefRepeatedUInt32(int number, int index) const;
+  const uint64_t& GetRefRepeatedUInt64(int number, int index) const;
+  const float& GetRefRepeatedFloat(int number, int index) const;
+  const double& GetRefRepeatedDouble(int number, int index) const;
+  const bool& GetRefRepeatedBool(int number, int index) const;
+  const int& GetRefRepeatedEnum(int number, int index) const;
+
+  // Implementation of _InternalSerialize for non-empty map_.
+  uint8_t* _InternalSerializeImpl(const MessageLite* extendee,
+                                  int start_field_number, int end_field_number,
+                                  uint8_t* target,
+                                  io::EpsCopyOutputStream* stream) const;
+  // Interface of a lazily parsed singular message extension.
+  class PROTOBUF_EXPORT LazyMessageExtension {
+   public:
+    LazyMessageExtension() {}
+    virtual ~LazyMessageExtension() {}
+
+    virtual LazyMessageExtension* New(Arena* arena) const = 0;
+    virtual const MessageLite& GetMessage(
+        const MessageLite& prototype) const = 0;
+    virtual MessageLite* MutableMessage(const MessageLite& prototype,
+                                        Arena* arena) = 0;
+    virtual void SetAllocatedMessage(MessageLite* message) = 0;
+    virtual void UnsafeArenaSetAllocatedMessage(MessageLite* message) = 0;
+    virtual PROTOBUF_MUST_USE_RESULT MessageLite* ReleaseMessage(
+        const MessageLite& prototype) = 0;
+    virtual MessageLite* UnsafeArenaReleaseMessage(
+        const MessageLite& prototype) = 0;
+
+    virtual bool IsInitialized() const = 0;
+
+    PROTOBUF_DEPRECATED_MSG("Please use ByteSizeLong() instead")
+    virtual int ByteSize() const { return internal::ToIntSize(ByteSizeLong()); }
+    virtual size_t ByteSizeLong() const = 0;
+    virtual size_t SpaceUsedLong() const = 0;
+
+    virtual void MergeFrom(const LazyMessageExtension& other, Arena* arena) = 0;
+    virtual void MergeFromMessage(const MessageLite& msg, Arena* arena) = 0;
+    virtual void Clear() = 0;
+
+    virtual bool ReadMessage(const MessageLite& prototype,
+                             io::CodedInputStream* input) = 0;
+    virtual const char* _InternalParse(const char* ptr, ParseContext* ctx) = 0;
+    virtual uint8_t* WriteMessageToArray(
+        const MessageLite* prototype, int number, uint8_t* target,
+        io::EpsCopyOutputStream* stream) const = 0;
+
+   private:
+    virtual void UnusedKeyMethod();  // Dummy key method to avoid weak vtable.
+
+    GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(LazyMessageExtension);
+  };
+  // Give access to function defined below to see LazyMessageExtension.
+  friend LazyMessageExtension* MaybeCreateLazyExtensionWithArenaString(Arena* arena);
+  struct Extension {
+    // The order of these fields packs Extension into 24 bytes when using 8
+    // byte alignment. Consider this when adding or removing fields here.
+    union {
+      int32_t int32_t_value;
+      int64_t int64_t_value;
+      uint32_t uint32_t_value;
+      uint64_t uint64_t_value;
+      float float_value;
+      double double_value;
+      bool bool_value;
+      int enum_value;
+      //std::string* string_value;
+      internal::TaggedStringPtrWithPatch string_value;
+      MessageLite* message_value;
+      LazyMessageExtension* lazymessage_value;
+
+      RepeatedField<int32_t>* repeated_int32_t_value;
+      RepeatedField<int64_t>* repeated_int64_t_value;
+      RepeatedField<uint32_t>* repeated_uint32_t_value;
+      RepeatedField<uint64_t>* repeated_uint64_t_value;
+      RepeatedField<float>* repeated_float_value;
+      RepeatedField<double>* repeated_double_value;
+      RepeatedField<bool>* repeated_bool_value;
+      RepeatedField<int>* repeated_enum_value;
+      RepeatedArenaPtrField<std::string>* repeated_string_value;
+      RepeatedArenaPtrField<MessageLite>* repeated_message_value;
+    };
+
+    FieldType type;
+    bool is_repeated;
+
+    // For singular types, indicates if the extension is "cleared".  This
+    // happens when an extension is set and then later cleared by the caller.
+    // We want to keep the Extension object around for reuse, so instead of
+    // removing it from the map, we just set is_cleared = true.  This has no
+    // meaning for repeated types; for those, the size of the RepeatedField
+    // simply becomes zero when cleared.
+    bool is_cleared : 4;
+
+    // For singular message types, indicates whether lazy parsing is enabled
+    // for this extension. This field is only valid when type == TYPE_MESSAGE
+    // and !is_repeated because we only support lazy parsing for singular
+    // message types currently. If is_lazy = true, the extension is stored in
+    // lazymessage_value. Otherwise, the extension will be message_value.
+    bool is_lazy : 4;
+
+    // For repeated types, this indicates if the [packed=true] option is set.
+    bool is_packed;
+
+    // For packed fields, the size of the packed data is recorded here when
+    // ByteSize() is called then used during serialization.
+    // TODO(kenton):  Use atomic<int> when C++ supports it.
+    mutable int cached_size;
+
+    // The descriptor for this extension, if one exists and is known.  May be
+    // NULL.  Must not be NULL if the descriptor for the extension does not
+    // live in the same pool as the descriptor for the containing type.
+    const FieldDescriptor* descriptor;
+
+    // Some helper methods for operations on a single Extension.
+    uint8_t* InternalSerializeFieldWithCachedSizesToArray(
+        const MessageLite* extendee, const ExtensionSetWithArenaString* extension_set,
+        int number, uint8_t* target, io::EpsCopyOutputStream* stream) const;
+    uint8_t* InternalSerializeMessageSetItemWithCachedSizesToArray(
+        const MessageLite* extendee, const ExtensionSetWithArenaString* extension_set,
+        int number, uint8_t* target, io::EpsCopyOutputStream* stream) const;
+    size_t ByteSize(int number) const;
+    size_t MessageSetItemByteSize(int number) const;
+    void Clear();
+    int GetSize() const;
+    void Free();
+    size_t SpaceUsedExcludingSelfLong() const;
+    bool IsInitialized() const;
+  };
+
+  // The Extension struct is small enough to be passed by value, so we use it
+  // directly as the value type in mappings rather than use pointers.  We use
+  // sorted maps rather than hash-maps because we expect most ExtensionSetWithArenaStrings will
+  // only contain a small number of extension.  Also, we want AppendToList and
+  // deterministic serialization to order fields by field number.
+
+  struct KeyValue {
+    int first;
+    Extension second;
+
+    struct FirstComparator {
+      bool operator()(const KeyValue& lhs, const KeyValue& rhs) const {
+        return lhs.first < rhs.first;
+      }
+      bool operator()(const KeyValue& lhs, int key) const {
+        return lhs.first < key;
+      }
+      bool operator()(int key, const KeyValue& rhs) const {
+        return key < rhs.first;
+      }
+    };
+  };
+
+  typedef std::map<int, Extension> LargeMap;
+
+  // Wrapper API that switches between flat-map and LargeMap.
+
+  // Finds a key (if present) in the ExtensionSetWithArenaString.
+  const Extension* FindOrNull(int key) const;
+  Extension* FindOrNull(int key);
+
+  // Helper-functions that only inspect the LargeMap.
+  const Extension* FindOrNullInLargeMap(int key) const;
+  Extension* FindOrNullInLargeMap(int key);
+
+  // Inserts a new (key, Extension) into the ExtensionSetWithArenaString (and returns true), or
+  // finds the already-existing Extension for that key (returns false).
+  // The Extension* will point to the new-or-found Extension.
+  std::pair<Extension*, bool> Insert(int key);
+
+  // Grows the flat_capacity_.
+  // If flat_capacity_ > kMaximumFlatCapacity, converts to LargeMap.
+  void GrowCapacity(size_t minimum_new_capacity);
+  static constexpr uint16_t kMaximumFlatCapacity = 256;
+  bool is_large() const { return static_cast<int16_t>(flat_size_) < 0; }
+
+  // Removes a key from the ExtensionSetWithArenaString.
+  void Erase(int key);
+
+  size_t Size() const {
+    return PROTOBUF_PREDICT_FALSE(is_large()) ? map_.large->size() : flat_size_;
+  }
+
+  // Similar to std::for_each.
+  // Each Iterator is decomposed into ->first and ->second fields, so
+  // that the KeyValueFunctor can be agnostic vis-a-vis KeyValue-vs-std::pair.
+  template <typename Iterator, typename KeyValueFunctor>
+  static KeyValueFunctor ForEach(Iterator begin, Iterator end,
+                                 KeyValueFunctor func) {
+    for (Iterator it = begin; it != end; ++it) func(it->first, it->second);
+    return std::move(func);
+  }
+
+  // Applies a functor to the <int, Extension&> pairs in sorted order.
+  template <typename KeyValueFunctor>
+  KeyValueFunctor ForEach(KeyValueFunctor func) {
+    if (PROTOBUF_PREDICT_FALSE(is_large())) {
+      return ForEach(map_.large->begin(), map_.large->end(), std::move(func));
+    }
+    return ForEach(flat_begin(), flat_end(), std::move(func));
+  }
+
+  // Applies a functor to the <int, const Extension&> pairs in sorted order.
+  template <typename KeyValueFunctor>
+  KeyValueFunctor ForEach(KeyValueFunctor func) const {
+    if (PROTOBUF_PREDICT_FALSE(is_large())) {
+      return ForEach(map_.large->begin(), map_.large->end(), std::move(func));
+    }
+    return ForEach(flat_begin(), flat_end(), std::move(func));
+  }
+
+  // Merges existing Extension from other_extension
+  void InternalExtensionMergeFrom(int number, const Extension& other_extension);
+
+  // Returns true and fills field_number and extension if extension is found.
+  // Note to support packed repeated field compatibility, it also fills whether
+  // the tag on wire is packed, which can be different from
+  // extension->is_packed (whether packed=true is specified).
+  bool FindExtensionInfoFromTag(uint32_t tag, ExtensionFinder* extension_finder,
+                                int* field_number, ExtensionInfo* extension,
+                                bool* was_packed_on_wire);
+
+  // Returns true and fills extension if extension is found.
+  // Note to support packed repeated field compatibility, it also fills whether
+  // the tag on wire is packed, which can be different from
+  // extension->is_packed (whether packed=true is specified).
+  bool FindExtensionInfoFromFieldNumber(int wire_type, int field_number,
+                                        ExtensionFinder* extension_finder,
+                                        ExtensionInfo* extension,
+                                        bool* was_packed_on_wire) const;
+
+  // Find the prototype for a LazyMessage from the extension registry. Returns
+  // null if the extension is not found.
+  const MessageLite* GetPrototypeForLazyMessage(const MessageLite* extendee,
+                                                int number) const;
+
+  // Parses a single extension from the input. The input should start out
+  // positioned immediately after the wire tag. This method is called in
+  // ParseField() after field number and was_packed_on_wire is extracted from
+  // the wire tag and ExtensionInfo is found by the field number.
+  bool ParseFieldWithExtensionInfo(int field_number, bool was_packed_on_wire,
+                                   const ExtensionInfo& extension,
+                                   io::CodedInputStream* input,
+                                   FieldSkipper* field_skipper);
+
+  // Like ParseField(), but this method may parse singular message extensions
+  // lazily depending on the value of FLAGS_eagerly_parse_message_sets.
+  bool ParseFieldMaybeLazily(int wire_type, int field_number,
+                             io::CodedInputStream* input,
+                             ExtensionFinder* extension_finder,
+                             MessageSetFieldSkipperWithArenaString* field_skipper);
+
+  // Gets the extension with the given number, creating it if it does not
+  // already exist.  Returns true if the extension did not already exist.
+  bool MaybeNewExtension(int number, const FieldDescriptor* descriptor,
+                         Extension** result);
+
+  // Gets the repeated extension for the given descriptor, creating it if
+  // it does not exist.
+  Extension* MaybeNewRepeatedExtension(const FieldDescriptor* descriptor);
+
+  // Parse a single MessageSet item -- called just after the item group start
+  // tag has been read.
+  bool ParseMessageSetItemLite(io::CodedInputStream* input,
+                               ExtensionFinder* extension_finder,
+                               FieldSkipper* field_skipper);
+  // Parse a single MessageSet item -- called just after the item group start
+  // tag has been read.
+  bool ParseMessageSetItem(io::CodedInputStream* input,
+                           ExtensionFinder* extension_finder,
+                           MessageSetFieldSkipperWithArenaString* field_skipper);
+
+  bool FindExtension(int wire_type, uint32_t field, const MessageLite* extendee,
+                     const internal::ParseContext* /*ctx*/,
+                     ExtensionInfo* extension, bool* was_packed_on_wire) {
+    GeneratedExtensionFinder finder(extendee);
+    return FindExtensionInfoFromFieldNumber(wire_type, field, &finder,
+                                            extension, was_packed_on_wire);
+  }
+  inline bool FindExtension(int wire_type, uint32_t field,
+                            const Message* extendee,
+                            const internal::ParseContext* ctx,
+                            ExtensionInfo* extension, bool* was_packed_on_wire);
+  // Used for MessageSet only
+  const char* ParseFieldMaybeLazily(uint64_t tag, const char* ptr,
+                                    const MessageLite* extendee,
+                                    internal::InternalMetadata* metadata,
+                                    internal::ParseContext* ctx) {
+    // Lite MessageSet doesn't implement lazy.
+    return ParseField(tag, ptr, extendee, metadata, ctx);
+  }
+  const char* ParseFieldMaybeLazily(uint64_t tag, const char* ptr,
+                                    const Message* extendee,
+                                    internal::InternalMetadata* metadata,
+                                    internal::ParseContext* ctx);
+  const char* ParseMessageSetItem(const char* ptr, const MessageLite* extendee,
+                                  internal::InternalMetadata* metadata,
+                                  internal::ParseContext* ctx);
+  const char* ParseMessageSetItem(const char* ptr, const Message* extendee,
+                                  internal::InternalMetadata* metadata,
+                                  internal::ParseContext* ctx);
+
+  // Implemented in extension_set_inl.h to keep code out of the header file.
+  template <typename T>
+  const char* ParseFieldWithExtensionInfo(int number, bool was_packed_on_wire,
+                                          const ExtensionInfo& info,
+                                          internal::InternalMetadata* metadata,
+                                          const char* ptr,
+                                          internal::ParseContext* ctx);
+  template <typename Msg, typename T>
+  const char* ParseMessageSetItemTmpl(const char* ptr, const Msg* extendee,
+                                      internal::InternalMetadata* metadata,
+                                      internal::ParseContext* ctx);
+
+  // Hack:  RepeatedArenaPtrFieldBase declares ExtensionSetWithArenaString as a friend.  This
+  //   friendship should automatically extend to ExtensionSetWithArenaString::Extension, but
+  //   unfortunately some older compilers (e.g. GCC 3.4.4) do not implement this
+  //   correctly.  So, we must provide helpers for calling methods of that
+  //   class.
+
+  // Defined in extension_set_heavy.cc.
+  static inline size_t RepeatedMessage_SpaceUsedExcludingSelfLong(
+      RepeatedArenaPtrFieldBase* field);
+
+  KeyValue* flat_begin() {
+    assert(!is_large());
+    return map_.flat;
+  }
+  const KeyValue* flat_begin() const {
+    assert(!is_large());
+    return map_.flat;
+  }
+  KeyValue* flat_end() {
+    assert(!is_large());
+    return map_.flat + flat_size_;
+  }
+  const KeyValue* flat_end() const {
+    assert(!is_large());
+    return map_.flat + flat_size_;
+  }
+
+  Arena* arena_;
+
+  // Manual memory-management:
+  // map_.flat is an allocated array of flat_capacity_ elements.
+  // [map_.flat, map_.flat + flat_size_) is the currently-in-use prefix.
+  uint16_t flat_capacity_;
+  uint16_t flat_size_;  // negative int16_t(flat_size_) indicates is_large()
+  union AllocatedData {
+    KeyValue* flat;
+
+    // If flat_capacity_ > kMaximumFlatCapacity, switch to LargeMap,
+    // which guarantees O(n lg n) CPU but larger constant factors.
+    LargeMap* large;
+  } map_;
+
+  static void DeleteFlatMap(const KeyValue* flat, uint16_t flat_capacity);
+
+  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ExtensionSetWithArenaString);
+};
+
+constexpr ExtensionSetWithArenaString::ExtensionSetWithArenaString()
+    : arena_(nullptr), flat_capacity_(0), flat_size_(0), map_{nullptr} {}
+
+// These are just for convenience...
+inline void ExtensionSetWithArenaString::SetString(int number, FieldType type,
+                                    std::string value,
+                                    const FieldDescriptor* descriptor) {
+  //MutableString(number, type, descriptor)->assign(std::move(value));
+  MutableAccessor(number, type, descriptor)->assign(std::move(value));
+}
+inline void ExtensionSetWithArenaString::SetRepeatedString(int number, int index,
+                                            std::string value) {
+  //MutableRepeatedString(number, index)->assign(std::move(value));
+  MutableRepeatedAccessor(number, index)->assign(std::move(value));
+}
+inline void ExtensionSetWithArenaString::AddString(int number, FieldType type,
+                                    std::string value,
+                                    const FieldDescriptor* descriptor) {
+  //AddString(number, type, descriptor)->assign(std::move(value));
+  AddAccessor(number, type, descriptor)->assign(std::move(value));
+}
+// ===================================================================
+// Glue for generated extension accessors
+
+// -------------------------------------------------------------------
+// Template magic
+
+// First we have a set of classes representing "type traits" for different
+// field types.  A type traits class knows how to implement basic accessors
+// for extensions of a particular type given an ExtensionSetWithArenaString.  The signature
+// for a type traits class looks like this:
+//
+//   class TypeTraits {
+//    public:
+//     typedef ? ConstType;
+//     typedef ? MutableType;
+//     // TypeTraits for singular fields and repeated fields will define the
+//     // symbol "Singular" or "Repeated" respectively. These two symbols will
+//     // be used in extension accessors to distinguish between singular
+//     // extensions and repeated extensions. If the TypeTraits for the passed
+//     // in extension doesn't have the expected symbol defined, it means the
+//     // user is passing a repeated extension to a singular accessor, or the
+//     // opposite. In that case the C++ compiler will generate an error
+//     // message "no matching member function" to inform the user.
+//     typedef ? Singular
+//     typedef ? Repeated
+//
+//     static inline ConstType Get(int number, const ExtensionSetWithArenaString& set);
+//     static inline void Set(int number, ConstType value, ExtensionSetWithArenaString* set);
+//     static inline MutableType Mutable(int number, ExtensionSetWithArenaString* set);
+//
+//     // Variants for repeated fields.
+//     static inline ConstType Get(int number, const ExtensionSetWithArenaString& set,
+//                                 int index);
+//     static inline void Set(int number, int index,
+//                            ConstType value, ExtensionSetWithArenaString* set);
+//     static inline MutableType Mutable(int number, int index,
+//                                       ExtensionSetWithArenaString* set);
+//     static inline void Add(int number, ConstType value, ExtensionSetWithArenaString* set);
+//     static inline MutableType Add(int number, ExtensionSetWithArenaString* set);
+//     This is used by the ExtensionIdentifier constructor to register
+//     the extension at dynamic initialization.
+//     template <typename ExtendeeT>
+//     static void Register(int number, FieldType type, bool is_packed);
+//   };
+//
+// Not all of these methods make sense for all field types.  For example, the
+// "Mutable" methods only make sense for strings and messages, and the
+// repeated methods only make sense for repeated types.  So, each type
+// traits class implements only the set of methods from this signature that it
+// actually supports.  This will cause a compiler error if the user tries to
+// access an extension using a method that doesn't make sense for its type.
+// For example, if "foo" is an extension of type "optional int32", then if you
+// try to write code like:
+//   my_message.MutableExtension(foo)
+// you will get a compile error because PrimitiveTypeTraits<int32_t> does not
+// have a "Mutable()" method.
+
+// -------------------------------------------------------------------
+// ArenaStringTypeTraits
+
+// Strings support both Set() and Mutable().
+class PROTOBUF_EXPORT ArenaStringTypeTraits {
+ public:
+  typedef const std::string& ConstType;
+  //typedef std::string* MutableType;
+  typedef MutableStringType MutableType;
+  typedef ArenaStringTypeTraits Singular;
+
+  static inline const std::string& Get(int number, const ExtensionSetWithArenaString& set,
+                                       ConstType default_value) {
+    return set.GetString(number, default_value);
+  }
+  static inline const std::string* GetPtr(int number, const ExtensionSetWithArenaString& set,
+                                          ConstType default_value) {
+    return &Get(number, set, default_value);
+  }
+  static inline void Set(int number, FieldType field_type,
+                         const std::string& value, ExtensionSetWithArenaString* set) {
+    set->SetString(number, field_type, value, NULL);
+  }
+  static inline MutableType Mutable(int number, FieldType field_type,
+                                     ExtensionSetWithArenaString* set) {
+    return set->MutableString(number, field_type, NULL);
+  }
+  template <typename ExtendeeT>
+  static void Register(int number, FieldType type, bool is_packed) {
+    ExtensionSetWithArenaString::RegisterExtension(&ExtendeeT::default_instance(), number,
+                                    type, false, is_packed);
+  }
+};
+
+class PROTOBUF_EXPORT RepeatedArenaStringTypeTraits {
+ public:
+  typedef const std::string& ConstType;
+  //typedef std::string* MutableType;
+  typedef MutableStringType MutableType;
+  typedef RepeatedArenaStringTypeTraits Repeated;
+
+  typedef RepeatedArenaPtrField<std::string> RepeatedFieldType;
+
+  static inline const std::string& Get(int number, const ExtensionSetWithArenaString& set,
+                                       int index) {
+    return set.GetRepeatedString(number, index);
+  }
+  static inline const std::string* GetPtr(int number, const ExtensionSetWithArenaString& set,
+                                          int index) {
+    return &Get(number, set, index);
+  }
+  static inline const RepeatedArenaPtrField<std::string>* GetRepeatedPtr(
+      int number, const ExtensionSetWithArenaString& set) {
+    return &GetRepeated(number, set);
+  }
+  static inline void Set(int number, int index, const std::string& value,
+                         ExtensionSetWithArenaString* set) {
+    set->SetRepeatedString(number, index, value);
+  }
+  static inline MutableType Mutable(int number, int index, ExtensionSetWithArenaString* set) {
+    return set->MutableRepeatedString(number, index);
+  }
+  static inline void Add(int number, FieldType field_type, bool /*is_packed*/,
+                         const std::string& value, ExtensionSetWithArenaString* set) {
+    set->AddString(number, field_type, value, NULL);
+  }
+  static inline MutableType Add(int number, FieldType field_type,
+                                 ExtensionSetWithArenaString* set) {
+    return set->AddString(number, field_type, NULL);
+  }
+  static inline const RepeatedArenaPtrField<std::string>& GetRepeated(
+      int number, const ExtensionSetWithArenaString& set) {
+    return *reinterpret_cast<const RepeatedArenaPtrField<std::string>*>(
+        set.GetRawRepeatedField(number, GetDefaultRepeatedField()));
+  }
+
+  static inline RepeatedArenaPtrField<std::string>* MutableRepeated(
+      int number, FieldType field_type, bool is_packed, ExtensionSetWithArenaString* set) {
+    return reinterpret_cast<RepeatedArenaPtrField<std::string>*>(
+        set->MutableRawRepeatedField(number, field_type, is_packed, NULL));
+  }
+
+  static const RepeatedFieldType* GetDefaultRepeatedField();
+
+  template <typename ExtendeeT>
+  static void Register(int number, FieldType type, bool is_packed) {
+    ExtensionSetWithArenaString::RegisterExtension(&ExtendeeT::default_instance(), number,
+                                    type, true, is_packed);
+  }
+
+ private:
+  static void InitializeDefaultRepeatedFields();
+  static void DestroyDefaultRepeatedFields();
+};
+
+}  // namespace internal
+}  // namespace protobuf
+}  // namespace google
+
+#include <google/protobuf/port_undef.inc>
+
+#endif  // GOOGLE_PROTOBUF_PATCH_EXTENSION_SET_WITH_ARENASTRING_H__
diff --git a/src/google/protobuf/patch/inlined_arenastring_field.cc b/src/google/protobuf/patch/inlined_arenastring_field.cc
new file mode 100644
index 000000000..f8cf47897
--- /dev/null
+++ b/src/google/protobuf/patch/inlined_arenastring_field.cc
@@ -0,0 +1,122 @@
+// Protocol Buffers - Google's data interchange format
+// Copyright 2008 Google Inc.  All rights reserved.
+// https://developers.google.com/protocol-buffers/
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include <google/protobuf/patch/inlined_arenastring_field.h>
+
+#include <google/protobuf/arena.h>
+#include <google/protobuf/patch/arenastring.h>
+#include <google/protobuf/generated_message_util.h>
+#include <google/protobuf/message_lite.h>
+#include <google/protobuf/parse_context.h>
+
+// clang-format off
+#include <google/protobuf/port_def.inc>
+// clang-format on
+
+namespace google {
+namespace protobuf {
+namespace internal {
+
+
+std::string* InlinedArenaStringField::Mutable(const LazyStringWithPatch& /*default_value*/,
+                                         Arena* arena, bool donated,
+                                         uint32_t* donating_states,
+                                         uint32_t mask, MessageLite* msg) {
+  if (arena == nullptr || !donated) {
+    return UnsafeMutablePointer();
+  }
+  return MutableSlow(arena, donated, donating_states, mask, msg);
+}
+
+std::string* InlinedArenaStringField::Mutable(Arena* arena, bool donated,
+                                         uint32_t* donating_states,
+                                         uint32_t mask, MessageLite* msg) {
+  if (arena == nullptr || !donated) {
+    return UnsafeMutablePointer();
+  }
+  return MutableSlow(arena, donated, donating_states, mask, msg);
+}
+
+MaybeArenaStringAccessor InlinedArenaStringField::MutableAccessor(
+    Arena* arena, bool donated, uint32_t*, uint32_t, MessageLite*) {
+  return MaybeArenaStringAccessor(donated ? arena : nullptr, get_mutable());
+}
+
+std::string* InlinedArenaStringField::MutableSlow(::google::protobuf::Arena* arena,
+                                             bool donated,
+                                             uint32_t* donating_states,
+                                             uint32_t mask, MessageLite* msg) {
+  auto ptr = get_mutable();
+  StringPiece tmp {*ptr};
+  new (ptr) ::std::string(tmp);
+  *donating_states &= mask;
+  arena->OwnDestructor(ptr);
+  return ptr;
+}
+
+void InlinedArenaStringField::SetAllocated(const std::string* default_value,
+                                      std::string* value, Arena* arena,
+                                      bool donated, uint32_t* donating_states,
+                                      uint32_t mask, MessageLite* msg) {
+  if (donated) {
+    new (get_mutable()) ::std::string(::std::move(*value));
+    *donating_states &= mask;
+    arena->OwnDestructor(get_mutable());
+    delete value;
+  } else {
+    SetAllocatedNoArena(default_value, value);
+  }
+}
+
+std::string* InlinedArenaStringField::Release() {
+  auto* released = new std::string(std::move(*get_mutable()));
+  MaybeArenaStringAccessor::clear(get_mutable());
+  return released;
+}
+
+std::string* InlinedArenaStringField::Release(Arena* arena, bool donated) {
+  // We can not steal donated arena strings.
+  std::string* released = (arena != nullptr && donated)
+                              ? new std::string(*get_mutable())
+                              : new std::string(std::move(*get_mutable()));
+  MaybeArenaStringAccessor::clear(get_mutable());
+  return released;
+}
+
+void InlinedArenaStringField::ClearToDefault(const LazyStringWithPatch& default_value,
+                                        Arena* arena, bool donated) {
+  (void)arena;
+  get_mutable()->assign(default_value.get());
+}
+
+
+}  // namespace internal
+}  // namespace protobuf
+}  // namespace google
diff --git a/src/google/protobuf/patch/inlined_arenastring_field.h b/src/google/protobuf/patch/inlined_arenastring_field.h
new file mode 100644
index 000000000..7df628d7d
--- /dev/null
+++ b/src/google/protobuf/patch/inlined_arenastring_field.h
@@ -0,0 +1,490 @@
+// Protocol Buffers - Google's data interchange format
+// Copyright 2008 Google Inc.  All rights reserved.
+// https://developers.google.com/protocol-buffers/
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef GOOGLE_PROTOBUF_INLINED_ARENASTRING_FIELD_H__
+#define GOOGLE_PROTOBUF_INLINED_ARENASTRING_FIELD_H__
+
+#include <string>
+#include <utility>
+
+#include <google/protobuf/stubs/logging.h>
+#include <google/protobuf/stubs/common.h>
+#include <google/protobuf/port.h>
+#include <google/protobuf/stubs/strutil.h>
+#include <google/protobuf/patch/arenastring.h>
+#include <google/protobuf/message_lite.h>
+
+// Must be included last.
+#include <google/protobuf/port_def.inc>
+
+#ifdef SWIG
+#error "You cannot SWIG proto headers"
+#endif
+
+namespace google {
+namespace protobuf {
+
+class Arena;
+
+namespace internal {
+
+// InlinedArenaStringField wraps a std::string instance and exposes an API similar to
+// ArenaStringPtr's wrapping of a std::string* instance.
+//
+// default_value parameters are taken for consistency with ArenaStringPtr, but
+// are not used for most methods. With inlining, these should be removed from
+// the generated binary.
+//
+// InlinedArenaStringField has a donating mechanism that allows string buffer
+// allocated on arena. A string is donated means both the string container and
+// the data buffer are on arena. The donating mechanism here is similar to the
+// one in ArenaStringPtr with some differences:
+//
+// When an InlinedArenaStringField is constructed, the donating state is true. This
+// is because the string container is directly stored in the message on the
+// arena:
+//
+//   Construction: donated=true
+//   Arena:
+//   +-----------------------+
+//   |Message foo:           |
+//   | +-------------------+ |
+//   | |InlinedArenaStringField:| |
+//   | | +-----+           | |
+//   | | | | | |           | |
+//   | | +-----+           | |
+//   | +-------------------+ |
+//   +-----------------------+
+//
+// When lvalue Set is called, the donating state is still true. String data will
+// be allocated on the arena:
+//
+//   Lvalue Set: donated=true
+//   Arena:
+//   +-----------------------+
+//   |Message foo:           |
+//   | +-------------------+ |
+//   | |InlinedArenaStringField:| |
+//   | | +-----+           | |
+//   | | | | | |           | |
+//   | | +|----+           | |
+//   | +--|----------------+ |
+//   |    V                  |
+//   |  +----------------+   |
+//   |  |'f','o','o',... |   |
+//   |  +----------------+   |
+//   +-----------------------+
+//
+// Some operations will undonate a donated string, including: Mutable,
+// SetAllocated, Rvalue Set, and Swap with a non-donated string.
+//
+// For more details of the donating states transitions, go/pd-inlined-string.
+class PROTOBUF_EXPORT InlinedArenaStringField {
+ public:
+  InlinedArenaStringField() { Init(); }
+  inline void Init() { new (get_mutable()) std::string(); }
+  // Add the dummy parameter just to make InlinedArenaStringField(nullptr)
+  // unambiguous.
+  constexpr InlinedArenaStringField(
+      const ExplicitlyConstructed<std::string>* /*default_value*/,
+      bool /*dummy*/)
+      : value_{} {}
+  explicit InlinedArenaStringField(const std::string& default_value);
+  explicit InlinedArenaStringField(Arena* arena);
+  ~InlinedArenaStringField() { Destruct(); }
+
+  // Lvalue Set. To save space, we pack the donating states of multiple
+  // InlinedArenaStringFields into an uint32_t `donating_states`. The `mask`
+  // indicates the position of the bit for this InlinedArenaStringField. `donated` is
+  // whether this field is donated.
+  //
+  // The caller should guarantee that:
+  //
+  //   `donated == ((donating_states & ~mask) != 0)`
+  //
+  // This method never changes the `donating_states`.
+  template <typename T>
+  void Set(T&& value, Arena* arena, bool donated,
+           uint32_t* donating_states, uint32_t mask, MessageLite* msg);
+
+  void Set(const char* str, size_t size, ::google::protobuf::Arena* arena, bool donated,
+           uint32_t* donating_states, uint32_t mask, MessageLite* msg);
+
+  template <typename T>
+  void SetBytes(T&& value, Arena* arena, bool donated,
+                uint32_t* donating_states, uint32_t mask, MessageLite* msg);
+
+  void SetBytes(const void* p, size_t size, ::google::protobuf::Arena* arena,
+                bool donated, uint32_t* donating_states, uint32_t mask,
+                MessageLite* msg);
+
+  template <typename RefWrappedType>
+  void SetBytes(std::reference_wrapper<RefWrappedType> const_string_ref,
+                ::google::protobuf::Arena* arena, bool donated, uint32_t* donating_states,
+                uint32_t mask, MessageLite* msg);
+
+  PROTOBUF_NDEBUG_INLINE void SetNoArena(StringPiece value);
+  PROTOBUF_NDEBUG_INLINE void SetNoArena(std::string&& value);
+
+  // Basic accessors.
+  PROTOBUF_NDEBUG_INLINE const std::string& Get() const { return GetNoArena(); }
+  PROTOBUF_NDEBUG_INLINE const std::string& GetNoArena() const;
+
+  // Mutable returns a std::string* instance that is heap-allocated. If this
+  // field is donated, this method undonates this field by mutating the
+  // `donating_states` according to `mask`, and copies the content of the
+  // original string to the returning string.
+  std::string* Mutable(Arena* arena, bool donated, uint32_t* donating_states,
+                       uint32_t mask, MessageLite* msg);
+  MaybeArenaStringAccessor MutableAccessor(Arena* arena, bool donated,
+                                           uint32_t*, uint32_t, MessageLite*);
+  std::string* Mutable(const LazyStringWithPatch& default_value, Arena* arena,
+                       bool donated, uint32_t* donating_states, uint32_t mask,
+                       MessageLite* msg);
+
+  // Mutable(nullptr_t) is an overload to explicitly support Mutable(nullptr)
+  // calls used by the internal parser logic. This provides API equivalence with
+  // ArenaStringPtr, while still protecting against calls with arena pointers.
+  std::string* Mutable(std::nullptr_t);
+  std::string* MutableNoCopy(std::nullptr_t);
+
+  // Takes a std::string that is heap-allocated, and takes ownership. The
+  // std::string's destructor is registered with the arena. Used to implement
+  // set_allocated_<field> in generated classes.
+  //
+  // If this field is donated, this method undonates this field by mutating the
+  // `donating_states` according to `mask`.
+  void SetAllocated(const std::string* default_value, std::string* value,
+                    Arena* arena, bool donated, uint32_t* donating_states,
+                    uint32_t mask, MessageLite* msg);
+
+  void SetAllocatedNoArena(const std::string* default_value,
+                           std::string* value);
+
+  // Release returns a std::string* instance that is heap-allocated and is not
+  // Own()'d by any arena. If the field is not set, this returns nullptr. The
+  // caller retains ownership. Clears this field back to nullptr state. Used to
+  // implement release_<field>() methods on generated classes.
+  PROTOBUF_MUST_USE_RESULT std::string* Release(Arena* arena, bool donated);
+  PROTOBUF_MUST_USE_RESULT std::string* Release();
+
+  // --------------------------------------------------------
+  // Below functions will be removed in subsequent code change
+  // --------------------------------------------------------
+#ifdef DEPRECATED_METHODS_TO_BE_DELETED
+  PROTOBUF_MUST_USE_RESULT std::string* Release(const std::string*, Arena* arena,
+                                          bool donated) {
+    return Release(arena, donated);
+  }
+
+  PROTOBUF_MUST_USE_RESULT std::string* ReleaseNonDefault(const std::string*,
+                                                    Arena* arena) {
+    return Release();
+  }
+
+  std::string* ReleaseNonDefaultNoArena(const std::string* default_value) {
+    return Release();
+  }
+
+  void Set(const std::string*, ConstStringParam value, Arena* arena,
+           bool donated, uint32_t* donating_states, uint32_t mask,
+           MessageLite* msg) {
+    Set(value, arena, donated, donating_states, mask, msg);
+  }
+
+  void Set(const std::string*, std::string&& value, Arena* arena, bool donated,
+           uint32_t* donating_states, uint32_t mask, MessageLite* msg) {
+    Set(std::move(value), arena, donated, donating_states, mask, msg);
+  }
+
+
+  template <typename FirstParam>
+  void Set(FirstParam, const char* str, ::google::protobuf::Arena* arena, bool donated,
+           uint32_t* donating_states, uint32_t mask, MessageLite* msg) {
+    Set(str, arena, donated, donating_states, mask, msg);
+  }
+
+  template <typename FirstParam>
+  void Set(FirstParam p1, const char* str, size_t size, ::google::protobuf::Arena* arena,
+           bool donated, uint32_t* donating_states, uint32_t mask,
+           MessageLite* msg) {
+    Set(str, size, arena, donated, donating_states, mask, msg);
+  }
+
+  template <typename FirstParam, typename RefWrappedType>
+  void Set(FirstParam p1,
+           std::reference_wrapper<RefWrappedType> const_string_ref,
+           ::google::protobuf::Arena* arena, bool donated, uint32_t* donating_states,
+           uint32_t mask, MessageLite* msg) {
+    Set(const_string_ref, arena, donated, donating_states, mask, msg);
+  }
+
+  void SetBytes(const std::string*, ConstStringParam value, Arena* arena,
+                bool donated, uint32_t* donating_states, uint32_t mask,
+                MessageLite* msg) {
+    Set(value, arena, donated, donating_states, mask, msg);
+  }
+
+
+  void SetBytes(const std::string*, std::string&& value, Arena* arena,
+                bool donated, uint32_t* donating_states, uint32_t mask,
+                MessageLite* msg) {
+    Set(std::move(value), arena, donated, donating_states, mask, msg);
+  }
+
+  template <typename FirstParam>
+  void SetBytes(FirstParam p1, const char* str, ::google::protobuf::Arena* arena,
+                bool donated, uint32_t* donating_states, uint32_t mask,
+                MessageLite* msg) {
+    SetBytes(str, arena, donated, donating_states, mask, msg);
+  }
+
+  template <typename FirstParam>
+  void SetBytes(FirstParam p1, const void* p, size_t size,
+                ::google::protobuf::Arena* arena, bool donated, uint32_t* donating_states,
+                uint32_t mask, MessageLite* msg) {
+    SetBytes(p, size, arena, donated, donating_states, mask, msg);
+  }
+
+  template <typename FirstParam, typename RefWrappedType>
+  void SetBytes(FirstParam p1,
+                std::reference_wrapper<RefWrappedType> const_string_ref,
+                ::google::protobuf::Arena* arena, bool donated, uint32_t* donating_states,
+                uint32_t mask, MessageLite* msg) {
+    SetBytes(const_string_ref.get(), arena, donated, donating_states, mask,
+             msg);
+  }
+
+  void SetNoArena(const std::string*, StringPiece value) {
+    SetNoArena(value);
+  }
+  void SetNoArena(const std::string*, std::string&& value) {
+    SetNoArena(std::move(value));
+  }
+
+  std::string* Mutable(ArenaStringPtr::EmptyDefault, Arena* arena, bool donated,
+                       uint32_t* donating_states, uint32_t mask,
+                       MessageLite* msg) {
+    return Mutable(arena, donated, donating_states, mask, msg);
+  }
+
+  PROTOBUF_NDEBUG_INLINE std::string* MutableNoArenaNoDefault(
+      const std::string* /*default_value*/) {
+    return MutableNoCopy(nullptr);
+  }
+
+#endif  // DEPRECATED_METHODS_TO_BE_DELETED
+
+  // Arena-safety semantics: this is guarded by the logic in
+  // Swap()/UnsafeArenaSwap() at the message level, so this method is
+  // 'unsafe' if called directly.
+  inline PROTOBUF_NDEBUG_INLINE static void InternalSwap(
+      InlinedArenaStringField* lhs, Arena* lhs_arena, bool lhs_arena_dtor_registered,
+      MessageLite* lhs_msg,  //
+      InlinedArenaStringField* rhs, Arena* rhs_arena, bool rhs_arena_dtor_registered,
+      MessageLite* rhs_msg);
+
+  // Frees storage (if not on an arena).
+  PROTOBUF_NDEBUG_INLINE void Destroy(const std::string* default_value,
+                                      Arena* arena) {
+    if (arena == nullptr) {
+      DestroyNoArena(default_value);
+    }
+  }
+  PROTOBUF_NDEBUG_INLINE void DestroyNoArena(const std::string* default_value);
+
+  // Clears content, but keeps allocated std::string, to avoid the overhead of
+  // heap operations. After this returns, the content (as seen by the user) will
+  // always be the empty std::string.
+  PROTOBUF_NDEBUG_INLINE void ClearToEmpty() { ClearNonDefaultToEmpty(); }
+  PROTOBUF_NDEBUG_INLINE void ClearNonDefaultToEmpty() {
+    MaybeArenaStringAccessor::clear(get_mutable());
+  }
+
+  // Clears content, but keeps allocated std::string if arena != nullptr, to
+  // avoid the overhead of heap operations. After this returns, the content (as
+  // seen by the user) will always be equal to |default_value|.
+  void ClearToDefault(const LazyStringWithPatch& default_value, Arena* arena,
+                      bool donated);
+
+  // Generated code / reflection only! Returns a mutable pointer to the string.
+  PROTOBUF_NDEBUG_INLINE std::string* UnsafeMutablePointer();
+
+  // InlinedArenaStringField doesn't have things like the `default_value` pointer in
+  // ArenaStringPtr.
+  static constexpr bool IsDefault() { return false; }
+  static constexpr bool IsDefault(const std::string*) { return false; }
+
+ private:
+  void Destruct() { get_mutable()->~basic_string(); }
+
+  PROTOBUF_NDEBUG_INLINE std::string* get_mutable();
+  PROTOBUF_NDEBUG_INLINE const std::string* get_const() const;
+
+  alignas(std::string) char value_[sizeof(std::string)];
+
+  std::string* MutableSlow(::google::protobuf::Arena* arena, bool donated,
+                           uint32_t* donating_states, uint32_t mask,
+                           MessageLite* msg);
+
+
+  // When constructed in an Arena, we want our destructor to be skipped.
+  friend class ::google::protobuf::Arena;
+  typedef void InternalArenaConstructable_;
+  typedef void DestructorSkippable_;
+};
+
+inline std::string* InlinedArenaStringField::get_mutable() {
+  return reinterpret_cast<std::string*>(&value_);
+}
+
+inline const std::string* InlinedArenaStringField::get_const() const {
+  return reinterpret_cast<const std::string*>(&value_);
+}
+
+inline InlinedArenaStringField::InlinedArenaStringField(
+    const std::string& default_value) {
+  new (get_mutable()) std::string(default_value);
+}
+
+
+inline InlinedArenaStringField::InlinedArenaStringField(Arena* /*arena*/) { Init(); }
+
+inline const std::string& InlinedArenaStringField::GetNoArena() const {
+  return *get_const();
+}
+
+inline void InlinedArenaStringField::SetAllocatedNoArena(
+    const std::string* /*default_value*/, std::string* value) {
+  if (value == nullptr) {
+    // Currently, inlined string field can't have non empty default.
+    get_mutable()->clear();
+  } else {
+    get_mutable()->assign(std::move(*value));
+    delete value;
+  }
+}
+
+inline void InlinedArenaStringField::DestroyNoArena(const std::string*) {
+  // This is invoked from the generated message's ArenaDtor, which is used to
+  // clean up objects not allocated on the Arena.
+  this->~InlinedArenaStringField();
+}
+
+inline void InlinedArenaStringField::SetNoArena(StringPiece value) {
+  get_mutable()->assign(value.data(), value.length());
+}
+
+inline void InlinedArenaStringField::SetNoArena(std::string&& value) {
+  get_mutable()->assign(std::move(value));
+}
+
+// Caller should make sure rhs_arena allocated rhs, and lhs_arena allocated lhs.
+inline PROTOBUF_NDEBUG_INLINE void InlinedArenaStringField::InternalSwap(
+    InlinedArenaStringField* lhs, Arena* lhs_arena, bool lhs_arena_dtor_registered,
+    MessageLite* lhs_msg,  //
+    InlinedArenaStringField* rhs, Arena* rhs_arena, bool rhs_arena_dtor_registered,
+    MessageLite* rhs_msg) {
+#if GOOGLE_PROTOBUF_INTERNAL_DONATE_STEAL_INLINE
+  lhs->get_mutable()->swap(*rhs->get_mutable());
+  if (!lhs_arena_dtor_registered && rhs_arena_dtor_registered) {
+    lhs_msg->OnDemandRegisterArenaDtor(lhs_arena);
+  } else if (lhs_arena_dtor_registered && !rhs_arena_dtor_registered) {
+    rhs_msg->OnDemandRegisterArenaDtor(rhs_arena);
+  }
+#else
+  (void)lhs_arena;
+  (void)rhs_arena;
+  (void)lhs_arena_dtor_registered;
+  (void)rhs_arena_dtor_registered;
+  (void)lhs_msg;
+  (void)rhs_msg;
+  lhs->get_mutable()->swap(*rhs->get_mutable());
+#endif
+}
+
+template <typename T>
+inline void InlinedArenaStringField::Set(T&& value, Arena* arena,
+                                     bool donated, uint32_t* donating_states,
+                                     uint32_t mask, MessageLite* msg) {
+  MutableAccessor(arena, donated, donating_states, mask, msg) =
+      std::forward<T>(value);
+} 
+
+inline void InlinedArenaStringField::Set(const char* str, size_t size,
+                                    ::google::protobuf::Arena* arena, bool donated,
+                                    uint32_t* donating_states, uint32_t mask,
+                                    MessageLite* msg) {
+  Set(StringPiece {str, size}, arena, donated, donating_states, mask, msg);
+}
+
+template <typename T>
+inline void InlinedArenaStringField::SetBytes(T&& value, Arena* arena,
+                                         bool donated,
+                                         uint32_t* donating_states,
+                                         uint32_t mask, MessageLite* msg) {
+  Set(::std::forward<T>(value), arena, donated, donating_states, mask, msg);
+}
+
+inline void InlinedArenaStringField::SetBytes(const void* p, size_t size,
+                                         ::google::protobuf::Arena* arena, bool donated,
+                                         uint32_t* donating_states,
+                                         uint32_t mask, MessageLite* msg) {
+  Set(static_cast<const char*>(p), size, arena, donated, donating_states, mask,
+      msg);
+}
+
+template <typename RefWrappedType>
+inline void InlinedArenaStringField::SetBytes(
+    std::reference_wrapper<RefWrappedType> const_string_ref,
+    ::google::protobuf::Arena* arena, bool donated, uint32_t* donating_states,
+    uint32_t mask, MessageLite* msg) {
+  Set(const_string_ref.get(), arena, donated, donating_states, mask, msg);
+}
+
+inline std::string* InlinedArenaStringField::UnsafeMutablePointer() {
+  return get_mutable();
+}
+
+inline std::string* InlinedArenaStringField::Mutable(std::nullptr_t) {
+  return get_mutable();
+}
+
+inline std::string* InlinedArenaStringField::MutableNoCopy(std::nullptr_t) {
+  return get_mutable();
+}
+
+}  // namespace internal
+}  // namespace protobuf
+}  // namespace google
+
+#include <google/protobuf/port_undef.inc>
+
+#endif  // GOOGLE_PROTOBUF_INLINED_ARENASTRING_FIELD_H__
diff --git a/src/google/protobuf/patch/repeated_arenastring_field.cc b/src/google/protobuf/patch/repeated_arenastring_field.cc
new file mode 100644
index 000000000..9f4d40172
--- /dev/null
+++ b/src/google/protobuf/patch/repeated_arenastring_field.cc
@@ -0,0 +1,160 @@
+// Protocol Buffers - Google's data interchange format
+// Copyright 2008 Google Inc.  All rights reserved.
+// https://developers.google.com/protocol-buffers/
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Author: kenton@google.com (Kenton Varda)
+//  Based on original Protocol Buffers design by
+//  Sanjay Ghemawat, Jeff Dean, and others.
+
+#include <algorithm>
+#include <google/protobuf/stubs/logging.h>
+#include <google/protobuf/stubs/common.h>
+#include <google/protobuf/implicit_weak_message.h>
+#include <google/protobuf/repeated_field.h>
+#include <google/protobuf/patch/repeated_arenastring_field.h>
+#include <google/protobuf/port.h>
+
+// Must be included last.
+#include <google/protobuf/port_def.inc>
+
+namespace google {
+namespace protobuf {
+
+namespace internal {
+
+void** RepeatedArenaPtrFieldBase::InternalExtend(int extend_amount) {
+  int new_size = current_size_ + extend_amount;
+  if (total_size_ >= new_size) {
+    // N.B.: rep_ is non-NULL because extend_amount is always > 0, hence
+    // total_size must be non-zero since it is lower-bounded by new_size.
+    return &rep_->elements[current_size_];
+  }
+  Rep* old_rep = rep_;
+  Arena* arena = GetArena();
+  new_size = std::max(internal::kRepeatedFieldLowerClampLimit,
+                      std::max(total_size_ * 2, new_size));
+  GOOGLE_CHECK_LE(static_cast<int64_t>(new_size),
+           static_cast<int64_t>(
+               (std::numeric_limits<size_t>::max() - kRepHeaderSize) /
+               sizeof(old_rep->elements[0])))
+      << "Requested size is too large to fit into size_t.";
+  size_t bytes = kRepHeaderSize + sizeof(old_rep->elements[0]) * new_size;
+  if (arena == NULL) {
+    rep_ = reinterpret_cast<Rep*>(::operator new(bytes));
+  } else {
+    rep_ = reinterpret_cast<Rep*>(Arena::CreateArray<char>(arena, bytes));
+  }
+#if defined(__GXX_DELETE_WITH_SIZE__) || defined(__cpp_sized_deallocation)
+  const int old_total_size = total_size_;
+#endif
+  total_size_ = new_size;
+  if (old_rep && old_rep->allocated_size > 0) {
+    memcpy(rep_->elements, old_rep->elements,
+           old_rep->allocated_size * sizeof(rep_->elements[0]));
+    rep_->allocated_size = old_rep->allocated_size;
+  } else {
+    rep_->allocated_size = 0;
+  }
+  if (arena == NULL) {
+#if defined(__GXX_DELETE_WITH_SIZE__) || defined(__cpp_sized_deallocation)
+    const size_t old_size =
+        old_total_size * sizeof(rep_->elements[0]) + kRepHeaderSize;
+    ::operator delete(static_cast<void*>(old_rep), old_size);
+#else
+    ::operator delete(static_cast<void*>(old_rep));
+#endif
+  }
+  return &rep_->elements[current_size_];
+}
+
+void RepeatedArenaPtrFieldBase::Reserve(int new_size) {
+  if (new_size > current_size_) {
+    InternalExtend(new_size - current_size_);
+  }
+}
+
+void RepeatedArenaPtrFieldBase::DestroyProtos() {
+  GOOGLE_DCHECK(rep_);
+  GOOGLE_DCHECK(arena_ == nullptr);
+  int n = rep_->allocated_size;
+  void* const* elements = rep_->elements;
+  for (int i = 0; i < n; i++) {
+    delete static_cast<MessageLite*>(elements[i]);
+  }
+  const size_t size = total_size_ * sizeof(elements[0]) + kRepHeaderSize;
+  internal::SizedDelete(rep_, size);
+  rep_ = nullptr;
+}
+
+void* RepeatedArenaPtrFieldBase::AddOutOfLineHelper(void* obj) {
+  if (!rep_ || rep_->allocated_size == total_size_) {
+    InternalExtend(1);  // Equivalent to "Reserve(total_size_ + 1)"
+  }
+  ++rep_->allocated_size;
+  rep_->elements[current_size_++] = obj;
+  return obj;
+}
+
+void RepeatedArenaPtrFieldBase::CloseGap(int start, int num) {
+  if (rep_ == nullptr) return;
+  // Close up a gap of "num" elements starting at offset "start".
+  for (int i = start + num; i < rep_->allocated_size; ++i)
+    rep_->elements[i - num] = rep_->elements[i];
+  current_size_ -= num;
+  rep_->allocated_size -= num;
+}
+
+MessageLite* RepeatedArenaPtrFieldBase::AddWeak(const MessageLite* prototype) {
+  if (rep_ != nullptr && current_size_ < rep_->allocated_size) {
+    return reinterpret_cast<MessageLite*>(rep_->elements[current_size_++]);
+  }
+  if (!rep_ || rep_->allocated_size == total_size_) {
+    Reserve(total_size_ + 1);
+  }
+  ++rep_->allocated_size;
+  MessageLite* result = prototype
+                            ? prototype->New(arena_)
+                            : Arena::CreateMessage<ImplicitWeakMessage>(arena_);
+  rep_->elements[current_size_++] = result;
+  return result;
+}
+
+}  // namespace internal
+
+}  // namespace protobuf
+}  // namespace google
+
+
+namespace google {
+namespace protobuf {
+template class PROTOBUF_EXPORT_TEMPLATE_DEFINE RepeatedArenaPtrField<std::string>;
+}  // namespace protobuf
+}  // namespace google
+
+#include <google/protobuf/port_undef.inc>
diff --git a/src/google/protobuf/patch/repeated_arenastring_field.h b/src/google/protobuf/patch/repeated_arenastring_field.h
new file mode 100644
index 000000000..7893eb391
--- /dev/null
+++ b/src/google/protobuf/patch/repeated_arenastring_field.h
@@ -0,0 +1,2176 @@
+// Protocol Buffers - Google's data interchange format
+// Copyright 2008 Google Inc.  All rights reserved.
+// https://developers.google.com/protocol-buffers/
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Author: kenton@google.com (Kenton Varda)
+//  Based on original Protocol Buffers design by
+//  Sanjay Ghemawat, Jeff Dean, and others.
+//
+// RepeatedField and RepeatedArenaPtrField are used by generated protocol message
+// classes to manipulate repeated fields.  These classes are very similar to
+// STL's vector, but include a number of optimizations found to be useful
+// specifically in the case of Protocol Buffers.  RepeatedArenaPtrField is
+// particularly different from STL vector as it manages ownership of the
+// pointers that it contains.
+//
+// This header covers RepeatedArenaPtrField.
+
+// IWYU pragma: private, include "net/proto2/public/repeated_field.h"
+
+#ifndef GOOGLE_PROTOBUF_REPEATED_ARENASTRING_FIELD_H__
+#define GOOGLE_PROTOBUF_REPEATED_ARENASTRING_FIELD_H__
+
+#include <utility>
+
+#ifdef _MSC_VER
+// This is required for min/max on VS2013 only.
+#include <algorithm>
+#endif
+
+#include <iterator>
+#include <limits>
+#include <string>
+#include <type_traits>
+
+#include <google/protobuf/stubs/logging.h>
+#include <google/protobuf/stubs/common.h>
+#include <google/protobuf/arena.h>
+#include <google/protobuf/patch/arenastring.h>
+#include <google/protobuf/port.h>
+#include <google/protobuf/message_lite.h>
+
+
+// Must be included last.
+#include <google/protobuf/port_def.inc>
+
+#ifdef SWIG
+#error "You cannot SWIG proto headers"
+#endif
+
+namespace google {
+namespace protobuf {
+
+class Message;
+class Reflection;
+
+template <typename T>
+struct WeakRepeatedArenaPtrField;
+
+namespace internal {
+
+class MergePartialFromCodedStreamHelper;
+class SwapFieldHelper;
+
+
+}  // namespace internal
+
+namespace internal {
+template <typename It>
+class RepeatedArenaPtrIterator;
+template <typename It, typename VoidPtr>
+class RepeatedArenaPtrOverPtrsIterator;
+}  // namespace internal
+
+namespace internal {
+
+// This is the common base class for RepeatedArenaPtrFields.  It deals only in void*
+// pointers.  Users should not use this interface directly.
+//
+// The methods of this interface correspond to the methods of RepeatedArenaPtrField,
+// but may have a template argument called TypeHandler.  Its signature is:
+//   class TypeHandler {
+//    public:
+//     typedef MyType Type;
+//     static Type* New();
+//     static Type* NewFromPrototype(const Type* prototype,
+//                                       Arena* arena);
+//     static void Delete(Type*);
+//     static void Clear(Type*);
+//     static void Merge(const Type& from, Type* to);
+//
+//     // Only needs to be implemented if SpaceUsedExcludingSelf() is called.
+//     static int SpaceUsedLong(const Type&);
+//   };
+class PROTOBUF_EXPORT RepeatedArenaPtrFieldBase {
+ protected:
+  constexpr RepeatedArenaPtrFieldBase()
+      : arena_(nullptr), current_size_(0), total_size_(0), rep_(nullptr) {}
+  explicit RepeatedArenaPtrFieldBase(Arena* arena)
+      : arena_(arena), current_size_(0), total_size_(0), rep_(nullptr) {}
+
+  RepeatedArenaPtrFieldBase(const RepeatedArenaPtrFieldBase&) = delete;
+  RepeatedArenaPtrFieldBase& operator=(const RepeatedArenaPtrFieldBase&) = delete;
+
+  ~RepeatedArenaPtrFieldBase() {
+#ifndef NDEBUG
+    // Try to trigger segfault / asan failure in non-opt builds. If arena_
+    // lifetime has ended before the destructor.
+    if (arena_) (void)arena_->SpaceAllocated();
+#endif
+  }
+
+  bool empty() const { return current_size_ == 0; }
+  int size() const { return current_size_; }
+  int Capacity() const { return total_size_; }
+
+  template <typename TypeHandler>
+  const typename TypeHandler::Type* at(int index) const {
+    GOOGLE_CHECK_GE(index, 0);
+    GOOGLE_CHECK_LT(index, current_size_);
+    return cast<TypeHandler>(rep_->elements[index]);
+  }
+
+  template <typename TypeHandler>
+  typename TypeHandler::Type* at(int index) {
+    GOOGLE_CHECK_GE(index, 0);
+    GOOGLE_CHECK_LT(index, current_size_);
+    return cast<TypeHandler>(rep_->elements[index]);
+  }
+
+  template <typename TypeHandler>
+  typename TypeHandler::Type* Mutable(int index) {
+    GOOGLE_DCHECK_GE(index, 0);
+    GOOGLE_DCHECK_LT(index, current_size_);
+    return cast<TypeHandler>(rep_->elements[index]);
+  }
+
+  template <typename TypeHandler>
+  typename TypeHandler::Type* Add(
+      const typename TypeHandler::Type* prototype = nullptr) {
+    if (rep_ != nullptr && current_size_ < rep_->allocated_size) {
+      return cast<TypeHandler>(rep_->elements[current_size_++]);
+    }
+    typename TypeHandler::Type* result =
+        TypeHandler::NewFromPrototype(prototype, arena_);
+    return reinterpret_cast<typename TypeHandler::Type*>(
+        AddOutOfLineHelper(result));
+  }
+
+  template <
+      typename TypeHandler,
+      typename std::enable_if<TypeHandler::Movable::value>::type* = nullptr>
+  inline void Add(typename TypeHandler::Type&& value) {
+    if (rep_ != nullptr && current_size_ < rep_->allocated_size) {
+      *cast<TypeHandler>(rep_->elements[current_size_++]) = std::move(value);
+      return;
+    }
+    if (!rep_ || rep_->allocated_size == total_size_) {
+      Reserve(total_size_ + 1);
+    }
+    ++rep_->allocated_size;
+    typename TypeHandler::Type* result =
+        TypeHandler::New(arena_, std::move(value));
+    rep_->elements[current_size_++] = result;
+  }
+
+  template <typename TypeHandler>
+  void Delete(int index) {
+    GOOGLE_DCHECK_GE(index, 0);
+    GOOGLE_DCHECK_LT(index, current_size_);
+    TypeHandler::Delete(cast<TypeHandler>(rep_->elements[index]), arena_);
+  }
+
+  // Must be called from destructor.
+  template <typename TypeHandler>
+  void Destroy() {
+    if (rep_ != nullptr && arena_ == nullptr) {
+      int n = rep_->allocated_size;
+      void* const* elements = rep_->elements;
+      for (int i = 0; i < n; i++) {
+        TypeHandler::Delete(cast<TypeHandler>(elements[i]), nullptr);
+      }
+      const size_t size = total_size_ * sizeof(elements[0]) + kRepHeaderSize;
+      internal::SizedDelete(rep_, size);
+    }
+    rep_ = nullptr;
+  }
+
+  bool NeedsDestroy() const { return rep_ != nullptr && arena_ == nullptr; }
+  void DestroyProtos();  // implemented in the cc file
+
+ public:
+  // The next few methods are public so that they can be called from generated
+  // code when implicit weak fields are used, but they should never be called by
+  // application code.
+
+  template <typename TypeHandler>
+  const typename TypeHandler::Type* Get(int index) const {
+    GOOGLE_DCHECK_GE(index, 0);
+    GOOGLE_DCHECK_LT(index, current_size_);
+    return cast<TypeHandler>(rep_->elements[index]);
+  }
+
+  // Creates and adds an element using the given prototype, without introducing
+  // a link-time dependency on the concrete message type. This method is used to
+  // implement implicit weak fields. The prototype may be nullptr, in which case
+  // an ImplicitWeakMessage will be used as a placeholder.
+  MessageLite* AddWeak(const MessageLite* prototype);
+
+  template <typename TypeHandler>
+  void Clear() {
+    const int n = current_size_;
+    GOOGLE_DCHECK_GE(n, 0);
+    if (n > 0) {
+      void* const* elements = rep_->elements;
+      int i = 0;
+      do {
+        TypeHandler::Clear(cast<TypeHandler>(elements[i++]));
+      } while (i < n);
+      current_size_ = 0;
+    }
+  }
+
+  template <typename TypeHandler>
+  void MergeFrom(const RepeatedArenaPtrFieldBase& other) {
+    // To avoid unnecessary code duplication and reduce binary size, we use a
+    // layered approach to implementing MergeFrom(). The toplevel method is
+    // templated, so we get a small thunk per concrete message type in the
+    // binary. This calls a shared implementation with most of the logic,
+    // passing a function pointer to another type-specific piece of code that
+    // calls the object-allocate and merge handlers.
+    GOOGLE_DCHECK_NE(&other, this);
+    if (other.current_size_ == 0) return;
+    MergeFromInternal(other,
+                      &RepeatedArenaPtrFieldBase::MergeFromInnerLoop<TypeHandler>);
+  }
+
+  inline void InternalSwap(RepeatedArenaPtrFieldBase* rhs) {
+    GOOGLE_DCHECK(this != rhs);
+
+    // Swap all fields at once.
+    auto temp = std::make_tuple(rhs->arena_, rhs->current_size_,
+                                rhs->total_size_, rhs->rep_);
+    std::tie(rhs->arena_, rhs->current_size_, rhs->total_size_, rhs->rep_) =
+        std::make_tuple(arena_, current_size_, total_size_, rep_);
+    std::tie(arena_, current_size_, total_size_, rep_) = temp;
+  }
+
+ protected:
+  template <typename TypeHandler>
+  void RemoveLast() {
+    GOOGLE_DCHECK_GT(current_size_, 0);
+    TypeHandler::Clear(cast<TypeHandler>(rep_->elements[--current_size_]));
+  }
+
+  template <typename TypeHandler>
+  void CopyFrom(const RepeatedArenaPtrFieldBase& other) {
+    if (&other == this) return;
+    RepeatedArenaPtrFieldBase::Clear<TypeHandler>();
+    RepeatedArenaPtrFieldBase::MergeFrom<TypeHandler>(other);
+  }
+
+  void CloseGap(int start, int num);  // implemented in the cc file
+
+  void Reserve(int new_size);  // implemented in the cc file
+
+  template <typename TypeHandler>
+  static inline typename TypeHandler::Type* copy(
+      typename TypeHandler::Type* value) {
+    auto* new_value = TypeHandler::NewFromPrototype(value, nullptr);
+    TypeHandler::Merge(nullptr, value, new_value);
+    return new_value;
+  }
+
+  // Used for constructing iterators.
+  void* const* raw_data() const { return rep_ ? rep_->elements : nullptr; }
+  void** raw_mutable_data() const {
+    return rep_ ? const_cast<void**>(rep_->elements) : nullptr;
+  }
+
+  template <typename TypeHandler>
+  typename TypeHandler::Type** mutable_data() {
+    // TODO(kenton):  Breaks C++ aliasing rules.  We should probably remove this
+    //   method entirely.
+    return reinterpret_cast<typename TypeHandler::Type**>(raw_mutable_data());
+  }
+
+  template <typename TypeHandler>
+  const typename TypeHandler::Type* const* data() const {
+    // TODO(kenton):  Breaks C++ aliasing rules.  We should probably remove this
+    //   method entirely.
+    return reinterpret_cast<const typename TypeHandler::Type* const*>(
+        raw_data());
+  }
+
+  template <typename TypeHandler>
+  PROTOBUF_NDEBUG_INLINE void Swap(RepeatedArenaPtrFieldBase* other) {
+#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() != nullptr &&
+        GetOwningArena() == other->GetOwningArena())
+#else   // PROTOBUF_FORCE_COPY_IN_SWAP
+    if (GetOwningArena() == other->GetOwningArena())
+#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+    {
+      InternalSwap(other);
+    } else {
+      SwapFallback<TypeHandler>(other);
+    }
+  }
+
+  void SwapElements(int index1, int index2) {
+    using std::swap;  // enable ADL with fallback
+    swap(rep_->elements[index1], rep_->elements[index2]);
+  }
+
+  template <typename TypeHandler>
+  size_t SpaceUsedExcludingSelfLong() const {
+    size_t allocated_bytes = static_cast<size_t>(total_size_) * sizeof(void*);
+    if (rep_ != nullptr) {
+      for (int i = 0; i < rep_->allocated_size; ++i) {
+        allocated_bytes +=
+            TypeHandler::SpaceUsedLong(cast<TypeHandler>(rep_->elements[i]));
+      }
+      allocated_bytes += kRepHeaderSize;
+    }
+    return allocated_bytes;
+  }
+
+  // Advanced memory management --------------------------------------
+
+  // Like Add(), but if there are no cleared objects to use, returns nullptr.
+  template <typename TypeHandler>
+  typename TypeHandler::Type* AddFromCleared() {
+    if (rep_ != nullptr && current_size_ < rep_->allocated_size) {
+      return cast<TypeHandler>(rep_->elements[current_size_++]);
+    } else {
+      return nullptr;
+    }
+  }
+
+  template <typename TypeHandler>
+  void AddAllocated(typename TypeHandler::Type* value) {
+    typename TypeImplementsMergeBehavior<typename TypeHandler::Type>::type t;
+    AddAllocatedInternal<TypeHandler>(value, t);
+  }
+
+  template <typename TypeHandler>
+  void UnsafeArenaAddAllocated(typename TypeHandler::Type* value) {
+    // Make room for the new pointer.
+    if (!rep_ || current_size_ == total_size_) {
+      // The array is completely full with no cleared objects, so grow it.
+      Reserve(total_size_ + 1);
+      ++rep_->allocated_size;
+    } else if (rep_->allocated_size == total_size_) {
+      // There is no more space in the pointer array because it contains some
+      // cleared objects awaiting reuse.  We don't want to grow the array in
+      // this case because otherwise a loop calling AddAllocated() followed by
+      // Clear() would leak memory.
+      TypeHandler::Delete(cast<TypeHandler>(rep_->elements[current_size_]),
+                          arena_);
+    } else if (current_size_ < rep_->allocated_size) {
+      // We have some cleared objects.  We don't care about their order, so we
+      // can just move the first one to the end to make space.
+      rep_->elements[rep_->allocated_size] = rep_->elements[current_size_];
+      ++rep_->allocated_size;
+    } else {
+      // There are no cleared objects.
+      ++rep_->allocated_size;
+    }
+
+    rep_->elements[current_size_++] = value;
+  }
+
+  template <typename TypeHandler>
+  PROTOBUF_MUST_USE_RESULT typename TypeHandler::Type* ReleaseLast() {
+    typename TypeImplementsMergeBehavior<typename TypeHandler::Type>::type t;
+    return ReleaseLastInternal<TypeHandler>(t);
+  }
+
+  // Releases and returns the last element, but does not do out-of-arena copy.
+  // Instead, just returns the raw pointer to the contained element in the
+  // arena.
+  template <typename TypeHandler>
+  typename TypeHandler::Type* UnsafeArenaReleaseLast() {
+    GOOGLE_DCHECK_GT(current_size_, 0);
+    typename TypeHandler::Type* result =
+        cast<TypeHandler>(rep_->elements[--current_size_]);
+    --rep_->allocated_size;
+    if (current_size_ < rep_->allocated_size) {
+      // There are cleared elements on the end; replace the removed element
+      // with the last allocated element.
+      rep_->elements[current_size_] = rep_->elements[rep_->allocated_size];
+    }
+    return result;
+  }
+
+  int ClearedCount() const {
+    return rep_ ? (rep_->allocated_size - current_size_) : 0;
+  }
+
+  template <typename TypeHandler>
+  void AddCleared(typename TypeHandler::Type* value) {
+    GOOGLE_DCHECK(GetOwningArena() == nullptr) << "AddCleared() can only be used on a "
+                                           "RepeatedArenaPtrField not on an arena.";
+    GOOGLE_DCHECK(TypeHandler::GetOwningArena(value) == nullptr)
+        << "AddCleared() can only accept values not on an arena.";
+    if (!rep_ || rep_->allocated_size == total_size_) {
+      Reserve(total_size_ + 1);
+    }
+    rep_->elements[rep_->allocated_size++] = value;
+  }
+
+  template <typename TypeHandler>
+  PROTOBUF_MUST_USE_RESULT typename TypeHandler::Type* ReleaseCleared() {
+    GOOGLE_DCHECK(GetOwningArena() == nullptr)
+        << "ReleaseCleared() can only be used on a RepeatedArenaPtrField not on "
+        << "an arena.";
+    GOOGLE_DCHECK(GetOwningArena() == nullptr);
+    GOOGLE_DCHECK(rep_ != nullptr);
+    GOOGLE_DCHECK_GT(rep_->allocated_size, current_size_);
+    return cast<TypeHandler>(rep_->elements[--rep_->allocated_size]);
+  }
+
+  template <typename TypeHandler>
+  void AddAllocatedInternal(typename TypeHandler::Type* value, std::true_type) {
+    // AddAllocated version that implements arena-safe copying behavior.
+    Arena* element_arena =
+        reinterpret_cast<Arena*>(TypeHandler::GetOwningArena(value));
+    Arena* arena = GetOwningArena();
+    if (arena == element_arena && rep_ && rep_->allocated_size < total_size_) {
+      // Fast path: underlying arena representation (tagged pointer) is equal to
+      // our arena pointer, and we can add to array without resizing it (at
+      // least one slot that is not allocated).
+      void** elems = rep_->elements;
+      if (current_size_ < rep_->allocated_size) {
+        // Make space at [current] by moving first allocated element to end of
+        // allocated list.
+        elems[rep_->allocated_size] = elems[current_size_];
+      }
+      elems[current_size_] = value;
+      current_size_ = current_size_ + 1;
+      rep_->allocated_size = rep_->allocated_size + 1;
+    } else {
+      AddAllocatedSlowWithCopy<TypeHandler>(value, element_arena, arena);
+    }
+  }
+
+  template <typename TypeHandler>
+  void AddAllocatedInternal(
+      // AddAllocated version that does not implement arena-safe copying
+      // behavior.
+      typename TypeHandler::Type* value, std::false_type) {
+    if (rep_ && rep_->allocated_size < total_size_) {
+      // Fast path: underlying arena representation (tagged pointer) is equal to
+      // our arena pointer, and we can add to array without resizing it (at
+      // least one slot that is not allocated).
+      void** elems = rep_->elements;
+      if (current_size_ < rep_->allocated_size) {
+        // Make space at [current] by moving first allocated element to end of
+        // allocated list.
+        elems[rep_->allocated_size] = elems[current_size_];
+      }
+      elems[current_size_] = value;
+      current_size_ = current_size_ + 1;
+      ++rep_->allocated_size;
+    } else {
+      UnsafeArenaAddAllocated<TypeHandler>(value);
+    }
+  }
+
+  // Slowpath handles all cases, copying if necessary.
+  template <typename TypeHandler>
+  PROTOBUF_NOINLINE void AddAllocatedSlowWithCopy(
+      // Pass value_arena and my_arena to avoid duplicate virtual call (value)
+      // or load (mine).
+      typename TypeHandler::Type* value, Arena* value_arena, Arena* my_arena) {
+    // Ensure that either the value is in the same arena, or if not, we do the
+    // appropriate thing: Own() it (if it's on heap and we're in an arena) or
+    // copy it to our arena/heap (otherwise).
+    if (my_arena != nullptr && value_arena == nullptr) {
+      using OwnType = typename ::std::conditional<
+          ::std::is_same<void, typename TypeHandler::Type>::value,
+          ::std::string, typename TypeHandler::Type>::type;
+      my_arena->Own(reinterpret_cast<OwnType*>(value));
+    } else if (my_arena != value_arena) {
+      typename TypeHandler::Type* new_value =
+          TypeHandler::NewFromPrototype(value, my_arena);
+      TypeHandler::Merge(my_arena, value, new_value);
+      TypeHandler::Delete(value, value_arena);
+      value = new_value;
+    }
+
+    UnsafeArenaAddAllocated<TypeHandler>(value);
+  }
+
+  template <typename TypeHandler>
+  typename TypeHandler::Type* ReleaseLastInternal(std::true_type) {
+    // ReleaseLast() for types that implement merge/copy behavior.
+    // First, release an element.
+    typename TypeHandler::Type* result = UnsafeArenaReleaseLast<TypeHandler>();
+    // Now perform a copy if we're on an arena.
+    Arena* arena = GetOwningArena();
+
+    typename TypeHandler::Type* new_result;
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+    new_result = copy<TypeHandler>(result);
+    if (arena == nullptr) delete result;
+#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
+    new_result = (arena == nullptr) ? result : copy<TypeHandler>(result);
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+    return new_result;
+  }
+
+  template <typename TypeHandler>
+  typename TypeHandler::Type* ReleaseLastInternal(std::false_type) {
+    // ReleaseLast() for types that *do not* implement merge/copy behavior --
+    // this is the same as UnsafeArenaReleaseLast(). Note that we GOOGLE_DCHECK-fail if
+    // we're on an arena, since the user really should implement the copy
+    // operation in this case.
+    GOOGLE_DCHECK(GetOwningArena() == nullptr)
+        << "ReleaseLast() called on a RepeatedArenaPtrField that is on an arena, "
+        << "with a type that does not implement MergeFrom. This is unsafe; "
+        << "please implement MergeFrom for your type.";
+    return UnsafeArenaReleaseLast<TypeHandler>();
+  }
+
+  template <typename TypeHandler>
+  PROTOBUF_NOINLINE void SwapFallback(RepeatedArenaPtrFieldBase* other) {
+#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
+    GOOGLE_DCHECK(GetOwningArena() == nullptr ||
+           other->GetOwningArena() != GetOwningArena());
+#else   // PROTOBUF_FORCE_COPY_IN_SWAP
+    GOOGLE_DCHECK(other->GetOwningArena() != GetOwningArena());
+#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
+
+    // Copy semantics in this case. We try to improve efficiency by placing the
+    // temporary on |other|'s arena so that messages are copied twice rather
+    // than three times.
+    RepeatedArenaPtrFieldBase temp(other->GetOwningArena());
+    temp.MergeFrom<TypeHandler>(*this);
+    this->Clear<TypeHandler>();
+    this->MergeFrom<TypeHandler>(*other);
+    other->InternalSwap(&temp);
+    temp.Destroy<TypeHandler>();  // Frees rep_ if `other` had no arena.
+  }
+
+  inline Arena* GetArena() const { return arena_; }
+
+ protected:
+  inline Arena* GetOwningArena() const { return arena_; }
+
+ private:
+  template <typename T> friend class Arena::InternalHelper;
+
+  static constexpr int kInitialSize = 0;
+  // A few notes on internal representation:
+  //
+  // We use an indirected approach, with struct Rep, to keep
+  // sizeof(RepeatedArenaPtrFieldBase) equivalent to what it was before arena support
+  // was added; namely, 3 8-byte machine words on x86-64. An instance of Rep is
+  // allocated only when the repeated field is non-empty, and it is a
+  // dynamically-sized struct (the header is directly followed by elements[]).
+  // We place arena_ and current_size_ directly in the object to avoid cache
+  // misses due to the indirection, because these fields are checked frequently.
+  // Placing all fields directly in the RepeatedArenaPtrFieldBase instance would cost
+  // significant performance for memory-sensitive workloads.
+  Arena* arena_;
+  int current_size_;
+  int total_size_;
+  struct Rep {
+    int allocated_size;
+    // Here we declare a huge array as a way of approximating C's "flexible
+    // array member" feature without relying on undefined behavior.
+    void* elements[(std::numeric_limits<int>::max() - 2 * sizeof(int)) /
+                   sizeof(void*)];
+  };
+  static constexpr size_t kRepHeaderSize = offsetof(Rep, elements);
+  Rep* rep_;
+
+  template <typename TypeHandler>
+  static inline typename TypeHandler::Type* cast(void* element) {
+    return reinterpret_cast<typename TypeHandler::Type*>(element);
+  }
+  template <typename TypeHandler>
+  static inline const typename TypeHandler::Type* cast(const void* element) {
+    return reinterpret_cast<const typename TypeHandler::Type*>(element);
+  }
+
+  // Non-templated inner function to avoid code duplication. Takes a function
+  // pointer to the type-specific (templated) inner allocate/merge loop.
+  void MergeFromInternal(const RepeatedArenaPtrFieldBase& other,
+                         void (RepeatedArenaPtrFieldBase::*inner_loop)(void**,
+                                                                  void**, int,
+                                                                  int)) {
+    // Note: wrapper has already guaranteed that other.rep_ != nullptr here.
+    int other_size = other.current_size_;
+    void** other_elements = other.rep_->elements;
+    void** new_elements = InternalExtend(other_size);
+    int allocated_elems = rep_->allocated_size - current_size_;
+    (this->*inner_loop)(new_elements, other_elements, other_size,
+                        allocated_elems);
+    current_size_ += other_size;
+    if (rep_->allocated_size < current_size_) {
+      rep_->allocated_size = current_size_;
+    }
+  }
+
+  // Merges other_elems to our_elems.
+  template <typename TypeHandler>
+  PROTOBUF_NOINLINE void MergeFromInnerLoop(void** our_elems,
+                                            void** other_elems, int length,
+                                            int already_allocated) {
+    Arena* arena = GetOwningArena();
+    if (already_allocated < length) {
+      typename TypeHandler::Type* elem_prototype =
+          reinterpret_cast<typename TypeHandler::Type*>(other_elems[0]);
+      for (int i = already_allocated; i < length; i++) {
+        // Allocate a new empty element that we'll merge into below
+        typename TypeHandler::Type* new_elem =
+            TypeHandler::NewFromPrototype(elem_prototype, arena);
+        our_elems[i] = new_elem;
+      }
+    }
+    // Main loop that does the actual merging
+    for (int i = 0; i < length; i++) {
+      // Already allocated: use existing element.
+      typename TypeHandler::Type* other_elem =
+          reinterpret_cast<typename TypeHandler::Type*>(other_elems[i]);
+      typename TypeHandler::Type* new_elem =
+          reinterpret_cast<typename TypeHandler::Type*>(our_elems[i]);
+      TypeHandler::Merge(arena, other_elem, new_elem);
+    }
+  }
+
+  // Internal helper: extends array space if necessary to contain
+  // |extend_amount| more elements, and returns a pointer to the element
+  // immediately following the old list of elements.  This interface factors out
+  // common behavior from Reserve() and MergeFrom() to reduce code size.
+  // |extend_amount| must be > 0.
+  void** InternalExtend(int extend_amount);
+
+  // Internal helper for Add: adds "obj" as the next element in the
+  // array, including potentially resizing the array with Reserve if
+  // needed
+  void* AddOutOfLineHelper(void* obj);
+
+  // The reflection implementation needs to call protected methods directly,
+  // reinterpreting pointers as being to Message instead of a specific Message
+  // subclass.
+  friend class ::PROTOBUF_NAMESPACE_ID::Reflection;
+  friend class ::PROTOBUF_NAMESPACE_ID::internal::SwapFieldHelper;
+
+  // ExtensionSet stores repeated message extensions as
+  // RepeatedArenaPtrField<MessageLite>, but non-lite ExtensionSets need to implement
+  // SpaceUsedLong(), and thus need to call SpaceUsedExcludingSelfLong()
+  // reinterpreting MessageLite as Message.  ExtensionSet also needs to make use
+  // of AddFromCleared(), which is not part of the public interface.
+  friend class ExtensionSet;
+  friend class ExtensionSetWithArenaString;
+
+  // The MapFieldBase implementation needs to call protected methods directly,
+  // reinterpreting pointers as being to Message instead of a specific Message
+  // subclass.
+  friend class MapFieldBase;
+  friend class MapFieldBaseStub;
+
+  // The table-driven MergePartialFromCodedStream implementation needs to
+  // operate on RepeatedArenaPtrField<MessageLite>.
+  friend class MergePartialFromCodedStreamHelper;
+  friend class AccessorHelper;
+  template <typename T>
+  friend struct google::protobuf::WeakRepeatedArenaPtrField;
+  //friend class internal::TcParser;  // TODO(jorg): Remove this friend.
+};
+
+template <typename GenericType>
+class ArenaGenericTypeHandler {
+ public:
+  typedef GenericType Type;
+  using Movable = IsMovable<GenericType>;
+
+  static inline GenericType* New(Arena* arena) {
+    return Arena::CreateMaybeMessage<Type>(arena);
+  }
+  static inline GenericType* New(Arena* arena, GenericType&& value) {
+    return Arena::Create<GenericType>(arena, std::move(value));
+  }
+  static inline GenericType* NewFromPrototype(const GenericType* /*prototype*/,
+                                              Arena* arena = nullptr) {
+    return New(arena);
+  }
+  static inline void Delete(GenericType* value, Arena* arena) {
+    if (arena == nullptr) {
+      delete value;
+    }
+  }
+  static inline Arena* GetOwningArena(GenericType* value) {
+    return Arena::GetOwningArena<Type>(value);
+  }
+
+  static inline void Clear(GenericType* value) { value->Clear(); }
+  static void Merge(Arena* arena, const GenericType* from, GenericType* to);
+  static inline size_t SpaceUsedLong(const GenericType* value) {
+    return value->SpaceUsedLong();
+  }
+};
+
+// NewFromPrototypeHelper() is not defined inline here, as we will need to do a
+// virtual function dispatch anyways to go from Message* to call New/Merge. (The
+// additional helper is needed as a workaround for MSVC.)
+MessageLite* NewFromPrototypeHelper(const MessageLite* prototype, Arena* arena);
+
+template <>
+inline MessageLite* ArenaGenericTypeHandler<MessageLite>::NewFromPrototype(
+    const MessageLite* prototype, Arena* arena) {
+  return NewFromPrototypeHelper(prototype, arena);
+}
+template <>
+inline Arena* ArenaGenericTypeHandler<MessageLite>::GetOwningArena(
+    MessageLite* value) {
+  return value->GetOwningArena();
+}
+
+template <typename GenericType>
+PROTOBUF_NOINLINE inline void ArenaGenericTypeHandler<GenericType>::Merge(
+    Arena*, const GenericType* from, GenericType* to) {
+  to->MergeFrom(*from);
+}
+template <>
+void ArenaGenericTypeHandler<MessageLite>::Merge(Arena* arena,
+                                            const MessageLite* from,
+                                            MessageLite* to);
+
+// Message specialization bodies defined in message.cc. This split is necessary
+// to allow proto2-lite (which includes this header) to be independent of
+// Message.
+template <>
+PROTOBUF_EXPORT Message* ArenaGenericTypeHandler<Message>::NewFromPrototype(
+    const Message* prototype, Arena* arena);
+template <>
+PROTOBUF_EXPORT Arena* ArenaGenericTypeHandler<Message>::GetOwningArena(
+    Message* value);
+
+class ArenaStringTypeHandler {
+ public:
+  typedef void Type;
+  using Movable = IsMovable<::std::string>;
+
+  static inline Type* New(Arena* arena) {
+    TaggedStringPtrWithPatch ptr;
+    if (arena != nullptr) {
+      ptr.SetFixedSizeArena(ArenaStringAccessor::create(arena).underlying());
+    } else {
+      ptr.SetDefault(new std::string());
+    }
+    return ptr.GetTagged();
+  }
+  static inline Type* NewFromPrototype(const Type*,
+                                       Arena* arena) {
+    return New(arena);
+  }
+  static inline Arena* GetOwningArena(Type*) { return nullptr; }
+  static inline void Delete(Type* value, Arena* arena) {
+    if (arena == nullptr) {
+      delete reinterpret_cast<::std::string*>(value);
+    }
+  }
+  static inline void Clear(Type* value) {
+    MaybeArenaStringAccessor::clear(TaggedStringPtrWithPatch{value}.Get());
+  }
+  static inline void Merge(Arena* arena, const Type* from, Type* to) {
+    TaggedStringPtrWithPatch to_ptr {to};
+    TaggedStringPtrWithPatch from_ptr {from};
+    MaybeArenaStringAccessor{
+        to_ptr.IsFixedSizeArena() ? arena : nullptr, to_ptr.Get()} =
+            *from_ptr.Get();
+  }
+  static size_t SpaceUsedLong(const Type* value) {
+    return sizeof(std::string) +
+        StringSpaceUsedExcludingSelfLong(*TaggedStringPtrWithPatch{value}.Get());
+  }
+};
+
+}  // namespace internal
+
+// RepeatedArenaPtrField is like RepeatedField, but used for repeated strings or
+// Messages.
+template <typename Element>
+class RepeatedArenaPtrField final : private internal::RepeatedArenaPtrFieldBase {
+
+ public:
+  constexpr RepeatedArenaPtrField();
+  explicit RepeatedArenaPtrField(Arena* arena);
+
+  RepeatedArenaPtrField(const RepeatedArenaPtrField& other);
+
+  template <typename Iter,
+            typename = typename std::enable_if<std::is_constructible<
+                Element, decltype(*std::declval<Iter>())>::value>::type>
+  RepeatedArenaPtrField(Iter begin, Iter end);
+
+  ~RepeatedArenaPtrField();
+
+  RepeatedArenaPtrField& operator=(const RepeatedArenaPtrField& other);
+
+  RepeatedArenaPtrField(RepeatedArenaPtrField&& other) noexcept;
+  RepeatedArenaPtrField& operator=(RepeatedArenaPtrField&& other) noexcept;
+
+  bool empty() const;
+  int size() const;
+
+  const Element& Get(int index) const;
+  template <typename T = Element,
+            typename std::enable_if<
+                !std::is_same<T, std::string>::value, int>::type = 0>
+  Element* Mutable(int index);
+  template <typename T = Element,
+            typename std::enable_if<
+                std::is_same<T, std::string>::value, int>::type = 0>
+  MutableStringType Mutable(int index);
+  template <typename T = Element,
+            typename = typename std::enable_if<
+                std::is_same<T, std::string>::value>::type>
+  Element* MutableString(int index);
+  template <typename T = Element,
+            typename = typename std::enable_if<
+                std::is_same<T, std::string>::value>::type>
+  MaybeArenaStringAccessor MutableAccessor(int index);
+
+  // Unlike std::vector, adding an element to a RepeatedArenaPtrField doesn't always
+  // make a new element; it might re-use an element left over from when the
+  // field was Clear()'d or reize()'d smaller.  For this reason, Add() is the
+  // fastest API for adding a new element.
+  template <typename T = Element,
+            typename std::enable_if<
+                !std::is_same<T, std::string>::value, int>::type = 0>
+  Element* Add();
+  template <typename T = Element,
+            typename std::enable_if<
+                std::is_same<T, std::string>::value, int>::type = 0>
+  MutableStringType Add();
+  template <typename T = Element,
+            typename = typename std::enable_if<
+                std::is_same<T, std::string>::value>::type>
+  Element* AddString();
+  template <typename T = Element,
+            typename = typename std::enable_if<
+                std::is_same<T, std::string>::value>::type>
+  MaybeArenaStringAccessor AddAccessor();
+
+  // `Add(std::move(value));` is equivalent to `*Add() = std::move(value);`
+  // It will either move-construct to the end of this field, or swap value
+  // with the new-or-recycled element at the end of this field.  Note that
+  // this operation is very slow if this RepeatedArenaPtrField is not on the
+  // same Arena, if any, as `value`.
+  void Add(Element&& value);
+
+  // Copying to the end of this RepeatedArenaPtrField is slowest of all; it can't
+  // reliably copy-construct to the last element of this RepeatedArenaPtrField, for
+  // example (unlike std::vector).
+  // We currently block this API.  The right way to add to the end is to call
+  // Add() and modify the element it points to.
+  // If you must add an existing value, call `*Add() = value;`
+  void Add(const Element& value) = delete;
+
+  // Append elements in the range [begin, end) after reserving
+  // the appropriate number of elements.
+  template <typename Iter, typename T = Element,
+            typename std::enable_if<
+                !std::is_same<T, std::string>::value, int>::type = 0>
+  void Add(Iter begin, Iter end);
+  template <typename Iter, typename T = Element,
+            typename std::enable_if<
+                std::is_same<T, std::string>::value, int>::type = 0>
+  void Add(Iter begin, Iter end);
+
+  const Element& operator[](int index) const { return Get(index); }
+  template <typename T = Element,
+            typename std::enable_if<
+                !std::is_same<T, std::string>::value, int>::type = 0>
+  Element& operator[](int index) { return *Mutable(index); }
+  template <typename T = Element,
+            typename std::enable_if<
+                std::is_same<T, std::string>::value, int>::type = 0>
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  MaybeArenaStringAccessor operator[](int index) { return *MutableAccessor(index); }
+#else // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  Element& operator[](int index) { return *MutableString(index); }
+#endif // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+
+  const Element& at(int index) const;
+  template <typename T = Element,
+            typename std::enable_if<
+                !std::is_same<T, std::string>::value, int>::type = 0>
+  Element& at(int index);
+  template <typename T = Element,
+            typename std::enable_if<
+                std::is_same<T, std::string>::value, int>::type = 0>
+  MutableStringReferenceType at(int index);
+
+  // Removes the last element in the array.
+  // Ownership of the element is retained by the array.
+  void RemoveLast();
+
+  // Deletes elements with indices in the range [start .. start+num-1].
+  // Caution: moves all elements with indices [start+num .. ].
+  // Calling this routine inside a loop can cause quadratic behavior.
+  void DeleteSubrange(int start, int num);
+
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear();
+  void MergeFrom(const RepeatedArenaPtrField& other);
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void CopyFrom(const RepeatedArenaPtrField& other);
+
+  // Replaces the contents with RepeatedArenaPtrField(begin, end).
+  template <typename Iter>
+  PROTOBUF_ATTRIBUTE_REINITIALIZES void Assign(Iter begin, Iter end);
+
+  // Reserves space to expand the field to at least the given size.  This only
+  // resizes the pointer array; it doesn't allocate any objects.  If the
+  // array is grown, it will always be at least doubled in size.
+  void Reserve(int new_size);
+
+  int Capacity() const;
+
+  // Gets the underlying array.  This pointer is possibly invalidated by
+  // any add or remove operation.
+  //
+  // This API is deprecated. Instead of directly working with element array,
+  // use APIs in repeated_field_util.h; e.g. sorting, etc.
+  PROTOBUF_DEPRECATED_MSG("Use APIs in repeated_field_util.h")
+  Element** mutable_data();
+  const Element* const* data() const;
+
+  // Swaps entire contents with "other". If they are on separate arenas, then
+  // copies data.
+  void Swap(RepeatedArenaPtrField* other);
+
+  // Swaps entire contents with "other". Caller should guarantee that either
+  // both fields are on the same arena or both are on the heap. Swapping between
+  // different arenas with this function is disallowed and is caught via
+  // GOOGLE_DCHECK.
+  void UnsafeArenaSwap(RepeatedArenaPtrField* other);
+
+  // Swaps two elements.
+  void SwapElements(int index1, int index2);
+
+  // STL-like iterator support
+  typedef internal::RepeatedArenaPtrIterator<Element> iterator;
+  typedef internal::RepeatedArenaPtrIterator<const Element> const_iterator;
+  typedef Element value_type;
+  typedef value_type& reference;
+  typedef const value_type& const_reference;
+  typedef value_type* pointer;
+  typedef const value_type* const_pointer;
+  typedef int size_type;
+  typedef ptrdiff_t difference_type;
+
+  iterator begin();
+  const_iterator begin() const;
+  const_iterator cbegin() const;
+  iterator end();
+  const_iterator end() const;
+  const_iterator cend() const;
+
+  // Reverse iterator support
+  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
+  typedef std::reverse_iterator<iterator> reverse_iterator;
+  reverse_iterator rbegin() { return reverse_iterator(end()); }
+  const_reverse_iterator rbegin() const {
+    return const_reverse_iterator(end());
+  }
+  reverse_iterator rend() { return reverse_iterator(begin()); }
+  const_reverse_iterator rend() const {
+    return const_reverse_iterator(begin());
+  }
+
+  // Custom STL-like iterator that iterates over and returns the underlying
+  // pointers to Element rather than Element itself.
+  typedef internal::RepeatedArenaPtrOverPtrsIterator<Element*, void*>
+      pointer_iterator;
+  typedef internal::RepeatedArenaPtrOverPtrsIterator<const Element* const,
+                                                const void* const>
+      const_pointer_iterator;
+  pointer_iterator pointer_begin();
+  const_pointer_iterator pointer_begin() const;
+  pointer_iterator pointer_end();
+  const_pointer_iterator pointer_end() const;
+
+  // Returns (an estimate of) the number of bytes used by the repeated field,
+  // excluding sizeof(*this).
+  size_t SpaceUsedExcludingSelfLong() const;
+
+  int SpaceUsedExcludingSelf() const {
+    return internal::ToIntSize(SpaceUsedExcludingSelfLong());
+  }
+
+  // Advanced memory management --------------------------------------
+  // When hardcore memory management becomes necessary -- as it sometimes
+  // does here at Google -- the following methods may be useful.
+
+  // Adds an already-allocated object, passing ownership to the
+  // RepeatedArenaPtrField.
+  //
+  // Note that some special behavior occurs with respect to arenas:
+  //
+  //   (i) if this field holds submessages, the new submessage will be copied if
+  //   the original is in an arena and this RepeatedArenaPtrField is either in a
+  //   different arena, or on the heap.
+  //   (ii) if this field holds strings, the passed-in string *must* be
+  //   heap-allocated, not arena-allocated. There is no way to dynamically check
+  //   this at runtime, so User Beware.
+  void AddAllocated(Element* value);
+
+  // Removes and returns the last element, passing ownership to the caller.
+  // Requires:  size() > 0
+  //
+  // If this RepeatedArenaPtrField is on an arena, an object copy is required to pass
+  // ownership back to the user (for compatible semantics). Use
+  // UnsafeArenaReleaseLast() if this behavior is undesired.
+  PROTOBUF_MUST_USE_RESULT Element* ReleaseLast();
+
+  // Adds an already-allocated object, skipping arena-ownership checks. The user
+  // must guarantee that the given object is in the same arena as this
+  // RepeatedArenaPtrField.
+  // It is also useful in legacy code that uses temporary ownership to avoid
+  // copies. Example:
+  //   RepeatedArenaPtrField<T> temp_field;
+  //   temp_field.UnsafeArenaAddAllocated(new T);
+  //   ... // Do something with temp_field
+  //   temp_field.UnsafeArenaExtractSubrange(0, temp_field.size(), nullptr);
+  // If you put temp_field on the arena this fails, because the ownership
+  // transfers to the arena at the "AddAllocated" call and is not released
+  // anymore, causing a double delete. UnsafeArenaAddAllocated prevents this.
+  void UnsafeArenaAddAllocated(Element* value);
+
+  // Removes and returns the last element.  Unlike ReleaseLast, the returned
+  // pointer is always to the original object.  This may be in an arena, in
+  // which case it would have the arena's lifetime.
+  // Requires: current_size_ > 0
+  Element* UnsafeArenaReleaseLast();
+
+  // Extracts elements with indices in the range "[start .. start+num-1]".
+  // The caller assumes ownership of the extracted elements and is responsible
+  // for deleting them when they are no longer needed.
+  // If "elements" is non-nullptr, then pointers to the extracted elements
+  // are stored in "elements[0 .. num-1]" for the convenience of the caller.
+  // If "elements" is nullptr, then the caller must use some other mechanism
+  // to perform any further operations (like deletion) on these elements.
+  // Caution: implementation also moves elements with indices [start+num ..].
+  // Calling this routine inside a loop can cause quadratic behavior.
+  //
+  // Memory copying behavior is identical to ReleaseLast(), described above: if
+  // this RepeatedArenaPtrField is on an arena, an object copy is performed for each
+  // returned element, so that all returned element pointers are to
+  // heap-allocated copies. If this copy is not desired, the user should call
+  // UnsafeArenaExtractSubrange().
+  void ExtractSubrange(int start, int num, Element** elements);
+
+  // Identical to ExtractSubrange() described above, except that no object
+  // copies are ever performed. Instead, the raw object pointers are returned.
+  // Thus, if on an arena, the returned objects must not be freed, because they
+  // will not be heap-allocated objects.
+  void UnsafeArenaExtractSubrange(int start, int num, Element** elements);
+
+  // When elements are removed by calls to RemoveLast() or Clear(), they
+  // are not actually freed.  Instead, they are cleared and kept so that
+  // they can be reused later.  This can save lots of CPU time when
+  // repeatedly reusing a protocol message for similar purposes.
+  //
+  // Hardcore programs may choose to manipulate these cleared objects
+  // to better optimize memory management using the following routines.
+
+  // Gets the number of cleared objects that are currently being kept
+  // around for reuse.
+  int ClearedCount() const;
+#ifndef PROTOBUF_FUTURE_BREAKING_CHANGES
+  // Adds an element to the pool of cleared objects, passing ownership to
+  // the RepeatedArenaPtrField.  The element must be cleared prior to calling
+  // this method.
+  //
+  // This method cannot be called when either the repeated field or |value| is
+  // on an arena; both cases will trigger a GOOGLE_DCHECK-failure.
+  void AddCleared(Element* value);
+  // Removes and returns a single element from the cleared pool, passing
+  // ownership to the caller.  The element is guaranteed to be cleared.
+  // Requires:  ClearedCount() > 0
+  //
+  // This method cannot be called when the repeated field is on an arena; doing
+  // so will trigger a GOOGLE_DCHECK-failure.
+  PROTOBUF_MUST_USE_RESULT Element* ReleaseCleared();
+#endif  // !PROTOBUF_FUTURE_BREAKING_CHANGES
+
+  // Removes the element referenced by position.
+  //
+  // Returns an iterator to the element immediately following the removed
+  // element.
+  //
+  // Invalidates all iterators at or after the removed element, including end().
+  iterator erase(const_iterator position);
+
+  // Removes the elements in the range [first, last).
+  //
+  // Returns an iterator to the element immediately following the removed range.
+  //
+  // Invalidates all iterators at or after the removed range, including end().
+  iterator erase(const_iterator first, const_iterator last);
+
+  // Gets the arena on which this RepeatedArenaPtrField stores its elements.
+  inline Arena* GetArena() const;
+
+  // For internal use only.
+  //
+  // This is public due to it being called by generated code.
+  void InternalSwap(RepeatedArenaPtrField* other) {
+    internal::RepeatedArenaPtrFieldBase::InternalSwap(other);
+  }
+
+ private:
+  // Note:  RepeatedArenaPtrField SHOULD NOT be subclassed by users.
+  class TypeHandler;
+
+  // Internal version of GetArena().
+  inline Arena* GetOwningArena() const;
+
+  // Implementations for ExtractSubrange(). The copying behavior must be
+  // included only if the type supports the necessary operations (e.g.,
+  // MergeFrom()), so we must resolve this at compile time. ExtractSubrange()
+  // uses SFINAE to choose one of the below implementations.
+  void ExtractSubrangeInternal(int start, int num, Element** elements,
+                               std::true_type);
+  void ExtractSubrangeInternal(int start, int num, Element** elements,
+                               std::false_type);
+
+  friend class Arena;
+
+  template <typename T>
+  friend struct WeakRepeatedArenaPtrField;
+
+  typedef void InternalArenaConstructable_;
+
+};
+
+// -------------------------------------------------------------------
+
+template <typename Element>
+class RepeatedArenaPtrField<Element>::TypeHandler
+    : public internal::ArenaGenericTypeHandler<Element> {};
+
+template <>
+class RepeatedArenaPtrField<std::string>::TypeHandler
+    : public internal::ArenaStringTypeHandler {};
+
+template <typename Element>
+constexpr RepeatedArenaPtrField<Element>::RepeatedArenaPtrField()
+    : RepeatedArenaPtrFieldBase() {}
+
+template <typename Element>
+inline RepeatedArenaPtrField<Element>::RepeatedArenaPtrField(Arena* arena)
+    : RepeatedArenaPtrFieldBase(arena) {}
+
+template <typename Element>
+inline RepeatedArenaPtrField<Element>::RepeatedArenaPtrField(
+    const RepeatedArenaPtrField& other)
+    : RepeatedArenaPtrFieldBase() {
+  MergeFrom(other);
+}
+
+template <typename Element>
+template <typename Iter, typename>
+inline RepeatedArenaPtrField<Element>::RepeatedArenaPtrField(Iter begin, Iter end) {
+  Add(begin, end);
+}
+
+template <typename Element>
+RepeatedArenaPtrField<Element>::~RepeatedArenaPtrField() {
+#ifdef __cpp_if_constexpr
+  if constexpr (std::is_base_of<MessageLite, Element>::value) {
+#else
+  if (std::is_base_of<MessageLite, Element>::value) {
+#endif
+    if (NeedsDestroy()) DestroyProtos();
+  } else {
+    Destroy<TypeHandler>();
+  }
+}
+
+template <typename Element>
+inline RepeatedArenaPtrField<Element>& RepeatedArenaPtrField<Element>::operator=(
+    const RepeatedArenaPtrField& other) {
+  if (this != &other) CopyFrom(other);
+  return *this;
+}
+
+template <typename Element>
+inline RepeatedArenaPtrField<Element>::RepeatedArenaPtrField(
+    RepeatedArenaPtrField&& other) noexcept
+    : RepeatedArenaPtrField() {
+#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+  CopyFrom(other);
+#else   // PROTOBUF_FORCE_COPY_IN_MOVE
+  // We don't just call Swap(&other) here because it would perform 3 copies if
+  // other is on an arena. This field can't be on an arena because arena
+  // construction always uses the Arena* accepting constructor.
+  if (other.GetOwningArena()) {
+    CopyFrom(other);
+  } else {
+    InternalSwap(&other);
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+}
+
+template <typename Element>
+inline RepeatedArenaPtrField<Element>& RepeatedArenaPtrField<Element>::operator=(
+    RepeatedArenaPtrField&& other) noexcept {
+  // We don't just call Swap(&other) here because it would perform 3 copies if
+  // the two fields are on different arenas.
+  if (this != &other) {
+    if (GetOwningArena() != other.GetOwningArena()
+#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
+        || GetOwningArena() == nullptr
+#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
+    ) {
+      CopyFrom(other);
+    } else {
+      InternalSwap(&other);
+    }
+  }
+  return *this;
+}
+
+template <typename Element>
+inline bool RepeatedArenaPtrField<Element>::empty() const {
+  return RepeatedArenaPtrFieldBase::empty();
+}
+
+template <typename Element>
+inline int RepeatedArenaPtrField<Element>::size() const {
+  return RepeatedArenaPtrFieldBase::size();
+}
+
+template <typename Element>
+inline const Element& RepeatedArenaPtrField<Element>::Get(int index) const {
+  return *RepeatedArenaPtrFieldBase::Get<TypeHandler>(index);
+}
+
+template <>
+inline const std::string& RepeatedArenaPtrField<std::string>::Get(int index) const {
+  return *internal::TaggedStringPtrWithPatch{
+      RepeatedArenaPtrFieldBase::Get<TypeHandler>(index)}.Get();
+}
+
+template <typename Element>
+inline const Element& RepeatedArenaPtrField<Element>::at(int index) const {
+  return Get(index);
+}
+
+template <typename Element>
+template <typename T,
+          typename std::enable_if<
+              !std::is_same<T, std::string>::value, int>::type>
+inline Element& RepeatedArenaPtrField<Element>::at(int index) {
+  return RepeatedArenaPtrFieldBase::at<TypeHandler>(index);
+}
+
+template <typename Element>
+template <typename T,
+          typename std::enable_if<
+              std::is_same<T, std::string>::value, int>::type>
+inline MutableStringReferenceType RepeatedArenaPtrField<Element>::at(int index) {
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  return MutableAccessor(index);
+#else // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  return *MutableString(index);
+#endif // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+}
+
+template <typename Element>
+template <typename T,
+          typename std::enable_if<
+              !std::is_same<T, std::string>::value, int>::type>
+inline Element* RepeatedArenaPtrField<Element>::Mutable(int index) {
+  return RepeatedArenaPtrFieldBase::Mutable<TypeHandler>(index);
+}
+
+template <typename Element>
+template <typename T,
+          typename std::enable_if<
+              std::is_same<T, std::string>::value, int>::type>
+inline MutableStringType RepeatedArenaPtrField<Element>::Mutable(int index) {
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  return MutableAccessor(index);
+#else // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  return MutableString(index);
+#endif // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+}
+
+template <typename Element>
+template <typename T, typename>
+inline Element* RepeatedArenaPtrField<Element>::MutableString(int index) {
+  internal::TaggedStringPtrWithPatch ptr {
+      RepeatedArenaPtrFieldBase::Mutable<TypeHandler>(index)};
+  auto string = ptr.Get();
+  if (ptr.IsFixedSizeArena()) {
+    string = Arena::Create<std::string>(GetArena(), *string);
+    ptr.SetMutableArena(string);
+    raw_mutable_data()[index] = ptr.GetTagged();
+  }
+  return string;
+}
+
+template <typename Element>
+template <typename T, typename>
+inline MaybeArenaStringAccessor
+RepeatedArenaPtrField<Element>::MutableAccessor(int index) {
+  internal::TaggedStringPtrWithPatch ptr {
+      RepeatedArenaPtrFieldBase::Mutable<TypeHandler>(index)};
+  return MaybeArenaStringAccessor{
+      ptr.IsFixedSizeArena() ? GetArena() : nullptr, ptr.Get()};
+}
+
+template <typename Element>
+template <typename T,
+          typename std::enable_if<
+              !std::is_same<T, std::string>::value, int>::type>
+inline Element* RepeatedArenaPtrField<Element>::Add() {
+  return RepeatedArenaPtrFieldBase::Add<TypeHandler>();
+}
+
+template <typename Element>
+template <typename T,
+          typename std::enable_if<
+              std::is_same<T, std::string>::value, int>::type>
+inline MutableStringType RepeatedArenaPtrField<Element>::Add() {
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  return AddAccessor();
+#else // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+  return AddString();
+#endif // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+}
+
+template <typename Element>
+template <typename T, typename>
+inline Element* RepeatedArenaPtrField<Element>::AddString() {
+  internal::TaggedStringPtrWithPatch ptr {
+      RepeatedArenaPtrFieldBase::Add<TypeHandler>()};
+  auto string = ptr.Get();
+  if (ptr.IsFixedSizeArena()) {
+    string = Arena::Create<std::string>(GetArena(), *string);
+    ptr.SetMutableArena(string);
+    raw_mutable_data()[size() - 1] = ptr.GetTagged();
+  }
+  return string;
+}
+
+template <typename Element>
+template <typename T, typename>
+inline MaybeArenaStringAccessor RepeatedArenaPtrField<Element>::AddAccessor() {
+  internal::TaggedStringPtrWithPatch ptr {
+      RepeatedArenaPtrFieldBase::Add<TypeHandler>()};
+  return MaybeArenaStringAccessor{
+      ptr.IsFixedSizeArena() ? GetArena() : nullptr, ptr.Get()};
+}
+
+template <typename Element>
+inline void RepeatedArenaPtrField<Element>::Add(Element&& value) {
+  RepeatedArenaPtrFieldBase::Add<TypeHandler>(std::move(value));
+}
+
+template <>
+inline void RepeatedArenaPtrField<std::string>::Add(std::string&& value) {
+  AddAccessor() = std::move(value);
+}
+
+template <typename Element>
+template <typename Iter, typename T,
+          typename std::enable_if<
+              !std::is_same<T, std::string>::value, int>::type>
+inline void RepeatedArenaPtrField<Element>::Add(Iter begin, Iter end) {
+  if (std::is_base_of<
+          std::forward_iterator_tag,
+          typename std::iterator_traits<Iter>::iterator_category>::value) {
+    int reserve = std::distance(begin, end);
+    Reserve(size() + reserve);
+  }
+  for (; begin != end; ++begin) {
+    *Add() = *begin;
+  }
+}
+
+template <typename Element>
+template <typename Iter, typename T,
+          typename std::enable_if<
+              std::is_same<T, std::string>::value, int>::type>
+inline void RepeatedArenaPtrField<Element>::Add(Iter begin, Iter end) {
+  if (std::is_base_of<
+          std::forward_iterator_tag,
+          typename std::iterator_traits<Iter>::iterator_category>::value) {
+    int reserve = std::distance(begin, end);
+    Reserve(size() + reserve);
+  }
+  for (; begin != end; ++begin) {
+    AddAccessor() = *begin;
+  }
+}
+
+template <typename Element>
+inline void RepeatedArenaPtrField<Element>::RemoveLast() {
+  RepeatedArenaPtrFieldBase::RemoveLast<TypeHandler>();
+}
+
+template <typename Element>
+inline void RepeatedArenaPtrField<Element>::DeleteSubrange(int start, int num) {
+  GOOGLE_DCHECK_GE(start, 0);
+  GOOGLE_DCHECK_GE(num, 0);
+  GOOGLE_DCHECK_LE(start + num, size());
+  for (int i = 0; i < num; ++i) {
+    RepeatedArenaPtrFieldBase::Delete<TypeHandler>(start + i);
+  }
+  UnsafeArenaExtractSubrange(start, num, nullptr);
+}
+
+template <typename Element>
+inline void RepeatedArenaPtrField<Element>::ExtractSubrange(int start, int num,
+                                                       Element** elements) {
+  typename internal::TypeImplementsMergeBehavior<
+      typename TypeHandler::Type>::type t;
+  ExtractSubrangeInternal(start, num, elements, t);
+}
+
+// ExtractSubrange() implementation for types that implement merge/copy
+// behavior.
+template <typename Element>
+inline void RepeatedArenaPtrField<Element>::ExtractSubrangeInternal(
+    int start, int num, Element** elements, std::true_type) {
+  GOOGLE_DCHECK_GE(start, 0);
+  GOOGLE_DCHECK_GE(num, 0);
+  GOOGLE_DCHECK_LE(start + num, size());
+
+  if (num == 0) return;
+
+  GOOGLE_DCHECK_NE(elements, nullptr)
+      << "Releasing elements without transferring ownership is an unsafe "
+         "operation.  Use UnsafeArenaExtractSubrange.";
+  if (elements == nullptr) {
+    CloseGap(start, num);
+    return;
+  }
+
+  Arena* arena = GetOwningArena();
+#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
+  // Always copy.
+  for (int i = 0; i < num; ++i) {
+    elements[i] = copy<TypeHandler>(
+        RepeatedArenaPtrFieldBase::Mutable<TypeHandler>(i + start));
+  }
+  if (arena == nullptr) {
+    for (int i = 0; i < num; ++i) {
+      delete RepeatedArenaPtrFieldBase::Mutable<TypeHandler>(i + start);
+    }
+  }
+#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
+  // If we're on an arena, we perform a copy for each element so that the
+  // returned elements are heap-allocated. Otherwise, just forward it.
+  if (arena != nullptr) {
+    for (int i = 0; i < num; ++i) {
+      elements[i] = reinterpret_cast<Element*>(
+          copy<TypeHandler>(
+              RepeatedArenaPtrFieldBase::Mutable<TypeHandler>(i + start)));
+    }
+  } else {
+    for (int i = 0; i < num; ++i) {
+      elements[i] = reinterpret_cast<Element*>(
+          RepeatedArenaPtrFieldBase::Mutable<TypeHandler>(i + start));
+    }
+  }
+#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
+  CloseGap(start, num);
+}
+
+// ExtractSubrange() implementation for types that do not implement merge/copy
+// behavior.
+template <typename Element>
+inline void RepeatedArenaPtrField<Element>::ExtractSubrangeInternal(
+    int start, int num, Element** elements, std::false_type) {
+  // This case is identical to UnsafeArenaExtractSubrange(). However, since
+  // ExtractSubrange() must return heap-allocated objects by contract, and we
+  // cannot fulfill this contract if we are an on arena, we must GOOGLE_DCHECK() that
+  // we are not on an arena.
+  GOOGLE_DCHECK(GetOwningArena() == nullptr)
+      << "ExtractSubrange() when arena is non-nullptr is only supported when "
+      << "the Element type supplies a MergeFrom() operation to make copies.";
+  UnsafeArenaExtractSubrange(start, num, elements);
+}
+
+template <typename Element>
+inline void RepeatedArenaPtrField<Element>::UnsafeArenaExtractSubrange(
+    int start, int num, Element** elements) {
+  GOOGLE_DCHECK_GE(start, 0);
+  GOOGLE_DCHECK_GE(num, 0);
+  GOOGLE_DCHECK_LE(start + num, size());
+
+  if (num > 0) {
+    // Save the values of the removed elements if requested.
+    if (elements != nullptr) {
+      for (int i = 0; i < num; ++i) {
+        elements[i] = reinterpret_cast<Element*>(
+            RepeatedArenaPtrFieldBase::Mutable<TypeHandler>(i + start));
+      }
+    }
+    CloseGap(start, num);
+  }
+}
+
+template <typename Element>
+inline void RepeatedArenaPtrField<Element>::Clear() {
+  RepeatedArenaPtrFieldBase::Clear<TypeHandler>();
+}
+
+template <typename Element>
+inline void RepeatedArenaPtrField<Element>::MergeFrom(
+    const RepeatedArenaPtrField& other) {
+  RepeatedArenaPtrFieldBase::MergeFrom<TypeHandler>(other);
+}
+
+template <typename Element>
+inline void RepeatedArenaPtrField<Element>::CopyFrom(const RepeatedArenaPtrField& other) {
+  RepeatedArenaPtrFieldBase::CopyFrom<TypeHandler>(other);
+}
+
+template <typename Element>
+template <typename Iter>
+inline void RepeatedArenaPtrField<Element>::Assign(Iter begin, Iter end) {
+  Clear();
+  Add(begin, end);
+}
+
+template <typename Element>
+inline typename RepeatedArenaPtrField<Element>::iterator
+RepeatedArenaPtrField<Element>::erase(const_iterator position) {
+  return erase(position, position + 1);
+}
+
+template <typename Element>
+inline typename RepeatedArenaPtrField<Element>::iterator
+RepeatedArenaPtrField<Element>::erase(const_iterator first, const_iterator last) {
+  size_type pos_offset = std::distance(cbegin(), first);
+  size_type last_offset = std::distance(cbegin(), last);
+  DeleteSubrange(pos_offset, last_offset - pos_offset);
+  return begin() + pos_offset;
+}
+
+template <typename Element>
+inline Element** RepeatedArenaPtrField<Element>::mutable_data() {
+  return RepeatedArenaPtrFieldBase::mutable_data<TypeHandler>();
+}
+
+template <>
+inline ::std::string** RepeatedArenaPtrField<::std::string>::mutable_data() {
+  return reinterpret_cast<::std::string**>(RepeatedArenaPtrFieldBase::mutable_data<TypeHandler>());
+}
+
+template <typename Element>
+inline const Element* const* RepeatedArenaPtrField<Element>::data() const {
+  return RepeatedArenaPtrFieldBase::data<TypeHandler>();
+}
+
+template <>
+inline const ::std::string* const* RepeatedArenaPtrField<::std::string>::data() const {
+  return reinterpret_cast<const ::std::string* const*>(RepeatedArenaPtrFieldBase::data<TypeHandler>());
+}
+
+template <typename Element>
+inline void RepeatedArenaPtrField<Element>::Swap(RepeatedArenaPtrField* other) {
+  if (this == other) return;
+  RepeatedArenaPtrFieldBase::Swap<TypeHandler>(other);
+}
+
+template <typename Element>
+inline void RepeatedArenaPtrField<Element>::UnsafeArenaSwap(
+    RepeatedArenaPtrField* other) {
+  if (this == other) return;
+  GOOGLE_DCHECK_EQ(GetOwningArena(), other->GetOwningArena());
+  RepeatedArenaPtrFieldBase::InternalSwap(other);
+}
+
+template <typename Element>
+inline void RepeatedArenaPtrField<Element>::SwapElements(int index1, int index2) {
+  RepeatedArenaPtrFieldBase::SwapElements(index1, index2);
+}
+
+template <typename Element>
+inline Arena* RepeatedArenaPtrField<Element>::GetArena() const {
+  return RepeatedArenaPtrFieldBase::GetArena();
+}
+
+template <typename Element>
+inline Arena* RepeatedArenaPtrField<Element>::GetOwningArena() const {
+  return RepeatedArenaPtrFieldBase::GetOwningArena();
+}
+
+template <typename Element>
+inline size_t RepeatedArenaPtrField<Element>::SpaceUsedExcludingSelfLong() const {
+  return RepeatedArenaPtrFieldBase::SpaceUsedExcludingSelfLong<TypeHandler>();
+}
+
+template <typename Element>
+inline void RepeatedArenaPtrField<Element>::AddAllocated(Element* value) {
+  RepeatedArenaPtrFieldBase::AddAllocated<TypeHandler>(
+      reinterpret_cast<typename TypeHandler::Type*>(value));
+}
+
+template <typename Element>
+inline void RepeatedArenaPtrField<Element>::UnsafeArenaAddAllocated(Element* value) {
+  RepeatedArenaPtrFieldBase::UnsafeArenaAddAllocated<TypeHandler>(
+      reinterpret_cast<typename TypeHandler::Type*>(value));
+}
+
+template <typename Element>
+inline Element* RepeatedArenaPtrField<Element>::ReleaseLast() {
+  return RepeatedArenaPtrFieldBase::ReleaseLast<TypeHandler>();
+}
+
+template <>
+inline std::string* RepeatedArenaPtrField<std::string>::ReleaseLast() {
+  internal::TaggedStringPtrWithPatch ptr {
+      RepeatedArenaPtrFieldBase::UnsafeArenaReleaseLast<TypeHandler>()};
+  auto arena = GetArena();
+  auto string = ptr.Get();
+  if (ptr.IsFixedSizeArena()) {
+    string = new std::string(*string);
+  } else if (arena != nullptr) {
+    string = new std::string(::std::move(*const_cast<std::string*>(string)));
+  }
+  return string;
+}
+
+template <typename Element>
+inline Element* RepeatedArenaPtrField<Element>::UnsafeArenaReleaseLast() {
+  return reinterpret_cast<Element*>(
+      RepeatedArenaPtrFieldBase::UnsafeArenaReleaseLast<TypeHandler>());
+}
+
+template <typename Element>
+inline int RepeatedArenaPtrField<Element>::ClearedCount() const {
+  return RepeatedArenaPtrFieldBase::ClearedCount();
+}
+
+#ifndef PROTOBUF_FUTURE_BREAKING_CHANGES
+template <typename Element>
+inline void RepeatedArenaPtrField<Element>::AddCleared(Element* value) {
+  return RepeatedArenaPtrFieldBase::AddCleared<TypeHandler>(
+      reinterpret_cast<typename TypeHandler::Type*>(value));
+}
+
+template <typename Element>
+inline Element* RepeatedArenaPtrField<Element>::ReleaseCleared() {
+  return reinterpret_cast<Element*>(
+      RepeatedArenaPtrFieldBase::ReleaseCleared<TypeHandler>());
+}
+#endif  // !PROTOBUF_FUTURE_BREAKING_CHANGES
+
+template <typename Element>
+inline void RepeatedArenaPtrField<Element>::Reserve(int new_size) {
+  return RepeatedArenaPtrFieldBase::Reserve(new_size);
+}
+
+template <typename Element>
+inline int RepeatedArenaPtrField<Element>::Capacity() const {
+  return RepeatedArenaPtrFieldBase::Capacity();
+}
+
+// -------------------------------------------------------------------
+
+namespace internal {
+
+// STL-like iterator implementation for RepeatedArenaPtrField.  You should not
+// refer to this class directly; use RepeatedArenaPtrField<T>::iterator instead.
+//
+// The iterator for RepeatedArenaPtrField<T>, RepeatedArenaPtrIterator<T>, is
+// very similar to iterator_ptr<T**> in util/gtl/iterator_adaptors.h,
+// but adds random-access operators and is modified to wrap a void** base
+// iterator (since RepeatedArenaPtrField stores its array as a void* array and
+// casting void** to T** would violate C++ aliasing rules).
+//
+// This code based on net/proto/proto-array-internal.h by Jeffrey Yasskin
+// (jyasskin@google.com).
+template <typename Element>
+class RepeatedArenaPtrIterator {
+ public:
+  using iterator = RepeatedArenaPtrIterator<Element>;
+  using iterator_category = std::random_access_iterator_tag;
+  using value_type = typename std::remove_const<Element>::type;
+  using difference_type = std::ptrdiff_t;
+  using pointer = typename std::conditional<
+      std::is_same<std::string, Element>::value,
+      MutableStringType, Element*>::type;
+  using reference = typename std::conditional<
+      std::is_same<std::string, Element>::value,
+      MutableStringReferenceType, Element&>::type;
+
+  RepeatedArenaPtrIterator() : it_(nullptr) {}
+  explicit RepeatedArenaPtrIterator(void* const* it) : it_(it) {}
+  RepeatedArenaPtrIterator(void* const* it, Arena* arena) : it_(it), arena_(arena) {}
+
+  // Allows "upcasting" from RepeatedArenaPtrIterator<T**> to
+  // RepeatedArenaPtrIterator<const T*const*>.
+  template <typename OtherElement,
+            typename std::enable_if<std::is_convertible<
+                OtherElement*, pointer>::value>::type* = nullptr>
+  RepeatedArenaPtrIterator(const RepeatedArenaPtrIterator<OtherElement>& other)
+      : it_(other.it_), arena_(other.arena_) {}
+
+  // dereferenceable
+  reference operator*() const { return *reinterpret_cast<Element*>(*it_); }
+  pointer operator->() const { return &(operator*()); }
+
+  // {inc,dec}rementable
+  iterator& operator++() {
+    ++it_;
+    return *this;
+  }
+  iterator operator++(int) { return iterator(it_++); }
+  iterator& operator--() {
+    --it_;
+    return *this;
+  }
+  iterator operator--(int) { return iterator(it_--); }
+
+  // equality_comparable
+  friend bool operator==(const iterator& x, const iterator& y) {
+    return x.it_ == y.it_;
+  }
+  friend bool operator!=(const iterator& x, const iterator& y) {
+    return x.it_ != y.it_;
+  }
+
+  // less_than_comparable
+  friend bool operator<(const iterator& x, const iterator& y) {
+    return x.it_ < y.it_;
+  }
+  friend bool operator<=(const iterator& x, const iterator& y) {
+    return x.it_ <= y.it_;
+  }
+  friend bool operator>(const iterator& x, const iterator& y) {
+    return x.it_ > y.it_;
+  }
+  friend bool operator>=(const iterator& x, const iterator& y) {
+    return x.it_ >= y.it_;
+  }
+
+  // addable, subtractable
+  iterator& operator+=(difference_type d) {
+    it_ += d;
+    return *this;
+  }
+  friend iterator operator+(iterator it, const difference_type d) {
+    it += d;
+    return it;
+  }
+  friend iterator operator+(const difference_type d, iterator it) {
+    it += d;
+    return it;
+  }
+  iterator& operator-=(difference_type d) {
+    it_ -= d;
+    return *this;
+  }
+  friend iterator operator-(iterator it, difference_type d) {
+    it -= d;
+    return it;
+  }
+
+  // indexable
+  reference operator[](difference_type d) const { return *(*this + d); }
+
+  // random access iterator
+  friend difference_type operator-(iterator it1, iterator it2) {
+    return it1.it_ - it2.it_;
+  }
+
+ private:
+  template <typename OtherElement>
+  friend class RepeatedArenaPtrIterator;
+
+  // The internal iterator.
+  void* const* it_;
+  Arena* arena_;
+};
+
+template <>
+inline const std::string&
+RepeatedArenaPtrIterator<const std::string>::operator*() const {
+  return *TaggedStringPtrWithPatch{*it_}.Get();
+}
+
+#if GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+template <>
+inline MaybeArenaStringAccessor
+RepeatedArenaPtrIterator<std::string>::operator*() const {
+  TaggedStringPtrWithPatch ptr {*it_};
+  return MaybeArenaStringAccessor{ptr.IsFixedSizeArena() ? arena_ : nullptr,
+                                  ptr.Get()};
+}
+template <>
+inline MaybeArenaStringAccessor
+RepeatedArenaPtrIterator<std::string>::operator->() const {
+  return operator*();
+}
+#else // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+template <>
+inline std::string& RepeatedArenaPtrIterator<std::string>::operator*() const {
+  TaggedStringPtrWithPatch ptr {*it_};
+  auto string = ptr.Get();
+  if (ptr.IsFixedSizeArena()) {
+    string = Arena::Create<std::string>(arena_, *string);
+    ptr.SetMutableArena(string);
+    *const_cast<void**>(it_) = ptr.GetTagged();
+  }
+  return *string;
+}
+#endif // !GOOGLE_PROTOBUF_MUTABLE_DONATED_STRING
+
+// Provides an iterator that operates on pointers to the underlying objects
+// rather than the objects themselves as RepeatedArenaPtrIterator does.
+// Consider using this when working with stl algorithms that change
+// the array.
+// The VoidPtr template parameter holds the type-agnostic pointer value
+// referenced by the iterator.  It should either be "void *" for a mutable
+// iterator, or "const void* const" for a constant iterator.
+template <typename Element, typename VoidPtr>
+class RepeatedArenaPtrOverPtrsIterator {
+ public:
+  using iterator = RepeatedArenaPtrOverPtrsIterator<Element, VoidPtr>;
+  using iterator_category = std::random_access_iterator_tag;
+  using value_type = typename std::remove_const<Element>::type;
+  using difference_type = std::ptrdiff_t;
+  using pointer = Element*;
+  using reference = Element&;
+
+  RepeatedArenaPtrOverPtrsIterator() : it_(nullptr) {}
+  explicit RepeatedArenaPtrOverPtrsIterator(VoidPtr* it) : it_(it) {}
+
+  // Allows "upcasting" from RepeatedArenaPtrOverPtrsIterator<T**> to
+  // RepeatedArenaPtrOverPtrsIterator<const T*const*>.
+  template <
+      typename OtherElement, typename OtherVoidPtr,
+      typename std::enable_if<
+          std::is_convertible<OtherElement*, pointer>::value &&
+          std::is_convertible<OtherVoidPtr*, VoidPtr>::value>::type* = nullptr>
+  RepeatedArenaPtrOverPtrsIterator(
+      const RepeatedArenaPtrOverPtrsIterator<OtherElement, OtherVoidPtr>& other)
+      : it_(other.it_) {}
+
+  // dereferenceable
+  reference operator*() const { return *reinterpret_cast<Element*>(it_); }
+  pointer operator->() const { return &(operator*()); }
+
+  // {inc,dec}rementable
+  iterator& operator++() {
+    ++it_;
+    return *this;
+  }
+  iterator operator++(int) { return iterator(it_++); }
+  iterator& operator--() {
+    --it_;
+    return *this;
+  }
+  iterator operator--(int) { return iterator(it_--); }
+
+  // equality_comparable
+  friend bool operator==(const iterator& x, const iterator& y) {
+    return x.it_ == y.it_;
+  }
+  friend bool operator!=(const iterator& x, const iterator& y) {
+    return x.it_ != y.it_;
+  }
+
+  // less_than_comparable
+  friend bool operator<(const iterator& x, const iterator& y) {
+    return x.it_ < y.it_;
+  }
+  friend bool operator<=(const iterator& x, const iterator& y) {
+    return x.it_ <= y.it_;
+  }
+  friend bool operator>(const iterator& x, const iterator& y) {
+    return x.it_ > y.it_;
+  }
+  friend bool operator>=(const iterator& x, const iterator& y) {
+    return x.it_ >= y.it_;
+  }
+
+  // addable, subtractable
+  iterator& operator+=(difference_type d) {
+    it_ += d;
+    return *this;
+  }
+  friend iterator operator+(iterator it, difference_type d) {
+    it += d;
+    return it;
+  }
+  friend iterator operator+(difference_type d, iterator it) {
+    it += d;
+    return it;
+  }
+  iterator& operator-=(difference_type d) {
+    it_ -= d;
+    return *this;
+  }
+  friend iterator operator-(iterator it, difference_type d) {
+    it -= d;
+    return it;
+  }
+
+  // indexable
+  reference operator[](difference_type d) const { return *(*this + d); }
+
+  // random access iterator
+  friend difference_type operator-(iterator it1, iterator it2) {
+    return it1.it_ - it2.it_;
+  }
+
+ private:
+  template <typename OtherElement, typename OtherVoidPtr>
+  friend class RepeatedArenaPtrOverPtrsIterator;
+
+  // The internal iterator.
+  VoidPtr* it_;
+};
+
+}  // namespace internal
+
+template <typename Element>
+inline typename RepeatedArenaPtrField<Element>::iterator
+RepeatedArenaPtrField<Element>::begin() {
+  return iterator(raw_data(), GetArena());
+}
+template <typename Element>
+inline typename RepeatedArenaPtrField<Element>::const_iterator
+RepeatedArenaPtrField<Element>::begin() const {
+  return iterator(raw_data(), GetArena());
+}
+template <typename Element>
+inline typename RepeatedArenaPtrField<Element>::const_iterator
+RepeatedArenaPtrField<Element>::cbegin() const {
+  return begin();
+}
+template <typename Element>
+inline typename RepeatedArenaPtrField<Element>::iterator
+RepeatedArenaPtrField<Element>::end() {
+  return iterator(raw_data() + size(), GetArena());
+}
+template <typename Element>
+inline typename RepeatedArenaPtrField<Element>::const_iterator
+RepeatedArenaPtrField<Element>::end() const {
+  return iterator(raw_data() + size(), GetArena());
+}
+template <typename Element>
+inline typename RepeatedArenaPtrField<Element>::const_iterator
+RepeatedArenaPtrField<Element>::cend() const {
+  return end();
+}
+
+template <typename Element>
+inline typename RepeatedArenaPtrField<Element>::pointer_iterator
+RepeatedArenaPtrField<Element>::pointer_begin() {
+  return pointer_iterator(raw_mutable_data());
+}
+template <typename Element>
+inline typename RepeatedArenaPtrField<Element>::const_pointer_iterator
+RepeatedArenaPtrField<Element>::pointer_begin() const {
+  return const_pointer_iterator(const_cast<const void* const*>(raw_data()));
+}
+template <typename Element>
+inline typename RepeatedArenaPtrField<Element>::pointer_iterator
+RepeatedArenaPtrField<Element>::pointer_end() {
+  return pointer_iterator(raw_mutable_data() + size());
+}
+template <typename Element>
+inline typename RepeatedArenaPtrField<Element>::const_pointer_iterator
+RepeatedArenaPtrField<Element>::pointer_end() const {
+  return const_pointer_iterator(
+      const_cast<const void* const*>(raw_data() + size()));
+}
+
+// Iterators and helper functions that follow the spirit of the STL
+// std::back_insert_iterator and std::back_inserter but are tailor-made
+// for RepeatedField and RepeatedArenaPtrField. Typical usage would be:
+//
+//   std::copy(some_sequence.begin(), some_sequence.end(),
+//             RepeatedFieldBackInserter(proto.mutable_sequence()));
+//
+// Ported by johannes from util/gtl/proto-array-iterators.h
+
+namespace internal {
+
+// A back inserter for RepeatedArenaPtrField objects.
+template <typename T>
+class RepeatedArenaPtrFieldBackInsertIterator {
+ public:
+  using iterator_category = std::output_iterator_tag;
+  using value_type = T;
+  using pointer = void;
+  using reference = void;
+  using difference_type = std::ptrdiff_t;
+
+  RepeatedArenaPtrFieldBackInsertIterator(RepeatedArenaPtrField<T>* const mutable_field)
+      : field_(mutable_field) {}
+  RepeatedArenaPtrFieldBackInsertIterator<T>& operator=(const T& value) {
+    *field_->Add() = value;
+    return *this;
+  }
+  RepeatedArenaPtrFieldBackInsertIterator<T>& operator=(
+      const T* const ptr_to_value) {
+    *field_->Add() = *ptr_to_value;
+    return *this;
+  }
+  RepeatedArenaPtrFieldBackInsertIterator<T>& operator=(T&& value) {
+    *field_->Add() = std::move(value);
+    return *this;
+  }
+  RepeatedArenaPtrFieldBackInsertIterator<T>& operator*() { return *this; }
+  RepeatedArenaPtrFieldBackInsertIterator<T>& operator++() { return *this; }
+  RepeatedArenaPtrFieldBackInsertIterator<T>& operator++(int /* unused */) {
+    return *this;
+  }
+
+ private:
+  RepeatedArenaPtrField<T>* field_;
+};
+
+// A back inserter for RepeatedArenaPtrFields that inserts by transferring ownership
+// of a pointer.
+template <typename T>
+class AllocatedRepeatedArenaPtrFieldBackInsertIterator {
+ public:
+  using iterator_category = std::output_iterator_tag;
+  using value_type = T;
+  using pointer = void;
+  using reference = void;
+  using difference_type = std::ptrdiff_t;
+
+  explicit AllocatedRepeatedArenaPtrFieldBackInsertIterator(
+      RepeatedArenaPtrField<T>* const mutable_field)
+      : field_(mutable_field) {}
+  AllocatedRepeatedArenaPtrFieldBackInsertIterator<T>& operator=(
+      T* const ptr_to_value) {
+    field_->AddAllocated(ptr_to_value);
+    return *this;
+  }
+  AllocatedRepeatedArenaPtrFieldBackInsertIterator<T>& operator*() { return *this; }
+  AllocatedRepeatedArenaPtrFieldBackInsertIterator<T>& operator++() { return *this; }
+  AllocatedRepeatedArenaPtrFieldBackInsertIterator<T>& operator++(int /* unused */) {
+    return *this;
+  }
+
+ private:
+  RepeatedArenaPtrField<T>* field_;
+};
+
+// Almost identical to AllocatedRepeatedArenaPtrFieldBackInsertIterator. This one
+// uses the UnsafeArenaAddAllocated instead.
+template <typename T>
+class UnsafeArenaAllocatedRepeatedArenaPtrFieldBackInsertIterator {
+ public:
+  using iterator_category = std::output_iterator_tag;
+  using value_type = T;
+  using pointer = void;
+  using reference = void;
+  using difference_type = std::ptrdiff_t;
+
+  explicit UnsafeArenaAllocatedRepeatedArenaPtrFieldBackInsertIterator(
+      RepeatedArenaPtrField<T>* const mutable_field)
+      : field_(mutable_field) {}
+  UnsafeArenaAllocatedRepeatedArenaPtrFieldBackInsertIterator<T>& operator=(
+      T const* const ptr_to_value) {
+    field_->UnsafeArenaAddAllocated(const_cast<T*>(ptr_to_value));
+    return *this;
+  }
+  UnsafeArenaAllocatedRepeatedArenaPtrFieldBackInsertIterator<T>& operator*() {
+    return *this;
+  }
+  UnsafeArenaAllocatedRepeatedArenaPtrFieldBackInsertIterator<T>& operator++() {
+    return *this;
+  }
+  UnsafeArenaAllocatedRepeatedArenaPtrFieldBackInsertIterator<T>& operator++(
+      int /* unused */) {
+    return *this;
+  }
+
+ private:
+  RepeatedArenaPtrField<T>* field_;
+};
+
+}  // namespace internal
+
+// Provides a back insert iterator for RepeatedArenaPtrField instances,
+// similar to std::back_inserter().
+template <typename T>
+internal::RepeatedArenaPtrFieldBackInsertIterator<T> RepeatedArenaPtrFieldBackInserter(
+    RepeatedArenaPtrField<T>* const mutable_field) {
+  return internal::RepeatedArenaPtrFieldBackInsertIterator<T>(mutable_field);
+}
+
+// Special back insert iterator for RepeatedArenaPtrField instances, just in
+// case someone wants to write generic template code that can access both
+// RepeatedFields and RepeatedArenaPtrFields using a common name.
+template <typename T>
+internal::RepeatedArenaPtrFieldBackInsertIterator<T> RepeatedFieldBackInserter(
+    RepeatedArenaPtrField<T>* const mutable_field) {
+  return internal::RepeatedArenaPtrFieldBackInsertIterator<T>(mutable_field);
+}
+
+// Provides a back insert iterator for RepeatedArenaPtrField instances
+// similar to std::back_inserter() which transfers the ownership while
+// copying elements.
+template <typename T>
+internal::AllocatedRepeatedArenaPtrFieldBackInsertIterator<T>
+AllocatedRepeatedArenaPtrFieldBackInserter(
+    RepeatedArenaPtrField<T>* const mutable_field) {
+  return internal::AllocatedRepeatedArenaPtrFieldBackInsertIterator<T>(
+      mutable_field);
+}
+
+// Similar to AllocatedRepeatedArenaPtrFieldBackInserter, using
+// UnsafeArenaAddAllocated instead of AddAllocated.
+// This is slightly faster if that matters. It is also useful in legacy code
+// that uses temporary ownership to avoid copies. Example:
+//   RepeatedArenaPtrField<T> temp_field;
+//   temp_field.UnsafeArenaAddAllocated(new T);
+//   ... // Do something with temp_field
+//   temp_field.UnsafeArenaExtractSubrange(0, temp_field.size(), nullptr);
+// Putting temp_field on the arena fails because the ownership transfers to the
+// arena at the "AddAllocated" call and is not released anymore causing a
+// double delete. This function uses UnsafeArenaAddAllocated to prevent this.
+template <typename T>
+internal::UnsafeArenaAllocatedRepeatedArenaPtrFieldBackInsertIterator<T>
+UnsafeArenaAllocatedRepeatedArenaPtrFieldBackInserter(
+    RepeatedArenaPtrField<T>* const mutable_field) {
+  return internal::UnsafeArenaAllocatedRepeatedArenaPtrFieldBackInsertIterator<T>(
+      mutable_field);
+}
+
+extern template class PROTOBUF_EXPORT_TEMPLATE_DECLARE
+    RepeatedArenaPtrField<std::string>;
+
+}  // namespace protobuf
+}  // namespace google
+
+#include <google/protobuf/port_undef.inc>
+
+#endif  // GOOGLE_PROTOBUF_REPEATED_ARENASTRING_FIELD_H__
diff --git a/src/google/protobuf/port.h b/src/google/protobuf/port.h
index 4c09eb1db..5f0e9a24e 100644
--- a/src/google/protobuf/port.h
+++ b/src/google/protobuf/port.h
@@ -36,5 +36,27 @@
 #ifndef GOOGLE_PROTOBUF_PORT_H__
 #define GOOGLE_PROTOBUF_PORT_H__
 
+#include <cstddef>
+#include <new>
+namespace google {
+namespace protobuf {
+namespace internal {
+inline void SizedDelete(void* p, size_t size) {
+#if defined(__cpp_sized_deallocation)
+  ::operator delete(p, size);
+#else
+  ::operator delete(p);
+#endif
+}
+// Tag type used to invoke the constinit constructor overload of classes
+// such as ArenaStringPtr and MapFieldBase. Such constructors are internal
+// implementation details of the library.
+struct ConstantInitialized {
+  explicit ConstantInitialized() = default;
+};
+
+}  // namespace internal
+}  // namespace protobuf
+}  // namespace google
 
 #endif  // GOOGLE_PROTOBUF_PORT_H__
diff --git a/src/google/protobuf/wire_format_lite.h b/src/google/protobuf/wire_format_lite.h
index 83668e9c0..0bdeb5257 100644
--- a/src/google/protobuf/wire_format_lite.h
+++ b/src/google/protobuf/wire_format_lite.h
@@ -46,6 +46,7 @@
 #include <google/protobuf/stubs/logging.h>
 #include <google/protobuf/io/coded_stream.h>
 #include <google/protobuf/arenastring.h>
+#include <google/protobuf/patch/arenastring.h>
 #include <google/protobuf/message_lite.h>
 #include <google/protobuf/port.h>
 #include <google/protobuf/repeated_field.h>
@@ -319,6 +320,10 @@ class PROTOBUF_EXPORT WireFormatLite {
   static bool ReadBytes(io::CodedInputStream* input, std::string* value);
   static bool ReadBytes(io::CodedInputStream* input, std::string** p);
 
+  // Implemented in arenastring.cc
+  static bool ReadArenaString(io::CodedInputStream* input,
+                                     MaybeArenaStringAccessor s);
+
   enum Operation {
     PARSE = 0,
     SERIALIZE = 1,
